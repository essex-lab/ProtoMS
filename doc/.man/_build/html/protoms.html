<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Design of ProtoMS &mdash; ProtoMS v3.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="ProtoMS v3.1 documentation" href="index.html" />
    <link rel="next" title="protoms.py" href="protomspy.html" />
    <link rel="prev" title="Compilation and Installation" href="compilation.html" /> 
  </head>
  <body>

<!--<div style="background-color: white; text-align: center; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/logo.png" border="0" alt="py4sci" style="width: 10em"/></a>
</div>-->

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="protomspy.html" title="protoms.py"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="compilation.html" title="Compilation and Installation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/dolphin.png" alt="Logo"/>
            </a></p>
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Design of ProtoMS</a><ul>
<li><a class="reference external" href="#proteins-solutes-solvents-gcsolutes">Proteins / Solutes / Solvents / GCSolutes</a></li>
<li><a class="reference external" href="#classical-forcefields">Classical forcefields</a></li>
<li><a class="reference external" href="#perturbations">Perturbations</a></li>
<li><a class="reference external" href="#generic-moves">Generic Moves</a></li>
</ul>
</li>
<li><a class="reference external" href="#executing-protoms">Executing ProtoMS</a><ul>
<li><a class="reference external" href="#file-output">File output</a></li>
<li><a class="reference external" href="#simulation-parameters">Simulation parameters</a><ul>
<li><a class="reference external" href="#parameters-for-developers">Parameters for developers</a></li>
<li><a class="reference external" href="#general-parameters">General parameters</a></li>
<li><a class="reference external" href="#gbsa-parameters">GBSA parameters</a></li>
<li><a class="reference external" href="#temperature-replica-exchange-parameters">Temperature replica-exchange parameters</a></li>
<li><a class="reference external" href="#free-energy-calculation-parameters">Free energy calculation parameters</a></li>
<li><a class="reference external" href="#gcmc-and-jaws-parameters">GCMC and JAWS parameters</a></li>
</ul>
</li>
<li><a class="reference external" href="#specifying-input-files">Specifying input files</a></li>
<li><a class="reference external" href="#running-a-simulation">Running a Simulation</a><ul>
<li><a class="reference external" href="#equilibration-and-production">Equilibration and Production</a></li>
<li><a class="reference external" href="#results-and-restarts">Results and Restarts</a></li>
<li><a class="reference external" href="#pdb-output">PDB Output</a></li>
<li><a class="reference external" href="#restraints">Restraints</a></li>
<li><a class="reference external" href="#frequent-output-generation">Frequent output generation</a></li>
<li><a class="reference external" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a class="reference external" href="#setup-and-analysis-tools">Setup and analysis tools</a></li>
</ul>
</li>
<li><a class="reference external" href="#input-files">Input Files</a><ul>
<li><a class="reference external" href="#parameter-forcefield-files">Parameter / Forcefield Files</a></li>
<li><a class="reference external" href="#templates">Templates</a></li>
<li><a class="reference external" href="#protein-file">Protein File</a></li>
<li><a class="reference external" href="#solute-file">Solute File</a></li>
<li><a class="reference external" href="#gcsolute-file">GCsolute File</a></li>
<li><a class="reference external" href="#solvent-file">Solvent File</a></li>
<li><a class="reference external" href="#restart-file">Restart File</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="compilation.html"
                                  title="previous chapter">Compilation and Installation</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="protomspy.html"
                                  title="next chapter">protoms.py</a></p>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="design-of-protoms">
<h1>Design of ProtoMS<a class="headerlink" href="#design-of-protoms" title="Permalink to this headline">¶</a></h1>
<p id="index-0">ProtoMS is a powerful simulation program that is capable of being used in many different ways. ProtoMS was originally designed to perform Monte Carlo free energy calculations on protein-ligand systems, so a lot of the terminology and ideas associated with ProtoMS derive from protein-ligand Monte Carlo methodology. While the code was originally designed with this use in mind, the framework is sufficiently flexible to allow the study of a wide range of different systems, using a wide range of simulation methodology.</p>
<p>At the core of ProtoMS are four central concepts;</p>
<ul class="simple">
<li><strong>Proteins/Solutes/Solvents/GCSolutes</strong> ProtoMS divides all molecules to be simulated into ‘proteins’, ‘solutes’ and ‘solvent’.</li>
<li><strong>Classical Forcefields</strong> ProtoMS Uses a generic classical forcefield to calculate the energy of the molecules. This forcefield may be specialised such that ProtoMS is able to implement a wide range of modern molecular mechanics forcefields.</li>
<li><strong>Perturbations</strong> ProtoMS provides support for free energy calculations by allowing forcefields and geometries to be perturbed using a <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> coordinate. The forcefield for any protein, solute or solvent may be perturbed, and the geometry of any solute may be perturbed.</li>
<li><strong>Generic Moves</strong> ProtoMS is designed around the concept a ‘move’. The move can do anything, from a Monte Carlo translation of solvent to a docking type move on a solute. A simulation is constructed by stringing a collection of moves together.</li>
</ul>
<div class="section" id="proteins-solutes-solvents-gcsolutes">
<h2>Proteins / Solutes / Solvents / GCSolutes<a class="headerlink" href="#proteins-solutes-solvents-gcsolutes" title="Permalink to this headline">¶</a></h2>
<p>ProtoMS divides all of the molecules loaded within a system into solvents, GCsolutes, solutes and proteins</p>
<ul class="simple">
<li><strong>solvents</strong>  A solvent is any rigid molecule. Solvents may only be translated and rotated, and by default, 75000 solvent molecules may be loaded, each consisting of up to 10 atoms. Solvent molecules do not have to be small - a rigid lipid molecule could be modelled as a solvent. There is no requirement for the solvents loaded in a system to be the same. Indeed every solvent loaded could be a different type of molecule!</li>
<li><strong>GCsolutes</strong> Like a solvent molecule, GCsolutes are rigid. They have the same properties as previously described for solvents, except GCsolutes are restrained to a defined region in the simulation.</li>
<li><strong>solutes</strong> A solute is any flexible molecule. Solutes can be translated and rotated, and change their internal geometry. By default 60 solutes, each composed of 10 residues, each composed of 100 atoms may be loaded simultaneously. Solute molecules are described using z-matrices, thus a solute molecule is perhaps what you would be most familiar with from other Monte Carlo simulation programs. Note that you can describe a protein molecule as a solute, and that you do not need to load it up as a ‘protein’.</li>
<li><strong>proteins</strong> A protein is any flexible chain molecule (polymer). A protein is composed of a linear chain of residues, with interresidue bonds connecting one residue to the next. By default, ProtoMS can load up to 3 proteins simultaneously, each protein consisting of 1000 residues, each consisting of up to 34 atoms.</li>
</ul>
<p id="index-1"><strong>Solvents</strong></p>
<p>Solvents are loaded into ProtoMS from PDB files (see section <a class="reference internal" href="#solventpdb"><em>Solvent File</em></a>). Each solvent molecule is identified by its residue name (the fourth column in the PDB file), e.g. ProtoMS identifies the TIP4P solvent with the residue name ‘T4P’. ProtoMS loads the coordinates of the solvent from the PDB file, and then assigns the parameters for the solvent from a solvent template (see section <a class="reference internal" href="#temref"><em>Templates</em></a>). The solvent template contains the information necessary to identify all of the atoms in the solvent molecule and to assign forcefield parameters to each atom. Note that this version of ProtoMS uses the coordinates of the solvent molecule that are present in the PDB file. ProtoMS does not yet have the capability to modify these coordinates to ensure that the internal geometry of the solvent is correct for the solvent model. This means that as solvents are only translated and rotated, the internal geometry of
the solvent molecule loaded at the start of the simulation will be identical to that at the end of the simulation.</p>
<p id="index-2"><strong>GCSolutes</strong></p>
<p>Like solvents, GCsolutes are loaded into ProtoMS from PDB files (see section <a class="reference internal" href="#gcpdb"><em>GCsolute File</em></a>). Each GCsolute molecule is identified by its residue name (the fourth column in the PDB file). ProtoMS loads the coordinates of the GCsolute from the PDB file, and then assigns the parameters for the GCsolute from a GCsolute template (see section <a class="reference internal" href="#temref"><em>Templates</em></a>). This template contains the information necessary to identify all of the atoms in the solvent molecule and to assign forcefield parameters to each atom. Alongside translational and rotational moves, the intermolecular energy between the GCsolute and the system can be sampled.</p>
<p id="index-3"><strong>Solutes</strong></p>
<p>Solutes are also loaded into ProtoMS from PDB files (see section <a class="reference internal" href="#solpdb"><em>Solute File</em></a>). Each solute molecule is identified by its solute name, which is given in the HEADER record of the PDB file. ProtoMS obtains the coordinates of the solute from the PDB file, and will then find a solute template that matches this solute name (see <a class="reference internal" href="#temref"><em>Templates</em></a>). The solute template is used to build the z-matrix for the solute, and to assign all of the forcefield parameters. The solute template is also used to assign the connectivity of the solute and to define the flexible internal coordinates. The solute molecule is constructed using the z-matrix, with the reference being three automatically added dummy atoms, called ‘DM1’, ‘DM2’ and ‘DM3’, all part of residue ‘DUM’. These dummy atoms are automatically added by ProtoMS at the geometric center of the solute, as a right angled set of atoms pointing along the major and minor axes of the solute.</p>
<p id="index-4"><strong>Proteins</strong>
Proteins are loaded into ProtoMS via PDB files (see section <a class="reference internal" href="#protpdb"><em>Protein File</em></a>). Each PDB file may only contain a single protein chain. ProtoMS constructs the linear chain of molecules based on the order of residues that it reads from the PDB file, and will ignore the residue number read from the PDB file. This means that you must ensure that you have the residues ordered correctly within the PDB file. ProtoMS assigns to each residue both a chain template (see section <a class="reference internal" href="#temref"><em>Templates</em></a>), that describes the backbone of the residue, and a residue template (see section <a class="reference internal" href="#temref"><em>Templates</em></a>), that describes the sidechain. The residue template is located based on the name of the residue given in the fourth column in the PDB file (e.g. ‘ASP’ or ‘HIS’). The chain template is located based on the chain template associated with the residue template for the position of the residue within the chain. For example, residue ‘ASP’ has a standard amino acid backbone chain template if this residue was in the middle of the chain, an NH+ capped backbone chain template 3 if this was the first residue of the chain (and thus at the n-terminus), and a CO&#8211; capped backbone chain template 2 if this were the last residue of the chain (and thus at the c-terminus). If the protein consisted of only one residue, then the zwitterionic amino acid chain template would be used for ‘ASP’.</p>
<p>ProtoMS obtains the coordinates of each residue from the PDB file, and will then use the residue and chain templates to build the z-matrix for each residue, and to assign all of the forcefield parameters.</p>
<p id="bbatoms">Proteins are moved in a different manner in ProtoMS compared to other Monte Carlo packages that are available. Each residue is moved independently, using both the internal geometry moves defined by the template z-matrix, and by backbone translation and rotation moves of the chain atoms (see figure above).</p>
<div class="figure">
<a class="reference external image-reference" href="_images/backbone.png"><img alt="_images/backbone.png" src="_images/backbone.png" style="width: 621.0px; height: 243.0px;" /></a>
<p class="caption">Four atoms from each protein residue are designated as backbone atoms (bbatoms). For most residues these atoms are the N, CA, C and O atoms respectively. The four backbone atoms for two neighbouring residues are shown above. The protein backbone move moves the last three bbatoms of one residue and the first bbatom of the next residue. This is because the moves assumes that these four bbatoms form a rigid triangle (as is shown by the grey lines). The four atoms are translated and rotated as a rigid triangle, with the origin of rotation of the triangle centered on the intersection of the vector between bbatoms 2 and 1, and the vector between bbatoms 3 and 4 (marked as a red dot directly above the C=O bond). Because this triangle is translated and rotated as a rigid unit, all atoms connected to the atoms of this triangle will also be translated and rotated as a rigid unit.</p>
</div>
<p>Four special backbone atoms (bbatoms) are identified in the chain-backbone of each residue. These atoms form the reference from which the rest of the residue atoms are built. These four atoms can be translated and rotated as a rigid unit via protein backbone moves (see figure above). As the rest of the residue is constructed from these bbatoms, the rest of the residue is thus also translated and rotated. Because the bbatoms are translated and rotated as a rigid unit, the internal geometry of these backbone atoms are held constant throughout the simulation. This means that the internal geometry of the bbatoms is taken from the PDB file, and may not be modified by the chain or residue templates. It is also not possible to build missing bbatoms, so they must all be present in the PDB file.</p>
<p>Once the coordinates and z-matrices of each residue have been assigned, interresidue bonds are added between the first bbatom of each residue and the third bbatom of the previous residue (e.g. for ‘ASP’, bonds would be added from the ‘N’ atom of the ‘ASP’ residue to the ‘C’ atom of the preceeding amino acid residue). If the length of this bond is less than 4 A then this bond is added as a real bond, and its energy is evaluated as part of the forcefield. However, if the length is greater than 4 A, then this bond will be added as a dummy bond, and a warning message output. This is useful in cases where you wish to load up a protein scoop, e.g. from around the active site. This option should be used with care in conjunction with backbone moves.</p>
<table border="1" class="docutils">
<caption>Table 1.0 The default value of the maximum number of proteins, GCsolutes, solutes and solvents that may be loaded simultaneously by ProtoMS. These values may be changed by editing the <tt class="docutils literal"><span class="pre">dimensions.inc</span></tt> file located in the src directory, and recompiling ProtoMS.</caption>
<colgroup>
<col width="33%" />
<col width="56%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Parameter</th>
<th class="head">Description</th>
<th class="head">Values</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>MAXPROTEINS</td>
<td>Maximum number of proteins</td>
<td>3</td>
</tr>
<tr><td>MAXRESIDUES</td>
<td>Maximum number of residues per protein</td>
<td>1000</td>
</tr>
<tr><td>MAXSCATOMS</td>
<td>Maximum number of atoms per protein residue</td>
<td>30</td>
</tr>
<tr><td>MAXSOLUTES</td>
<td>Maximum number of solutes</td>
<td>60</td>
</tr>
<tr><td>MAXSOLUTERESIDUES</td>
<td>Maximum number of residues per solute</td>
<td>10</td>
</tr>
<tr><td>MAXSOLUTEATOMSPERRESIDUE</td>
<td>Maximum number of solute atoms per residue</td>
<td>100</td>
</tr>
<tr><td>MAXSOLVENTS</td>
<td>Maximum number of solvent molecules</td>
<td>75000</td>
</tr>
<tr><td>MAXSOLVENTS</td>
<td>Maximum number of GCsolute molecules</td>
<td>75000</td>
</tr>
<tr><td>MAXSOLVENTATOMS</td>
<td>Maximum number of atoms per solvent</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><strong>Limits</strong></p>
<p>ProtoMS is written using slightly extended Fortran 77 (see <a class="reference external" href="compilation.html#fortran77"><em>Programming Language</em></a>). This means that the maximum numbers of loaded proteins, solutes and solvents has to be set at compile time. Table 1.0 gives the default values for the maximum number of proteins, solutes and solvents. Please note that you may change these numbers to fit the system that you are interested in, e.g. if you were investigating a single protein in a lipid bilayer then you may choose to model the lipid as a solute (thus requiring a large increase in the number of solute molecules, but a decrease in the number of solute residues), and you could reduce the maximum number of protein molecules to one. By balancing the numbers of protein, solutes and solvents you should find that you are able to load up the system that you want to simulate.</p>
</div>
<div class="section" id="classical-forcefields">
<span id="index-5"></span><h2>Classical forcefields<a class="headerlink" href="#classical-forcefields" title="Permalink to this headline">¶</a></h2>
<p>ProtoMS was designed to perform simulations using a range of different molecular mechanics (MM) forcefields. To achieve this aim, a generic forcefield has been implemented, and this can be specialised into a specific, traditional forcefield.</p>
<p>The forcefield in ProtoMS is comprised of several terms;</p>
<p id="index-6"><strong>Intermolecular Potential</strong></p>
<p>An intermolecular potential acts between all molecules within the system. The intermolecular potential between a pair of molecules, <em>A</em> and <em>B</em>, <img class="math" src="_images/math/8b4b39dcebfa1c8f019e4eebce5763802603ffd1.png" alt="U_{molecule} (A, B)"/>, with <em>A</em> consisting of <img class="math" src="_images/math/2fdb780be66bfbfb3082563bb7e174790920da0e.png" alt="n_A"/> atoms and <em>B</em> consisting of <img class="math" src="_images/math/82fd55895406f8f28ff30273c1cbacce629f24b7.png" alt="n_B"/> atoms, is formed as the sum of the non-bonded potential, <img class="math" src="_images/math/86abfd49405d15051ee44c79ab2436d9b0ab90fe.png" alt="U_{nb} (i, j)"/> between each pair of atom sites, <em>i</em> and <em>j</em>, between the two molecules, scaled by a constant, <em>scl</em>, e.g.</p>
<div class="math" id="equation-intermol1">
<p><span class="eqno">(1)</span><img src="_images/math/b851e74f80484126993c1b66d90f381d405c216c.png" alt="U_{molecule}(A,B) = scl(R)\times\biggl( \sum_{i=1}^{n_A} \sum_{j=1}^{n_B} U_{nb}(i,j) \biggr)" /></p>
</div><p>where <em>R</em> is the shortest distance between a pair of atom sites between the molecules. The scaling factor is set according to</p>
<div class="math">
<p><img src="_images/math/a37c0f4c10ef5a294d3de79f67cdf1bd4129757f.png" alt="&amp;R \ge r_{cut} \rightarrow scl = 0.0 \\

&amp;r_{cut}-r_{feather} \le R \le r_{cut} \rightarrow scl = \frac{r_{cut}^2-R^2}{r_{cut}^2-(r_{cut}-r_{feather})^2} \\

&amp;R \le r_{feather} \rightarrow scl = 1.0," /></p>
</div><p>where <img class="math" src="_images/math/d8bfcdc8a7342e18da6cd9aba6d8364a181eb581.png" alt="r_{cut}"/> and <img class="math" src="_images/math/a52937a589d5a82bde3f81a3eb9aa92ba1f2bb06.png" alt="r_{feather}"/> are the non-bonded cutoff and feather parameters.</p>
<p>The non-bonded potential between the pair of atoms is evaluated as the sum of the Coulombic and Lennard-Jones (LJ) potentials between the atoms,</p>
<div class="math" id="equation-intermol2">
<p><span class="eqno">(2)</span><img src="_images/math/929d2bf2f0dd35825cc5c01e44e6db291b7fbec4.png" alt="U_{nb}(i,j) = \frac{q_i q_j}{4\pi\epsilon_{0} r(i,j)} + 4\epsilon_{ij}\biggl[ \biggl(\frac{\sigma_{ij}}{r(i,j)}\biggr)^{12} - \biggl(\frac{\sigma_{ij}}{r(i,j)}\biggr)^6 \biggr]," /></p>
</div><p>where <img class="math" src="_images/math/6b50b1e2a036e3897de5cd74a367b0a7da70d160.png" alt="q_i"/> and <img class="math" src="_images/math/eb243d633fd865f7347e6ece4cd3e84f287dfcdb.png" alt="q_j"/> are the partial charges on the two atom sites, <em>r(i, j)</em> is the distance between the atom sites, <img class="math" src="_images/math/2bfc38c1b85f06435f1af5c9b92c5550e68d7ad5.png" alt="\epsilon_0"/> is the permittivity of free space and <img class="math" src="_images/math/48fa96efe2a845cb79a0228d8c5784bc11613039.png" alt="\sigma_{ij}"/> and <img class="math" src="_images/math/9775c4979815e5b297f3a5bb23239b6e3acc6363.png" alt="\epsilon_{ij}"/> are the Lennard Jones parameters for the atom site pair <em>i</em> and <em>j</em>. The LJ parameters for an atom site pair are calculated as the average of the LJ parameters for the same site pair.</p>
<p id="index-7">Either the arithmetic average is used, or the geometric average is used, e.g.</p>
<div class="math" id="equation-arithmetriccomb">
<p><span class="eqno">(3)</span><img src="_images/math/ead372a7ed5ac5564e7a5b9c402b5e55251535b0.png" alt="\sigma_{ij} = 0.5\times(\sigma_{ii} + \sigma_{jj})." /></p>
</div><div class="math" id="equation-geometriccomb">
<p><span class="eqno">(4)</span><img src="_images/math/1d07d5ddfcf72e24266d490f6a8d1a47e4aa303c.png" alt="\epsilon_{ij} = \sqrt{\epsilon_{ii}\times\epsilon_{jj}}." /></p>
</div><p>The AMBER family of forcefields use the arithmetic average for <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/>, and the geometric average for <img class="math" src="_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/>, while the OPLS family of forcefields use the geometric average for both parameters. The intermolecular potential is formed as the sum of the non-bonded potential over all pairs of atom sites. It should be noted that an atom site does not necessarily need to lie at the center of each atom, and it may lie between atoms, or at the location of any lone pairs. Individual atoms may possess many atom sites, or even no atom sites.</p>
<p id="index-8"><strong>Bond Potential</strong></p>
<p>A bond potential acts over all of the explicitly added, non-dummy bonds within a molecule. ProtoMS makes no attempt to find any implicit bonds within a molecule, and it is not possible to add a bond between atoms of different molecules. The energy of each bond, <img class="math" src="_images/math/f61ea128501b95dad47531a93a06ed9c65afd642.png" alt="U_{bond}"/> , is evaluated according to</p>
<div class="math" id="equation-bondpot">
<p><span class="eqno">(5)</span><img src="_images/math/7d89a9c5a5974ac51f08eb4a7985465006618a85.png" alt="U_{bond}(r) = k_{bond}\bigl(r-r_0\bigr)^2," /></p>
</div><p>where <em>r</em> is the bond length, <img class="math" src="_images/math/2da9b480f4929b470c155bb7b1c926cb05a458db.png" alt="k_{bond}"/> is the force constant for the bond, and <img class="math" src="_images/math/630f232dcbff18b52c950e05ea525a8a119ff77b.png" alt="r_0"/> is the equilibrium bond length. The total bond energy of a molecule is the sum of the bond energies for all of the bonds within the molecule, and the total bond energy of the system is the sum of the bond energies for each of the molecules in the system.</p>
<p id="index-9"><strong>Angle Potential</strong></p>
<p>An angle potential acts over all angles between atoms that are connected by non-dummy bonds, and over all
non-dummy angles that have been explicitly added to the molecule. The energy of each angle, Uangle , is evaluated
according to</p>
<div class="math" id="equation-angpot">
<p><span class="eqno">(6)</span><img src="_images/math/a1760d35628bfccc31f628816cf92255194be9fa.png" alt="U_{angle}(\theta) = k_{angle}\bigl(\theta-\theta_0\bigr)^2," /></p>
</div><p>where <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is the size of the angle, <img class="math" src="_images/math/ea7b0ca11cd67679c638250e784c211e8124e120.png" alt="k_{angle}"/> is the force constant for the angle, and <img class="math" src="_images/math/62df86ba6c84c9e8a5008f0ad6bbefa5d9cf301f.png" alt="\theta_0"/> is the equilibrium angle size. The total angle energy of a molecule is the sum of the angle energies for each of the angles within the molecule, and the total energy of the system is the sum of the angle energies for each of the molecules in the system.</p>
<p id="index-10"><strong>Urey-Bradley Potential</strong></p>
<p>A Urey-Bradley potential may act between the first and third atoms of some of the angles that are evaluated for the angle potential. If this is the case, then a Urey-Bradley energy is added onto the angle energy. The Urey-Bradley energy, <img class="math" src="_images/math/51dff17006e985270b255d8302f9f0d5e5553bea.png" alt="U_{uby}"/>, is evaluated according to</p>
<div class="math" id="equation-ubpot">
<p><span class="eqno">(7)</span><img src="_images/math/0e8f0a5671a920836ac4d8ac4eab50e2df084829.png" alt="U_{uby}(x) = k_{uby}\bigl(x-x_0\bigr)^2," /></p>
</div><p>where <em>x</em> is the distance between the first and third atoms, <img class="math" src="_images/math/fd201fa83d1d0b4814a1a758c1f4a75a156bd7ed.png" alt="k_{uby}"/> is the Urey-Bradley force constant, and <img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/> is the equilibrium distance.</p>
<p id="index-11"><strong>Dihedral Potential</strong></p>
<p>A dihedral potential acts over all dihedrals between atoms that are connected by non-dummy bonds, and over all non-dummy dihedrals that have been explicitly added to the molecule. Such explicitly added dihedrals may be used to add improper dihedrals that maintain the stereochemistry of chiral centers. The energy for each dihedral, <img class="math" src="_images/math/3c2e62687a4abf2d88399a6ddd9748652869fec7.png" alt="U_{dihedral}"/>, is formed as the sum of <em>n</em> cosine terms,</p>
<div class="math" id="equation-dihepot">
<p><span class="eqno">(8)</span><img src="_images/math/50213887231f2d6b47454e2fd6dd33139f4aaf7f.png" alt="U_{dihedral}(\phi) = \sum_{i=1}^{n} k_{i1}\bigl[1.0 + k_{i2}\bigl(cos(k_{i3}\phi + k_{i4})\bigr)\bigr]," /></p>
</div><p>where <img class="math" src="_images/math/d3de5b97b6e707b488b5f57b1779e926d8073d44.png" alt="k_{i1}"/> to <img class="math" src="_images/math/77cb3e4c85e616fae68b7d3142cf44d416f95829.png" alt="k_{i4}"/> are dihedral parameters and <img class="math" src="_images/math/2c175f60eecef1de7560c3bdea495d69f26f719d.png" alt="\phi"/> is the size of the dihedral. The total dihedral energy of a molecule is the sum of the dihedral energies for each of the dihedrals in the molecule, and the total dihedral energy of the system is the sum of the dihedral energies of each of the molecules.</p>
<p id="index-12"><strong>Intramolecular non-bonded Potential</strong></p>
<p>An intramolecular non-bonded potential acts between all intramolecular pairs of atoms that are either not connected by a non-dummy bond, or are not both connected to a third atom by a non-dummy bond. To make this more clear, if two atoms are connected by a non-dummy bond then they are said to be 1-2 bonded. If two atoms are both connected to a third atom by non-dummy bonds, then they are said to 1-?-3, or 1-3 bonded. Similarly, if the pair of atoms are connected together via two atoms via non-dummy bonds, then they are said to be 1-?-?-4, or 1-4 bonded. An intramolecular non-bonded potential does not act over 1-2 or 1-3 bonded pairs within a molecule, but does act over 1-4 bonded pairs and above. Note that ProtoMS only looks at the non-dummy bonds between atoms, and will not consider whether or not there are non-dummy angles, Urey-Bradley or dihedral terms involving these atoms.</p>
<p>The intramolecular non-bonded potential of a molecule, <img class="math" src="_images/math/8546dcd91c1b57b1c7493b70b40a91973a3873d0.png" alt="U_{intra}"/> is the sum of the non-bonded energy between all 1-5 and above pairs of atoms within the molecule, plus the sum of the non-bonded energy between all 1-4 atoms scaled by a 1-4 scaling factor, e.g.</p>
<div class="math" id="equation-intrapot1">
<p><span class="eqno">(9)</span><img src="_images/math/5b801b91de3983ae119c52a023f3c17cd9d8056d.png" alt="U_{intra} = &amp;\sum_{\text{1-5+ i j pairs}} U_{coul}(i,j) + U_{lj}(i,j) + \sum_{\text{1-4 i j pairs}} scl_{coul} U_{coul}(i,j) + scl_{lj} U_{lj}(i,j)," /></p>
</div><p>where</p>
<div class="math" id="equation-intrapot2">
<p><span class="eqno">(10)</span><img src="_images/math/8d673dabeb43d9388ec75c4923bdffb64d9e5560.png" alt="U_{coul}(i,j) = \frac{q_i q_j}{4\pi\epsilon_{0} r}," /></p>
</div><p>and</p>
<div class="math" id="equation-intrapot3">
<p><span class="eqno">(11)</span><img src="_images/math/edc2c29f0e1a5ef13f8fc6fbdd4e2c2e5b842bb4.png" alt="U_{lj}(i,j) = 4\epsilon_{ij}\biggl[ \biggl(\frac{\sigma_{ij}}{r}\biggr)^{12} - \biggl(\frac{\sigma_{ij}}{r}\biggr)^6 \biggr]." /></p>
</div><p>Equations <a href="#equation-intrapot2">(10)</a> and <a href="#equation-intrapot3">(11)</a> are the Coulomb and Lennard Jones equations, as seen in the intermolecular potential in equations <a href="#equation-intermol1">(1)</a> and <a href="#equation-intermol2">(2)</a>. <img class="math" src="_images/math/0da2a02f70237e313f2a5e0ff11174453d15b63d.png" alt="scl_{coul}"/> and <img class="math" src="_images/math/93b78e1a8e6ff09f0e1b55abb024037dcddba7e1.png" alt="scl_{lj}"/> are the Coulomb and Lennard Jones scaling factors.</p>
<p id="index-13"><strong>Generalized Born Surface Area potential</strong></p>
<p>While free energy simulations are usually conducted in explicit solvent, ProtoMS supports Generalized Born Surface Area (GBSA) implicit solvent models. Relatively few free energy implicit solvent studies have been conducted and such option should be tested carefully before embarking onto expensive free energy simulations. The GBSA theory assumes that the total solvation free energy of a molecule A is a sum of a polar and non-polar energy term:</p>
<div class="math" id="equation-gb1">
<p><span class="eqno">(12)</span><img src="_images/math/7580301cf6d8881df2916f3a995a1b055e36a163.png" alt="\Delta G_{solv} = \Delta G_{pol} + \Delta G_{nonpol}" /></p>
</div><p>The second term, is simply proportional to the solvent accessible surface area (SASA) of the molecule, times a parameter that depends on the atom types present in the molecule. The first term is more complex and derived from the following equation :</p>
<div class="math" id="equation-gb2">
<p><span class="eqno">(13)</span><img src="_images/math/62ec18c3e244bf96b61c8941342c6fc638dde53a.png" alt="\Delta G_{pol} = -\frac{1}{2}(\frac{1}{\epsilon_{vac}}-\frac{1}{\epsilon_{solv}})  \sum_{i}\sum_{j} \frac{q_{i}q_{j}}{\sqrt{r^{2}_{ij} + B_{i}B_{j} e^{\frac{-r^{2}_{ij}}{4B_{i}B_{j}}}   } }" /></p>
</div><p><img class="math" src="_images/math/2daf16e8ff77e830d02747ded3126df8193a7999.png" alt="\epsilon_{vac}"/> and <img class="math" src="_images/math/c8dbf0e2fe3799d233585b5ee35caf282f84074a.png" alt="\epsilon_{solv}"/> are the dielectric constants of the vacuum and the solvent respectively, <img class="math" src="_images/math/334cb700056c8c4edf0ee8dde46453d48b4b9d68.png" alt="q_{i}"/> the atomic partial charge of atom <em>i</em>, <img class="math" src="_images/math/b6e5ee948e8687c21ec22b1593ade16a201ad195.png" alt="r_{ij}"/> the distance between a pair of atoms <em>ij</em>, and <img class="math" src="_images/math/dd4e5f5f80ad202ae33b8295d1ce51438005f067.png" alt="B_{i}"/> is the effective Born radius of atom <em>i</em>.</p>
<p>The effective Born Radius <img class="math" src="_images/math/dd4e5f5f80ad202ae33b8295d1ce51438005f067.png" alt="B_{i}"/> is in essence the spherically averaged distance of the solute atom to the solvent. An accurate estimate of this quantity is essential to calculate high quality solvation free energies. It is however fairly complex to compute as it formalyl involves an integral over the position of all the atoms in the system. While numerical techniques can calculate such value, they are too slow to be of practical use in a simulation. In ProtoMS, the effective Born radii are calculated using the Pairwise Descreening Approximation (PDA) method.</p>
<div class="math">
<p><img src="_images/math/39641a3779ce5619029b99c03435e6e6f08e870c.png" alt="{\frac{1}{B_i}} = \frac{1}{\alpha _{i}} - \frac{1}{2} \sum_{j \not= i} \lbrack \frac{1}{L_{ij}}-\frac{1}{U_{ij}}+\frac{r_{ij}}{4}(\frac{1}{U_{ij}^{2}}-\frac{1}{L_{ij}^{2}}) +\frac{1}{2r_{ij}}ln\frac{L_{ij}}{U_{ij}} + \frac{S_{j}^{2}\alpha_{j}^{2}}{4r_{ij}}(\frac{1}{L_{ij}^{2}}-\frac{1}{U_{ij}^{2}} ) \rbrack

L_{ij} &amp;= 1 \quad if \quad r_{ij} + S_{j}\alpha_{j} \leq \alpha_{i} \\

L_{ij} &amp;= \alpha_{i} \quad if \quad r_{ij} - S_{j}\alpha_{j} \leq \alpha_{i}  &lt;r_{ij} + S_{j}\alpha_{j}\\

L_{ij} &amp;= r_{ij} - S_{j}\alpha_{j} \quad if \quad \alpha_{i} \leq r_{ij} - S_{j}\alpha_{j}\\

U_{ij} &amp;= 1 \quad if \quad  r_{ij} + S_{j}\alpha_{j} \leq \alpha_{j}\\

U_{ij} &amp;= r_{ij} + S_{j}\alpha_{j} \quad if \quad \alpha{i} &lt;  r_{ij} + S_{j}\alpha_{j}\\" /></p>
</div><p>where <img class="math" src="_images/math/b6e5ee948e8687c21ec22b1593ade16a201ad195.png" alt="r_{ij}"/> is the distance between a pair of atoms <em>ij</em> and <img class="math" src="_images/math/73c80f9c86b2cec4542f88276ae27938ef614425.png" alt="\alpha_{i}"/> is the intrinsic Born radius of atom <em>i</em>, that is, the Born radius that atom <em>i</em> would adopt if it was completely isolated. Finally <img class="math" src="_images/math/d5c9cce378b112e3abf23dc48739be876f823ac3.png" alt="S_{j}"/> is a scaling factor which compensates for systematic errors introduced by this approximate Born radii calculation.</p>
<p>As the name says, the technique approximate the descreening (the extent to which a nearby atom j displaces a volume that would have otherwise been occupied by solvent) by a fast summation of pairwise terms. It is however not rigorous and has to be parameterised carefully to yield robust performance. The PDA method tend to systematically underestimate the Born radius of buried atoms because it incorrectly assign high dielectric constants to numerous small voids and crevices that exist between atoms in a protein and are not occupied by water. To increase accuracy, a re-scaling technique has been implemented.</p>
<div class="math">
<p><img src="_images/math/2c6e46845f04139ab17375691ec5c6801f375fa8.png" alt="{\frac{1}{B_i}}  = \frac{1}{\alpha _{i}} - Itanh\big( \alpha \psi - \beta \psi^{2} + \gamma \psi^{3}  \big)" /></p>
</div><p>where <em>I</em> is the summation term from the PDA calculation, <img class="math" src="_images/math/8ada738001410f131563551fb68731e4f302048d.png" alt="\psi"/>, <img class="math" src="_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha"/>, <img class="math" src="_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta"/> and <img class="math" src="_images/math/66981fa3920210c6ad8dbe5e968783d5dd7520c3.png" alt="\gamma"/> are parameters taken from the litterature.</p>
<p>The rescaling option has not been used extensively in ProtoMS and should be used with caution. It appears it may prove useful when simulation buried protein binding sites.</p>
<p>The GBSA force field implemented in ProtoMS was parameterised to be used with the AMBER99 and the GAFF force fields. While alternative force fields could be used, a loss of accuracy could be expected.</p>
<p>GBSA simulations are order of magnitude more efficient than explicit solvent simulations of small isolated molecules. However, they slow
down rapidly when the size of the system increases. This is especially notable in Monte Carlo simulations where a small movement of part of a system formally warrants the computation the entire solvation energy of the system. This issue arises because the GBSA energy terms are not strictly pairwise decomposable.  It is possible to use however different techniques to increase the speed of a GBSA simulation. Cutoffs in the calculation of the Born radii are introduced and in addition the update of pairwise GB energies can be skipped if the Born radii of either atoms have not changed more than a certain threshold value after a MC move. Because this option will introduce energy drifts, it is advised to periodically recalculate rigorously the GB energy. In addition, a more complex Monte Carlo move is implemented in ProtoMS. This option allows to conduct a simulation with a crude GBSA model and a low cutoff for the non bonded energy terms. Normally the  predicted macroscopic properties would suffer from such crude treatment of intermolecular energies. However, periodically, a special acceptance test is employed to remove the bias introduced by the crude potential and ensure that the equilibrium density of states generated by the Monte Carlo simulation converges to the equilibrium density of states suitable for the standard biomolecular potential.</p>
<p>Actual speedups using either techniques are system dependent and optimisation of the different parameters can be a complex task. It is advised to use the default parameters described latter in the manual.</p>
<p><strong>Caveats</strong></p>
<p>ProtoMS implements this forcefield mostly as described. However there are a few shortcuts that are taken to improve the efficiency of the code. These shortcuts are based on the three-way split of the molecules of the system into solvents, solutes and proteins</p>
<ul class="simple">
<li><strong>solvents</strong> As solvents are rigid, there is no need to evaluate any of the intramolecular potentials. ProtoMS thus only evaluates the intermolecular energy of solvent molecules.</li>
<li><strong>solutes</strong> ProtoMS evaluates the forcefield of solute molecules exactly as described, with no shortcuts.</li>
<li><strong>proteins</strong>. ProtoMS implements a protein as a chain of residues. As these molecules can be large, and typically larger than the non-bonded cutoff, ProtoMS implements the non-bonded cutoff differently for proteins. Instead of evaluating the non-bonded cutoff for the protein as a whole, ProtoMS implements a residue-based cutoff, with the cutoff scaling factors evaluated individually for each residue. Additionally, the intramolecular non-bonded energy is also scaled according to the non-bonded cutoffs given in equation <a href="#equation-intermol1">(1)</a>. If you do not want to use residue based cutoffs, then it is possible to tell ProtoMS to use a molecule based cutoff, in which case the forcefield for proteins will be evaluated exactly as described with no shortcuts.</li>
</ul>
</div>
<div class="section" id="perturbations">
<span id="index-14"></span><h2>Perturbations<a class="headerlink" href="#perturbations" title="Permalink to this headline">¶</a></h2>
<p>ProtoMS is capable of calculating the relative free energy of two systems. ProtoMS does this by perturbing one system into the other through the use of a <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>-coordinate. If A and B are the two systems of interest, then the forcefield is constructed such that at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 the forcefield represents system A, at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0 the forcefield represents system B, and at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> value inbetween, the forcefield represents a hybrid of A and B.</p>
<p>ProtoMS implements two methods of perturbing between systems A and B;</p>
<ul class="simple">
<li><strong>Single topology</strong> System A is perturbed into system B by scaling the forcefield parameters such that the model morphs from A to B.</li>
<li><strong>Dual topology</strong> System A and B are simulated together, with <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> scaling the total energies of A and B such that one system is turned off as the other is turned on.</li>
</ul>
<p id="index-15"><strong>Single Topology Calculations</strong></p>
<p>ProtoMS assigns two sets of parameters to every single forcefield term; one parameter represents that term at <img class="math" src="_images/math/d8d2173b94ff669e26a5e823f7d7a5b80ebeec9d.png" alt="\lambda=0.0"/> (<img class="math" src="_images/math/2289c528187aceb6e79eb5bf59d38ba4891a0d75.png" alt="par_0"/>), the other represents that term at <img class="math" src="_images/math/d9e2cde3e83358b8f6931671dda8e169eab52372.png" alt="\lambda=1.0"/> (<img class="math" src="_images/math/e2f23fad3767dabe78612d9615debea542b704e1.png" alt="par_1"/>). <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> is used to linearly scale between these two parameters to obtain the value of the parameter at each value of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> (<img class="math" src="_images/math/a269c2ab58595d6b07e49162049ee4fee1a86c52.png" alt="par_\lambda"/>)</p>
<div class="math" id="equation-lambdamix">
<p><span class="eqno">(14)</span><img src="_images/math/f54caac6bef223c4f3473bd9e68d50381c60eab2.png" alt="par_\lambda = (1.0-\lambda) \times par_0 + \lambda \times par_1." /></p>
</div><p>This equation is used to scale the charge, <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> and <img class="math" src="_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/> parameters assigned to each atom site (see equations <a href="#equation-intermol1">(1)</a>), and the force constants (<img class="math" src="_images/math/2da9b480f4929b470c155bb7b1c926cb05a458db.png" alt="k_{bond}"/>, <img class="math" src="_images/math/ea7b0ca11cd67679c638250e784c211e8124e120.png" alt="k_{angle}"/> and <img class="math" src="_images/math/fd201fa83d1d0b4814a1a758c1f4a75a156bd7ed.png" alt="k_{uby}"/>) and equilibrium sizes (<img class="math" src="_images/math/630f232dcbff18b52c950e05ea525a8a119ff77b.png" alt="r_0"/>, <img class="math" src="_images/math/62df86ba6c84c9e8a5008f0ad6bbefa5d9cf301f.png" alt="\theta_0"/> and <img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/>) for the bond, angle and Urey-Bradley terms (see equations <a href="#equation-bondpot">(5)</a>, <a href="#equation-angpot">(6)</a> and <a href="#equation-ubpot">(7)</a>). This equation is not used to scale the dihedral parameters, as the functional form of the dihedral potential is more complicated. Rather than scale the dihedral parameters, ProtoMS uses <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> to scale the total energy of each dihedral;</p>
<div class="math" id="equation-dihmix">
<p><span class="eqno">(15)</span><img src="_images/math/4fbe6185b08c0ceb54316e8f701f6c3416de25a9.png" alt="U_{dihedral}(\phi)_\lambda = (1.0-\lambda)\times U_{dihedral}(\phi)_0 + \lambda \times U_{dihedral}(\phi)_1," /></p>
</div><p>where <img class="math" src="_images/math/641e7901173421fa2ff8de328af72f9e8beea4de.png" alt="U_{dihedral}(\phi)_0"/> is the dihedral energy using the parameters for <img class="math" src="_images/math/d8d2173b94ff669e26a5e823f7d7a5b80ebeec9d.png" alt="\lambda=0.0"/>, <img class="math" src="_images/math/bc90482fe7f4ad33a8cb95c67cdf974178b7de25.png" alt="U_{dihedral}(\phi)_1"/> is the dihedral energy using the parameters for <img class="math" src="_images/math/d9e2cde3e83358b8f6931671dda8e169eab52372.png" alt="\lambda=1.0"/>, and <img class="math" src="_images/math/92c8687028dfc2ceefd0f46be8a81c5bb83b8b8b.png" alt="U_{dihedral}(\phi)_\lambda"/> is the scaled dihedral energy at that value of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>.</p>
<p>Any and all parts of the forcefield can be scaled. This includes all of the forcefield parameters of any solutes, all of the parameters of any proteins, and all parameters of any solvent molecules. While this is very useful, and enables perturbations of any and all parts of the system, there are many cases where just changing the forcefield parameters is not sufficient to smoothly morph from one system into the other. There are many cases where the geometry of the molecules needs to be changed with <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. Fortunately ProtoMS provides this capability for solute molecules. Any internal coordinates that are part of the z-matrix of a solute molecule may perturbed with <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. Geometry variations are a powerful tool as they allow for very complicated, yet very smooth transitions between two systems to be described. A good example of such a transition is the annihilation of the hydrogen atoms as a methyl group is morphed into a single hydrogen.</p>
<div class="figure">
<a class="reference external image-reference" href="_images/alchemy.png"><img alt="_images/alchemy.png" src="_images/alchemy.png" style="width: 400.0px; height: 200.0px;" /></a>
<p class="caption">Geometry variations allow for a smoother transition between two systems, for example here a methyl group is smoothly converted into a hydrogen.</p>
</div>
<p>As well as enabling smooth transitions between systems, geometry variations may be used to calculate potentials of mean force along structural coordinates.</p>
<p id="index-16"><strong>Dual Topology Calculations</strong></p>
<p>A dual topology method to calculate free energy changes is also available in ProtoMS. In the single topology method force field terms were linearly interpolated so that they match the force field parameters suitable for particular molecule at either end of the perturbation (<img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> 0.0 or <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> 1.0). As two molecules often differ not only in their force field terms but also their geometry, it is often necessary to modify the internal coordinates as well. This is relatively easy In simple cases (morphing a methyl group into a hydrogen group) but for larger, complex, perturbations this is often cumbersome if not impossible. In the dual topology method no geometry variations are attempted. However, the interaction energy of a pair of solutes with their surroundings (solvent, protein, other solutes), is gradually turned on or off with the coupling parameter.</p>
<div class="math" id="equation-doubletopu">
<p><span class="eqno">(16)</span><img src="_images/math/37a14ad48f62829dca3307e25cdbacb424a0f139.png" alt="U(\lambda) = U_{0} + \lambda U(S_{2}) + (1 - \lambda) U(S_{1})" /></p>
</div><p>Equation <a href="#equation-doubletopu">(16)</a> thus shows that at any given value of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>, the total energy of the system consists in a term <img class="math" src="_images/math/99e99faf80caa8c65684099d6694dda5e1da56eb.png" alt="U_{0}"/> that is independent of the perturbation and a term <img class="math" src="_images/math/9b0ac453685d96ef398680e4c7b8975401f289ab.png" alt="U(S_{2})"/> and <img class="math" src="_images/math/183e35436db77120f5be0e22e78906c826c748d5.png" alt="U(S_{1})"/> which is a function of the intermolecular energies of the pair of solutes for which a free energy change is to be calculated.</p>
<p>A dual topology setup is simpler and more generally applicable than a single topology setup. However dual topology approaches suffer from a number of technical difficulties which are mainly related to the fact that if a solute does not have any intermolecular interaction with its surroundings, it can drift anywhere in the simulation box. This usually causes the free energy difference to converge very very slowly (in practice not at all). To overcome these difficulties, the dual topology technique implemented in ProtoMS constrains a pair of solutes to stay together by the introduction of dummy bond between the center of geometry of the two solutes. As this does not prove to be sufficient to avoid convergence issues, a soft-core non bonded energy function is also implemented. In essence, the function that computes the intermolecular energy of the solutes is modified such that when a solute is not fully interacting with its surroundings, it&#8217;s Lennard-Jones and couloumbic energies are softened such that atomic overlaps do not result in very large, positive, energies. The solute is effectively &#8216;softer&#8217;. There are three soft-core versions implemented in ProtoMS. The original implementation in ProtoMS for a solute
that is being turned off is described by equation <a href="#equation-uljsoftmod">(17)</a>.</p>
<div class="math" id="equation-uljsoftmod">
<p><span class="eqno">(17)</span><img src="_images/math/197490cdba223448923560b7dfb821248665b056.png" alt="U_{non bonded,\lambda}= (1-\lambda) 4{\epsilon}_{ij} \left[ \left( \frac{ \sigma_{ij}^{12} }{ ( \lambda \delta \sigma_{ij} + r_{ij}^{2} )^{6}} \right) - \left( \frac{ \sigma_{ij}^{6} }{ (\lambda \delta \sigma_{iJ}  + r_{ij}^{2})^{3} } \right) \right] +  \frac{(1-\lambda)^{n} q_{i}q_{j}} {4\pi{\epsilon}_{0}\sqrt{(\lambda +  r_{ij}^{2})}}" /></p>
</div><p>where the parameters n and <img class="math" src="_images/math/0a42a8b725c200085e5253db2d2fbf8dab898a8f.png" alt="\delta"/> control the softness of the Coulombic and Lennard-Jones interactions respectively.</p>
<p>An alternative that has been useful in some applications is described by equation <a href="#equation-uljsoftmod2">(18)</a></p>
<div class="math" id="equation-uljsoftmod2">
<p><span class="eqno">(18)</span><img src="_images/math/025ba926a33b97f76dd9e57d071d9c46b716e70c.png" alt="U_{non bonded,\lambda}= (1-\lambda) 4{\epsilon}_{ij} \left[  \left( \frac{ \sigma_{ij}^{12} }{ ( \lambda \delta \sigma_{ij}^6 + r_{ij}^{6} )^{2}} \right) -  \left( \frac{ \sigma_{ij}^{6} }{ \lambda \delta \sigma_{iJ}^6  + r_{ij}^{6} } \right) \right] +  \frac{(1-\lambda)^{n} q_{i}q_{j}} {4\pi{\epsilon}_{0} \left [ \lambda \delta_c +  r_{ij}^{6} \right ]^{1/6}}" /></p>
</div><p>with an additional softness parameter <img class="math" src="_images/math/3478748db61344e708754bdac6aae7b6a1fd2de4.png" alt="\delta_c"/> for the Coulombic interactions.</p>
<p>Third, the soft-core implementation in the latest version of the Amber package is available and is described by equation <a href="#equation-uljsoftmod3">(19)</a></p>
<div class="math" id="equation-uljsoftmod3">
<p><span class="eqno">(19)</span><img src="_images/math/6bdacbf1c8c09b1d522a748551d951c027dd064a.png" alt="U_{non bonded,\lambda}= (1-\lambda) 4{\epsilon}_{ij} \left[ \left( \frac{ \sigma_{ij}^{12} }{ ( \lambda \delta \sigma_{ij}^6 + r_{ij}^{6} )^{2}} \right) - \left( \frac{ \sigma_{ij}^{6} }{ \lambda \delta \sigma_{iJ}^6 + r_{ij}^{6} } \right) \right] +  \frac{(1-\lambda)^{n} q_{i}q_{j}} {4\pi{\epsilon}_{0} \sqrt{( \lambda \delta_c +  r_{ij}^{2})}}" /></p>
</div></div>
<div class="section" id="generic-moves">
<span id="moves"></span><h2>Generic Moves<a class="headerlink" href="#generic-moves" title="Permalink to this headline">¶</a></h2>
<p>ProtoMS conducts a simulation by performing a sequence of moves on the system. The following moves are currently implemented</p>
<ul class="simple">
<li><strong>Residue moves</strong> Standard Monte Carlo (MC) moves on protein residues.</li>
<li><strong>Solute moves</strong> Standard MC moves on solute molecules.</li>
<li><strong>Solvent moves</strong> Standard MC moves on solvent molecule.</li>
<li><strong>Volume moves</strong> Monte Carlo moves that change the volume of the system. These are used to run constant pressure simulations.</li>
<li><strong>GCSolute moves</strong> Standard MC moves on GCsolute molecules.</li>
<li><strong>Insertion moves</strong> MC moves which selects a GCsolute with a θ value of 0 and turns it to 1</li>
<li><strong>Deletion moves</strong> MC moves which selects a GCsolute with a θ value of 1 and turns it to 0</li>
<li><strong>Theta moves</strong> MC moves which sample the value of θ on a GCsolute molecule</li>
<li><strong>Sample moves</strong> MC moves which sample the value of θ on a GCsolute molecule whilst applying a biasing potential <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>-moves Monte Carlo moves that change <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. These may be used to perform umbrella sampling free energy simulations.</li>
<li><strong>Dual potential moves</strong> Works only with implicit solvent simulations. Allows to sample rapidly configurations with a crude potential but correct for errors with a specific acceptance test.</li>
</ul>
<p id="index-17"><strong>Residue Moves</strong>
A residue move is a Monte Carlo move on a single protein residue. Obviously, for a residue move to be be performed, at least one protein that has flexible residues must be loaded. Each residue move comprises the following steps</p>
<ol class="arabic simple">
<li>A protein is picked randomly from the set of proteins that have flexible residues. Note that each protein is weighted equally, so each protein has an equal chance of being chosen, regardless of how many flexible residues it contains. This behaviour is likely to change in future versions of the code, as ideally the probability of choosing to move a protein should be proportional to the number of flexible residues.</li>
<li>One of the flexible residues within the protein is chosen randomly from the set of all flexible residues in the protein. Again, there is no weighting of residues, so each flexible residue has an even chance of being chosen, despite the size of each residue.</li>
<li>If the backbone of this residue is flexible, then a random number between 1 and 3 is generated. If the random number is equal to 1, then only a backbone move on the residue will be attempted. If the random number is equal to 2 then only a sidechain move will be attempted, where all of the flexible internals of the residue are moved. If the random number is equal to 3 then a backbone and sidechain move are attempted simultaneously. If the backbone of this residue is fixed, then only a sidechain move is attempted.</li>
<li>The change in energy that results from this move is evaluated, and then tested according to the Metropolis criterion to decide whether or not to accept the move.</li>
<li>If the move is accepted, then the new configuration of the residue is saved. If the move was rejected then the original configuration of the residue is restored.</li>
</ol>
<p>You can change the flexibility of any residue in any protein by using the fixbackbone and fixresidues commands described in section <a class="reference internal" href="#misccmd"><em>Miscellaneous</em></a>. All residues of all proteins are flexible by default, and have flexible backbones. Note that the backbone move is still experimental and not thouroughly tested. I recommend that you fix the backbone of all residues for production simulations. You control the maximum amounts that the residue moves via the residue template (see <a class="reference internal" href="#temref"><em>Templates</em></a>). The actual amount that a residue moves by will be based on random values generated within the limits of the maximum amounts set in the residue template, e.g. if the maximum change of an angle was <img class="math" src="_images/math/454a5e7eb12d86dd692b9852b9377aba9dcbbfa4.png" alt="5.0^\circ"/> , then the angle will be changed by a random value generated evenly between <img class="math" src="_images/math/532daab5015ad682bdf404c345c6f33e5b1ec923.png" alt="-5.0^\circ"/> and <img class="math" src="_images/math/94549583458de3fd3a9af0e1ee794ba8cb099a4f.png" alt="+5.0^\circ"/>.</p>
<p id="index-18"><strong>Solute Moves</strong>
A solute move is a Monte Carlo move on a single solute molecule. Obviously, for a solute move to be performed, at least one solute molecule must be loaded. Each solute move comprises the following steps</p>
<ol class="arabic simple">
<li>A solute is picked randomly from the set of loaded solutes. Each solute is weighted equally, regardless of its size or numbers of degrees of freedom.</li>
<li>One of the residues is chosen at random within the solute. Again, each residue is weighted equally, regard- less of its size.</li>
<li>All of the flexible internals of this residue are changed, and the whole solute molecule is randomly translated, and rotated around its center of geometry.</li>
<li>The change in energy associated with this move is evaluated and then tested via the Metropolis criterion to decide whether or not to accept the move.</li>
<li>If the move is accepted then the new configuration of the solute is saved. If the move was rejected then the original configuration is restored. You can control the maximum amounts that the solute moves via the solute template (see <a class="reference internal" href="#temref"><em>Templates</em></a>).</li>
</ol>
<p id="index-19"><strong>Solvent Moves</strong></p>
<p>A solvent move is a Monte Carlo move on a single solvent molecule. Obviously, for a solvent move to be performed, at least one solvent molecule must be loaded. Each solvent move comprises the following steps</p>
<ol class="arabic simple">
<li>A solvent molecule is randomly chosed from the set of loaded solvent molecules. If preferential sampling is turned on (see <a class="reference internal" href="#parameters"><em>Simulation parameters</em></a>), then the solvent molecules closest to the preferred solute have a relatively higher weight, so will be more likely to be chosen. If preferential sampling is off, then each solvent is weighted equally, regardless of its relative size or proximity to a solute.</li>
<li>The solvent molecule is randomly translated and rotated around its center of geometry.</li>
<li>The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion if preferential sampling was turned off, or via a biased Monte Carlo test if preferential sampling were turned on.</li>
<li>If the move was accepted then the new solvent configuration is saved, otherwise the original configuration is restored.</li>
</ol>
<p>You can control the maximum amounts that the solvent is translated and rotated by by editing its solvent template (see <a class="reference internal" href="#temref"><em>Templates</em></a>).</p>
<p id="index-20"><strong>Volume Moves</strong></p>
<p>A volume move is a Monte Carlo move that changes the volume of the system. This is needed to be able to perform Monte Carlo simulations at constant pressure (i.e. using the NPT ensemble). For a volume move to be performed you need to have loaded a box of solvent molecules, and be running using periodic boundary conditions. A volume move is comprised of the following steps</p>
<ol class="arabic simple">
<li>A random change in volume is chosen within the range set via the maxvolchange command (see <a class="reference internal" href="#parameters"><em>Simulation parameters</em></a>).</li>
<li>The volume of the system is changed by this amount by scaling all of the coordinates evenly from the center of the simulation box.</li>
<li>The change in energy associated with this change in volume is evaluated and used to decide whether or not to accept this move via the constant pressure Monte Carlo test, for the system pressure set via the pressure command (see <a class="reference internal" href="#parameters"><em>Simulation parameters</em></a>).</li>
<li>If the move is accepted then the new system configuration is saved, otherwise the original system configuration is restored.</li>
</ol>
<p id="index-21"><strong>GCsolute Moves</strong></p>
<p>A GCsolute move is a Monte Carlo move on a single Gcsolute molecule. Each GCsolute move comprises the following steps</p>
<ol class="arabic simple">
<li>A GCsolute molecule is randomly chosed from the set of loaded GCsolute molecules.</li>
<li>The GCsolute molecule is randomly translated and rotated around its center of geometry. If it attempts to leave the confines of its predefined cubic region then it experiences a huge energetic penalty, ensuring that the Metropolis move is rejected.</li>
<li>The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.</li>
<li>If the move was accepted then the new GCsolute configuration is saved, otherwise the original configuration is restored.</li>
</ol>
<p>You can control the maximum amounts that the GCsolute is translated and rotated by by editing its template (see <a class="reference internal" href="#temref"><em>Templates</em></a>).</p>
<p id="index-22"><strong>Insertion Moves</strong></p>
<p>An insertion move is a Monte Carlo move on a single GCsolute molecule, whereby the <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> value of a GCsolute is turned from 0 to 1. Each insertion move comprises the following steps;</p>
<ol class="arabic simple">
<li>A GCsolute molecule is randomly chosed from the set of loaded GCsolute molecules. The value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is examined; if it is set to 1 then another is chosen until the examined <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> value is 0</li>
<li>The value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is set to 1, and the new energy associated with this value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is calculated</li>
<li>The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.</li>
<li>If the move was accepted then the new value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is saved, otherwise the original value of 0 is restored.</li>
</ol>
<p id="index-23"><strong>Deletion Moves</strong></p>
<p>A deletion move is a Monte Carlo move on a single GCsolute molecule, whereby the <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> value of a GCsolute is turned from 1 to 0. Each deletion move comprises the following steps</p>
<ol class="arabic simple">
<li>A GCsolute molecule is randomly chosed from the set of loaded GCsolute molecules. The value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is examined; if it is set to 0 then another is chosen until the examined <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> value is 1</li>
<li>The value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is set to 0, and the new energy associated with this value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is calculated</li>
<li>The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.</li>
<li>If the move was accepted then the new value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is saved, otherwise the original value of 1 is restored.</li>
</ol>
<p id="index-24"><strong>Theta Moves</strong></p>
<p>A theta move is a Monte Carlo move on a single GCsolute molecule, whereby the <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> value of a GCsolute is sampled. Each theta move comprises the following steps</p>
<ol class="arabic simple">
<li>A GCsolute molecule is randomly chosed from the set of loaded GCsolute molecules</li>
<li>The value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is randomly changed, and the new energy associated with this value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is calculated</li>
<li>The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.</li>
<li>If the move was accepted then the new value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is saved, otherwise the original value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is restored.</li>
</ol>
<p id="index-25"><strong>Sample Moves</strong></p>
<p>A sample move is a Monte Carlo move on a single GCsolute molecule, whereby the <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> value of a GCsolute is sampled whilst applying a biasing potential, jbias. Each sample move comprises the following steps</p>
<ol class="arabic simple">
<li>A GCsolute molecule is randomly chosed from the set of loaded GCsolute molecules (typically only one GCsolute molecule is studied in a sample move)</li>
<li>The biasing potential is added onto the value of ieold for that molecule, based upon the volume of the restraint and the applied jbias</li>
<li>The value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is randomly changed, and the new energy associated with this value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is found</li>
<li>The biasing potential is added onto the value of ienew for that molecule, based upon the volume of the restraint and the applied jbias</li>
<li>The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.</li>
<li>If the move was accepted then the new value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> for that GCsolute molecule is saved, otherwise the original value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> is restored.</li>
</ol>
<p id="index-26"><strong>Relative Move Probabilities</strong></p>
<p>You can specify which moves should be run by passing arguments to the simulate and equilibrate commands (see <a class="reference internal" href="#runcmd"><em>Running a Simulation</em></a>). You can use these commands to assign a weight to each type of move, e.g. 100 for solvent moves, 10 for protein moves, 1 for solute moves and 0 for volume move. The type of move chosen for each step of the simulation is generated randomly based on these set relative weights. These weights mean that on average, in 111 moves, 100 of these moves will be solvent moves, 10 of these moves will be protein moves, 1 of these moves will be solute moves and none of the moves will be volume moves (e.g. no volume moves will be performed). Note that you need to perform some volume moves if you wish to sample from the NPT ensemble!</p>
</div>
</div>
<div class="section" id="executing-protoms">
<h1>Executing ProtoMS<a class="headerlink" href="#executing-protoms" title="Permalink to this headline">¶</a></h1>
<p>ProtoMS is a simple program that may be used from the command line. Once you have compiled it you should find it in the top directory (it is called simply protoms3). If you run the program you should see that it prints out some information about the program and license, then it complains that nothing has been loaded so it closes down. The interface to ProtoMS has been designed to allow easy integration of ProtoMS with scripts, and to enable simple use from a command file. A ProtoMS input consists of a set of commands and values, e.g. the command <tt class="docutils literal"><span class="pre">temperature</span></tt> could have the value <em>25.0</em> . This would set the simulation temperature to <img class="math" src="_images/math/18132ecd2caa83f4f282c735327518e8dcc79339.png" alt="25^\circ"/> C. The input is passed to ProtoMS via a command file. The above command could thus be input by setting by placing the line</p>
<div class="highlight-python"><pre>temperature 25.0</pre>
</div>
<p>into a file and have ProtoMS read commands from that file. You specify the command file by passing it to ProtoMS on the command line, e.g.</p>
<div class="highlight-python"><pre>protoms3 mycmdfile.txt</pre>
</div>
<p>Note that ProtoMS is insensitive to whether commands, variables or contents of files are uppercase or lowercase, so you are free to mix and match capitals and small case wherever you want. The only exception to this is in the specification of filenames, where your operating system may care about case. As an example, depending on your operating system, ProtoMS may fail when the file containing the commands is named in upper case letters.</p>
<p>For replica exchange or ensemble type calculations, you have to execeute ProtoMS through the OpenMPI program, e.g.</p>
<div class="highlight-python"><pre>mpirun -np 16 protoms3 mycmdfile.txt</pre>
</div>
<div class="section" id="file-output">
<span id="index-27"></span><h2>File output<a class="headerlink" href="#file-output" title="Permalink to this headline">¶</a></h2>
<p>If you run ProtoMS from the command line you should see that it prints out a lot of information to the screen (on Unix called standard output, STDOUT). If you look closely at the output you should see that each line of output is preceeded by a tag, such as ‘HEADER’ or ‘INFO’. ProtoMS uses streams to output data, and these tags state which stream the line of data came from. Thus the information at the top of the output that gives the license and version details has been printed to the ‘HEADER’ stream, while the lines stating that ProtoMS is closing down because nothing has been loaded have gone to the ‘FATAL’ stream. ProtoMS uses the following streams</p>
<ul class="simple">
<li><strong>HEADER</strong> Used to print the program header.</li>
<li><strong>INFO</strong> Used to print general information.</li>
<li><strong>WARNING</strong> Warnings are printed to this stream. ProtoMS will generally try to continue if it detects a problem, and will print out information about any errors to the WARNING stream. It is up to you to check the WARNING stream to ensure that your simulation is working correctly.</li>
<li><strong>FATAL</strong> If an error is so serious that ProtoMS is forced to shutdown then it will first try to tell you what the problem is by sending text to the FATAL stream.</li>
<li><strong>RESTART</strong> The restart file is written to the RESTART stream.</li>
<li><strong>PDB</strong> Any output PDB files are written to the PDB stream.</li>
<li><strong>MOVE</strong> Information about moves are printed to this stream, e.g. whether or not a move was accepted, and how much progress has been made during the simulation.</li>
<li><strong>ENERGY</strong> Information about the energy components for the moves are printed to this stream, e.g. the bond energy of solute 1, or the coulomb energy between protein 1 and the solvent.</li>
<li><strong>RESULTS</strong> The results of the simulation are written to the RESULTS stream. These include the free energy averages and energy component averages.</li>
<li><strong>DETAIL</strong> The DETAIL stream contains lots of additional detail about the setup of the simulation. This can be very verbose, as it includes complete detail of the connectivity of the system and the loaded forcefield. The DETAIL stream is useful when you are setting a simulation up, though should be turned off when you are running production.</li>
<li><strong>SPENERGY</strong> The SPENERGY stream is used to report the results of single point energy calculations.</li>
<li><strong>ACCEPT</strong> The ACCEPT stream is used to print information about the numbers of attempted and accepted moves.</li>
<li><strong>RETI</strong> The RETI stream is used to report the energies needed by the RETI free energy method.</li>
<li><strong>DEBUG</strong> The DEBUG stream is used by the developers to report debugging information during a ProtoMS run. This stream is only active if ‘debug’ is set to true.</li>
</ul>
<p>These streams may be switched on or off, directed to STDOUT, directed to STDERR or directed to a file. You can do this by using the commands</p>
<div class="highlight-python"><pre>streamSTREAM STDOUT

streamSTREAM STDERR

streamSTREAM off

streamSTREAM /path/to/file.txt</pre>
</div>
<p>where <cite>STREAM</cite> is the name of the stream that you wish to direct (e.g. streamINFO). ProtoMS is insensitive to case, so you could use the command</p>
<div class="highlight-python"><pre>streaminfo stdout</pre>
</div>
<p>However, your operating system may be sensitive to case so you should ensure that you use the correct case for filenames.</p>
<p>You are free to direct multiple streams into a single file, or to turn undesired streams off. If a stream is output to STDOUT or STDERR then the name of the stream is prepended to the start of each line. The name is not attached if the stream is directed into a file. The WARNING and FATAL streams are special as unlike the other
streams, these two cannot be turned off. These two streams will be directed to STDERR if they have not been directed elsewhere.</p>
<p>By default, the HEADER, INFO, MOVE and RESULTS streams are directed to STDOUT, the WARNING and FATAL streams are directed to STDERR, and the remaining streams are switched off. Bear this in mind if you think that you should be getting output and you are not - make sure that the stream that contains your output is directed to something!</p>
<p>The streamSTREAM command is used to specify the direction of the stream at the start of the simulation. It is possible to redirect streams while the simulation is running. This is slightly more complicated than then streamSTREAM command, and is described in section <a class="reference internal" href="#misccmd"><em>Miscellaneous</em></a>.</p>
<p>By default ProtoMS overwrites the files specified by the streamSTREAM command. If you want to append to already exisiting files, for instance if you are restarting a simulation, you have to add the option</p>
<div class="highlight-python"><pre>appendstreams on</pre>
</div>
<p>This option will turn on append mode for all streams, except the <strong>RESTART</strong> stream that never will be appended.</p>
</div>
<div class="section" id="simulation-parameters">
<span id="parameters"></span><h2>Simulation parameters<a class="headerlink" href="#simulation-parameters" title="Permalink to this headline">¶</a></h2>
<p>There are many commands to set parameters that you can use to control your simulation. To make it easier to search for those relevant to your calculations, these will be divided in several subsections.</p>
<p>In the subsections below, unless otherwise specified:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">locical</span></tt> stands for <em>true</em> or <em>false</em>, <em>yes</em> or <em>no</em>, <em>on</em> or <em>off</em> (depending on your personal preference)</li>
<li><tt class="docutils literal"><span class="pre">integer</span></tt> or <tt class="docutils literal"><span class="pre">int</span></tt> stands for any integer number</li>
<li><tt class="docutils literal"><span class="pre">float</span></tt> stands for any floating point number</li>
<li><tt class="docutils literal"><span class="pre">string</span></tt> stands for a string of characters</li>
</ul>
<div class="section" id="parameters-for-developers">
<h3>Parameters for developers<a class="headerlink" href="#parameters-for-developers" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python" id="index-28"><pre>debug logical</pre>
</div>
<p>This turns on or off debugging output that may be useful for ProtoMS developers. By default <tt class="docutils literal"><span class="pre">debug</span></tt> is <em>off</em>.</p>
<div class="highlight-python" id="index-29"><pre>testenergy logical</pre>
</div>
<p>This is used to set whether or not to turn on testing of energies. This is useful if you are developing ProtoMS. By default <tt class="docutils literal"><span class="pre">testenergy</span></tt> is <em>off</em>.</p>
</div>
<div class="section" id="general-parameters">
<h3>General parameters<a class="headerlink" href="#general-parameters" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python" id="index-30"><pre>prettyprint logical</pre>
</div>
<p>Turn on or off pretty printing. With pretty printing turned on, you will see nice starry boxes drawn highlighting certain parts of the output. By default, <tt class="docutils literal"><span class="pre">prettyprint</span></tt> is <em>on</em>.</p>
<div class="highlight-python" id="index-31"><pre>dryrun logical</pre>
</div>
<p>Whether or not to perform a dry run of the simulation. If this is true then all of the files will be loaded up and your commands parsed. If there are any problems then these will be reported in the WARNING stream. No actual simulation will be run, though any files that would be created may be created. While this option is very useful for testing your commands, it is not perfect and cannot check everything. I thus recommend that you also perform a short version of your simulation before you commit yourself to full production. By default <tt class="docutils literal"><span class="pre">dryrun</span></tt> is off.</p>
<div class="highlight-python" id="index-32"><pre>ranseed integer</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">integer</span></tt> is any positive integer. This command is used to set the random number seed to be used by the random number generator. The random number seed can be any positive integer, and you will want to specify a seed if you wish to run reproducable simulations. If you do not specify a random number seed then a seed is generated based on the time and date that the simulation started.</p>
<div class="highlight-python" id="index-33"><pre>temperature float</pre>
</div>
<p>Use this command to specify the simulation temperature in <em>Celsius</em>. By default temperature is 25.0 C.</p>
<div class="highlight-python" id="index-34"><pre>pdbparam logical</pre>
</div>
<p>Whether or not to automatically detect and use, in the simulation, any chunks which might be included in the input PDB files after REMARK. It is most commonly used to include the fixresidues and fixbackbone commands often found at the beginning of a protein scoop. Any chunks included in pdb files will be applied before any other chunk. By default <cite>pdbparam</cite> is on.</p>
<div class="highlight-python" id="index-35"><pre>cutoff float</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">float</span></tt> is any positive number. This command is used to set the size of the non-bonded cutoff, in Angstroms, used to truncate the intermolecular non-bonded potentials (see eq <a href="#equation-intermol1">(1)</a>). By default the non-bonded cutoff is 15A.</p>
<div class="highlight-python" id="index-36"><pre>feather float</pre>
</div>
<p>To prevent an abrupt cutoff, the non-bonded energy is scaled quadratically down to zero over the last part of the cutoff (see eq <a href="#equation-intermol1">(1)</a>). The feather command sets the distance over which this scaling occurs, e.g.</p>
<div class="highlight-python"><pre>feather 1.3</pre>
</div>
<p>sets this feathering to occur over the last 1.3A. The default value of the feather is 0.5A.</p>
<div class="highlight-python" id="index-37"><pre>cuttype string</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">string</span></tt> is either <em>residue</em> or <em>molecule</em>. This specifies the type of non-bonded cutting to use; either residue, where the cutoff is between protein residues, solute molecules and solvent molecules, or molecule, where the cutoff is between protein molecules, solutes molecules and solvent molecules. By default the <tt class="docutils literal"><span class="pre">cuttype</span></tt> is <em>residue</em>.</p>
<div class="highlight-python" id="index-38"><pre>pressure float</pre>
</div>
<p>This command sets the pressure of the system in atmospheres. By setting the pressure to a non-zero value you will be able to perform a simulation in the NPT isothermal-isobaric ensemble. Note that you need to perform volume moves (see <a class="reference internal" href="#moves"><em>Generic Moves</em></a>) to be able to run in the NPT ensemble. By default the pressure is equal to zero, and thus a NPT simulation is not performed.</p>
<div class="highlight-python" id="index-39"><pre>maxvolchange float</pre>
</div>
<p>This command sets the maximum change in volume for a volume move in cubic Angstroms. This command only has meaning if an NPT simulation is being performed. By default <tt class="docutils literal"><span class="pre">maxvolchange</span></tt> is equal to the number of solvent molecules divided by ten.</p>
<div class="highlight-python"><pre>prefsampling integer</pre>
</div>
<p>This command is used to turn on preferential sampling of the solvent, and to specify which solute is used to define the center of the preferential sampling sphere. The command</p>
<div class="highlight-python" id="index-40"><pre>prefsampling 1</pre>
</div>
<p>means that the solvents closest to solute 1 will be moved more frequently than those furthest from solute 1. An optional parameter may be used to change the influence of the sphere, e.g.</p>
<div class="highlight-python"><pre>prefsampling 1 100.0</pre>
</div>
<p>will specify a preferential sampling sphere centered on solute 1, with a parameter of 100.0. The larger the parameter, the more highly focussed the influence of the sphere around the closest solvent molecules. By default the parameter is 200.0, and preferential sampling is turned off.</p>
<div class="highlight-python" id="index-41"><pre>boundary none</pre>
</div>
<p>This turns off any boundary conditions, i.e. the simulation will be performed in vacuum.</p>
<div class="highlight-python"><pre>boundary periodic dimx dimy dimz</pre>
</div>
<p>This turns on periodic boundaries, using a orthorhombic box centered on the origin, with dimensions <tt class="docutils literal"><span class="pre">dimx</span></tt> A by <tt class="docutils literal"><span class="pre">dimy</span></tt> A by <tt class="docutils literal"><span class="pre">dimz</span></tt> A. Note that these dimensions may be modified by any loaded solvent file</p>
<div class="highlight-python"><pre>boundary periodic ox oy oz tx ty tz</pre>
</div>
<p>This turns on periodic boundaries using an orthorhombic box with the bottom-left-back corner at coordinates (<tt class="docutils literal"><span class="pre">ox</span></tt> , <tt class="docutils literal"><span class="pre">oy</span></tt> , <tt class="docutils literal"><span class="pre">oz</span></tt>) A and the top-right-front corner at (<tt class="docutils literal"><span class="pre">tx</span></tt> , <tt class="docutils literal"><span class="pre">ty</span></tt> , <tt class="docutils literal"><span class="pre">tz</span></tt>) A. Note that these dimensions may be modified by any loaded solvent file.</p>
<div class="highlight-python"><pre>boundary cap ox oy oz rad k</pre>
</div>
<p>This turns on solvent cap boundary conditions. Protein and solute molecules will experience no boundary conditions, while solvent molecules will be restrained within a spherical region of radius rad A, centered at coordinates (<tt class="docutils literal"><span class="pre">ox</span></tt> , <tt class="docutils literal"><span class="pre">oy</span></tt> , <tt class="docutils literal"><span class="pre">oz</span></tt>) A. A half-harmonic restraint with force constant <tt class="docutils literal"><span class="pre">k</span></tt> kcal.mol-1.A-2 is added to the solvent energy if it moves outside of this sphere.</p>
<div class="highlight-python"><pre>boundary solvent</pre>
</div>
<p>This sets the boundary conditions to whatever is set by the loaded solvent files. If no solvent files are loaded then no boundary conditions are used. This is the default option, and the method of setting boundary conditions via a solvent file is described in section <a class="reference internal" href="#solventpdb"><em>Solvent File</em></a></p>
</div>
<div class="section" id="gbsa-parameters">
<h3>GBSA parameters<a class="headerlink" href="#gbsa-parameters" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python" id="index-42"><pre>surface quality 3 probe 1.4</pre>
</div>
<p>This command will cause surface area calculations to be performed during the simulation. <tt class="docutils literal"><span class="pre">quality</span></tt> can be set to 1,2,3,4 and will result in increasingly precise surface area calculations. For typical simulations, 3 should be fine and 2 will not give a huge error. <tt class="docutils literal"><span class="pre">probe</span></tt> is the radius of the probe and should be set to 1.4 if you want to calculate the solvent accessible surface area of water, but can be set to 0 if you want to calculate the van der waals surface area of a molecule.</p>
<div class="highlight-python" id="index-43"><pre>born cut 20 threshold 0.005 proteins</pre>
</div>
<p>This command will enable Generalised Born energy calculations. Thus to run a full GBSA simulation you should use both the surface and born keywords. cut controls the cutoff distance for the computation of the Born radii. If you work with a medium sized protein scoop of circa 100-150 residues, 20 should be fine but you may want a larger value for simulations of large proteins. threshold controls the number of pairwise terms that are not updated when the effective Born radii must be calculated by the Pairwise descreening approximation. The default value
0.005 appear to be a good tradeoff. Increasing it will make the simulation faster but less accurate. proteins activates the rescaling of the Born radii to compensate for systematic errors of the Pairwise Descreening Approximation in large biomolecules. It should be used only when simulating proteins and then its effectiveness has not been yet
convincingly demonstrated.</p>
<p><em>WARNING: These commands are considered to be deprecated.</em> This means that they are not developed any more and have not been tested extensively with newer features. Dump commands are supported with the <cite>simulate</cite> command and one can do simple MC sampling with GB. However, it is not sure that free energy or the replica-exchange commands work satisfactorily.</p>
</div>
<div class="section" id="temperature-replica-exchange-parameters">
<h3>Temperature replica-exchange parameters<a class="headerlink" href="#temperature-replica-exchange-parameters" title="Permalink to this headline">¶</a></h3>
<p>ProtoMS can perform temperature replica-exchange simulations.</p>
<div class="highlight-python" id="index-44"><pre>temperaturere integer float float float</pre>
</div>
<p>is the command to set a replica exchange simulation between the different temperatures given as floats, where <tt class="docutils literal"><span class="pre">float</span></tt> is any positive float, and temperatures are given en Celsius. In principle, any desired number of temperature values can be used, and the simulation will require to be runned in as many cores as temperature values are provided. The integer value stands for the frequency at which the exchange between the different temperature values is attempted. Please, note that this value should be a multiple of the frequency of printing output when the dump commands are used (see <a class="reference internal" href="#frequent-output-generation">Frequent output generation</a>). If no exchange is desired, the frequency of exchange can simply be set to the total number of moves of the simulation.</p>
<p>As an example:</p>
<div class="highlight-python"><pre>temperaturere 20 25.0 30.0 35.0</pre>
</div>
<p>corresponds to a simulation which will run at three different temperature windows in parallel, and will attempt swaps between the conformations of different temperature windows each 20 moves.</p>
<p>The temperature replica-exchange command can be used in conjuction with the <tt class="docutils literal"><span class="pre">lambdare</span></tt> command, see below, to add temperature ladders to different values of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>.</p>
<div class="highlight-python" id="index-45"><pre>solutetempering 25.0 bndang 3 dih 1 lj 3 coul 1 solu 2 prot 2 solv 2</pre>
</div>
<p>Turns on replica-exchange with solute tempering (REST). It only works if you have specified temperature replica-exchange (see <a class="reference internal" href="#temperature-replica-exchange-parameters">Temperature replica-exchange parameters</a>). In this type of simulation the system is simulated at 25.0 Celsius, or the temperature set with this command, and the temperatures set with the <tt class="docutils literal"><span class="pre">temperaturere</span></tt> command are used to scale the solute energies. The level of scaling for the different energy components can be set with the rest of the options; <tt class="docutils literal"><span class="pre">bndang</span></tt> controls the internal bond-angle energy terms, <tt class="docutils literal"><span class="pre">dih</span></tt> the internal dihedral energy term, <tt class="docutils literal"><span class="pre">lj</span></tt> the internal van der Waals energy, <tt class="docutils literal"><span class="pre">coul</span></tt> the internal Coulomb energy, <tt class="docutils literal"><span class="pre">solu</span></tt> the interaction with other solutes, <tt class="docutils literal"><span class="pre">prot</span></tt> the interaction with the protein and <tt class="docutils literal"><span class="pre">solv</span></tt> the interaction with solvent molecules. Each argument can be either 1, 2 or 3. If the argument is 1, the energy is scaled with <img class="math" src="_images/math/575da08fd1865945d250d247cb3123b51455abf3.png" alt="\beta_i/\beta_0"/>, where <img class="math" src="_images/math/69b7960de2d0464d76554a59404da87b450fe890.png" alt="\beta_i"/> is the effective inverse temperature of the replica (set with the <tt class="docutils literal"><span class="pre">temperaturre</span></tt> command) and <img class="math" src="_images/math/5a0edd6f80ab5f09590cb9c0c545a6ea08da4f03.png" alt="\beta_0"/> is the inverse simulation temperature (set with this command). If the argument is 2, the energy is scaled with <img class="math" src="_images/math/a074087affd16305b56a36664a3d8c9dc87124f2.png" alt="(\beta_i+\beta_0)/2\beta_0"/> and if the argument 3 the energy is unscaled.</p>
</div>
<div class="section" id="free-energy-calculation-parameters">
<h3>Free energy calculation parameters<a class="headerlink" href="#free-energy-calculation-parameters" title="Permalink to this headline">¶</a></h3>
<p>To be able to run a single simulation for a given lambda value, you will need to use the following parameters:</p>
<div class="highlight-python" id="index-46"><pre>lambda float</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">float</span></tt> is a number between 0.0 and 1.0. Specify the value of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. If a single value is given then that is used for <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. If three values are given then these are used for <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>, and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> in the forwards and backwards windows, e.g.</p>
<div class="highlight-python"><pre>lambda 0.5 0.6 0.4</pre>
</div>
<p>would set <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> for the reference state to 0.5, <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> for the forwards perturbed state to 0.6, and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> for the backwards perturbed state to 0.4. By default all values of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> are 0.0.</p>
<p>To run several at several values of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>  in parallel and hence perform your full perturbation at once with ProtoMS, you will need the commands shown below. Running your free energy calculation in this manner, you will be able to attempt exchanges between the configurations of your system at the different lambdas, increasing the probability of convergence.</p>
<div class="highlight-python" id="index-47"><pre>lambdare integer float float float</pre>
</div>
<p>is the command to set a replica exchange calculation between the different <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> given as floats, where <tt class="docutils literal"><span class="pre">float</span></tt> is a number between 0.0 and 1.0. In principle, any desired number of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> values can be used, and the simulation will require to be runned in as many cores as <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> values are provided. The integer value stands for the frequency at which the exchange between the different <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> values is attempted. Please, note that this value should be a multiple of the frequency of printing output when the dump commands are used (see <a class="reference internal" href="#frequent-output-generation">Frequent output generation</a>). If no exchange is desired, the frequency of exchange can simply be set to the total number of moves of the simulation.</p>
<p>As an example:</p>
<div class="highlight-python"><pre>lambdare 20 0.000 0.333 0.667 1.000</pre>
</div>
<p>corresponds to a simulation which will run at four different <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows in parallel, and will attempt swaps between the conformations of different <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows each 20 moves.</p>
<p><strong>With temperature replica-exchange</strong></p>
<div class="highlight-python" id="index-48"><pre>temperatureladder lambda float float</pre>
</div>
<p>is one of the commands required to proceed with a simulation including both temperature and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> replica exchange, where <tt class="docutils literal"><span class="pre">float</span></tt> is each of the <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> values where a temperature ladder is desired. All <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> values must be among those included after the <tt class="docutils literal"><span class="pre">lambdare</span></tt> keyword. In principle, the number of temperature ladders can be as high as the number of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows.</p>
<p>As an example:</p>
<div class="highlight-python"><pre>temperatureladder lambda 0.00 1.00</pre>
</div>
<p>corresponds to a simulation which runs the <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windowns 0.00 and 1.00 at all temperatures included after the <tt class="docutils literal"><span class="pre">temperaturere</span></tt> keyword, as far as the corresponding <tt class="docutils literal"><span class="pre">lambdaladder</span></tt> command line is set accordingly.</p>
<div class="highlight-python" id="index-49"><pre>lambdaladder temperature float float</pre>
</div>
<p>is one of the commands required to proceed with a simulation including both temperature and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> replica exchange, where <tt class="docutils literal"><span class="pre">float</span></tt> is each of the temperature values where a <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> ladder is to be placed. All temperature values must be among those included after the <tt class="docutils literal"><span class="pre">temperaturere</span></tt> keyword. In principle, the number of lambda ladders can be as high as the number of temperatures in temperaturere. The number of cores must be calculated based on the number of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> ladders and temperature ladders, as well as <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> and temperature values per ladder, takind into account the cores shared by each <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> ladder with each temperature ladder.</p>
<p>As an example:</p>
<div class="highlight-python"><pre>lambdaladder temperature 25.0 35.0</pre>
</div>
<p>corresponds to a simulation which runs all <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windowns at temperatures 25.0 and 35.0, as far as the corresponding <tt class="docutils literal"><span class="pre">temperatureladder</span></tt> command line is set accordingly.</p>
<p>All replica-exchange commands together:</p>
<div class="highlight-python"><pre>lambdare 20 0.000 0.333 0.667 1.000
temperaturere 20 25.0 30.0 35.0
temperatureladder lambda 0.00 1.00
lambdaladder temperature 25.0 35.0</pre>
</div>
<p>correspond to a simulation where <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows 0.000 0.333 0.667 1.000 are simulated at 25.0 and 35.0 Celsius, while at temperature 30.0, only <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows 0.000 and 1.000 will be simulated.</p>
<p><strong>Other free energy commands</strong></p>
<div class="highlight-python" id="index-50"><pre>dlambda float</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">float</span></tt> is a number between 0.0 and 1.0 (often of the order of 0.001). This command sets the gradient for a free energy calculation. It is required for thermodynamic integration (TI) to be applied on the simulation results.</p>
<div class="highlight-python" id="index-51"><pre>printfe string</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">string</span></tt> should be either <tt class="docutils literal"><span class="pre">off</span></tt>, <tt class="docutils literal"><span class="pre">bar</span></tt> or <tt class="docutils literal"><span class="pre">mbar</span></tt>. Whether to print the free energy estimates required to proceed with BAR or MBAR calculations. Take into acount that this estimates will take some time. Your simulations may run faster when this option is set to off (default).</p>
<p>In case dual topology is desired, whether it is for a single or multiple <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> simulation, the following parameters must be used:</p>
<div class="highlight-python"><pre>dualtopologyint integer1 integer2 synctrans syncrot</pre>
</div>
<p>This turns on the dual topology method of calculating relative free energies, where <cite>int1</cite> is the perturbed solute at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and <cite>in2</cite> is the solute at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0 . If <tt class="docutils literal"><span class="pre">synctrans</span></tt> is set, the rigid body translations of the two solutes will be synchronised. If <tt class="docutils literal"><span class="pre">syncrot</span></tt> is set, the rigid body rotations of the two solutes will also be synchronised.</p>
<div class="highlight-python" id="index-52"><pre>softcoreint solute integer</pre>
</div>
<p>This causes the intermolecular energy of solute integer to be softened. Alternatively, you can write <tt class="docutils literal"><span class="pre">all</span></tt> instead of the solute index and all solutes will have their non bonded energy softened. The softcore is only supported for solutes.</p>
<div class="highlight-python" id="index-53"><pre>softcoreparams coul 1 delta 1.5 gb 0 old</pre>
</div>
<p>This causes the solutes non bonded energy to be softened with a parameter <em>n</em> set to 1 and <img class="math" src="_images/math/0a42a8b725c200085e5253db2d2fbf8dab898a8f.png" alt="\delta"/> set to 1.5. (see eq <a href="#equation-uljsoftmod">(17)</a>). The old keyword selects the original soft-core implementation and can be omitted. If conducting a GBSA simulation, this also causes the GB energy to be softened as well. It is recommended to use the same parameter for the Coulombic and Generalised Born energy. The values listed here, seem to work well for a number of relative binding free energy calculations but actual optimum values of these parameters will depend on your system.</p>
<div class="highlight-python"><pre>softcoreparams coul 1 delta 0.2 deltacoul 2.0 soft66</pre>
</div>
<p>This causes the solutes non bonded energy to be softened with a parameter <em>n</em> set to 1, <img class="math" src="_images/math/0a42a8b725c200085e5253db2d2fbf8dab898a8f.png" alt="\delta"/> set to 0.2 and <img class="math" src="_images/math/3478748db61344e708754bdac6aae7b6a1fd2de4.png" alt="\delta_c"/> set to 2.0. (see eq <a href="#equation-uljsoftmod2">(18)</a>). The soft66 keyword selects the second soft-core implementation, eq <a href="#equation-uljsoftmod2">(18)</a> .</p>
<div class="highlight-python"><pre>softcoreparams coul 1 delta 0.5 deltacoul 12.0 amber</pre>
</div>
<p>This causes the solutes non bonded energy to be softened with a parameter <em>n</em> set to 1, <img class="math" src="_images/math/0a42a8b725c200085e5253db2d2fbf8dab898a8f.png" alt="\delta"/> set to 0.5 and <img class="math" src="_images/math/3478748db61344e708754bdac6aae7b6a1fd2de4.png" alt="\delta_c"/>  set to 12.0. (see eq <a href="#equation-uljsoftmod3">(19)</a> ). The amber keyword selects the third soft-core implementation, eq <a href="#equation-uljsoftmod3">(19)</a>. The values listed here are the default values in the Amber package.</p>
</div>
<div class="section" id="gcmc-and-jaws-parameters">
<h3>GCMC and JAWS parameters<a class="headerlink" href="#gcmc-and-jaws-parameters" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python" id="index-54"><pre>gcmc 0</pre>
</div>
<p>This command tells ProtoMS that it is to perform a GCMC simulation, and that the starting value of <img class="math" src="_images/math/a321d1b883ba985b1f59ca076beaaf17aa8ab06c.png" alt="\Theta"/> all of the GCsolutes is 0.</p>
<div class="highlight-python" id="index-55"><pre>potential float</pre>
</div>
<p>This command will set a <em>B</em>-value of <tt class="docutils literal"><span class="pre">float</span></tt> (i.e. -8) for moves in the Grand Canonical Ensemble. The value of <em>B</em> can be related to the excess chemical by the following equation:</p>
<div class="math" id="equation-bval">
<p><span class="eqno">(20)</span><img src="_images/math/48bb709cc3c30bd7677dfbcd03ed46c19801ae9b.png" alt="B = \frac{\mu'}{k_{B}T}+\ln \bar{n}" /></p>
</div><p>In the equation, <img class="math" src="_images/math/113db59b4c977e5b153bb0858a89cb945170ba74.png" alt="\bar{n}"/> is the number density of the GCsolute multiplied by the simulation subvolume.</p>
<div class="highlight-python" id="index-56"><pre>multigcmc float float float</pre>
</div>
<p>is the right command to several gcmc simulations running in parallel for different B values. Each <tt class="docutils literal"><span class="pre">float</span></tt> is the B value for each independent calculation. In principle, the number of B values is not restricted. The simulation will need to be submited to run in parallel in as many cores as B values.</p>
<div class="highlight-python" id="index-57"><pre>originx float</pre>
</div>
<p>This command will set the X origin of the defined GCsolute sampling subvolume to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>originy float</pre>
</div>
<p>This command will set the Y origin of the defined GCsolute sampling subvolume to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>originz float</pre>
</div>
<p>This command will set the Z origin of the defined GCsolute sampling subvolume to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>x float</pre>
</div>
<p>This command will set the distance along the X coordinate from originx to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>y float</pre>
</div>
<p>This command will set the distance along the Y coordinate from originy to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>z float</pre>
</div>
<p>This command will set the distance along the Z coordinate from originz to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<p>Alternatively to the origin, the position of the box may be set using its center:</p>
<div class="highlight-python"><pre>centerx float</pre>
</div>
<p>This command will set the X center of the defined GCsolute sampling subvolume to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>centery float</pre>
</div>
<p>This command will set the Y center of the defined GCsolute sampling subvolume to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>centerz float</pre>
</div>
<p>This command will set the Z center of the defined GCsolute sampling subvolume to be 9</p>
<p>A different, equally valid expression for the distance or length of the box is the keyword <cite>len?</cite>:</p>
<div class="highlight-python"><pre>lenx float</pre>
</div>
<p>This command will set the distance along the X coordinate from originx to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>leny float</pre>
</div>
<p>This command will set the distance along the Y coordinate from originy to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python"><pre>lenz float</pre>
</div>
<p>This command will set the distance along the Z coordinate from originz to be the specified <tt class="docutils literal"><span class="pre">float</span></tt></p>
<div class="highlight-python" id="index-58"><pre>jaws1 0</pre>
</div>
<p>This command tells ProtoMS that it is to perform a JAWS stage one simulation, and that the starting value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> all of the GCsolutes is 0.</p>
<div class="highlight-python" id="index-59"><pre>thres 0.95</pre>
</div>
<p>This command will set the <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> threshold for defining whether a molecule is <em>on</em> in the first stage of the JAWS method to be 0.95 (default)</p>
<p>Note here that, in order to run a JAWS stage 1 calculation, you will also need to include softcores. The parameters to do this can be found among the <a class="reference internal" href="#free-energy-calculation-parameters">Free energy calculation parameters</a>.</p>
<div class="highlight-python" id="index-60"><pre>jaws2 1</pre>
</div>
<p>This command tells ProtoMS that it is to perform a JAWS stage two simulation, and that the starting value of <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/> all of the GCsolutes is 1.</p>
<div class="highlight-python" id="index-61"><pre>jbias float</pre>
</div>
<p>This command will set the value of the biasing potential in the second stage of the JAWS algorithm to be <tt class="docutils literal"><span class="pre">float</span></tt>, in kcal/mol (i.e. 14).</p>
</div>
</div>
<div class="section" id="specifying-input-files">
<span id="incmd"></span><h2>Specifying input files<a class="headerlink" href="#specifying-input-files" title="Permalink to this headline">¶</a></h2>
<p>As well as controlling the simulation, commands are also used to specify the names of the input files that describe the system and forcefield for the simulation. These input files are specified using the following commands</p>
<div class="highlight-python" id="index-62"><pre>proteinN filename</pre>
</div>
<p>Specifies the name of the Nth protein file, e.g.</p>
<div class="highlight-python"><pre>protein1 protein.pdb</pre>
</div>
<p>specifies that protein 1 should be loaded from the file protein.pdb. Note that proteins must be numbered sequentially from 1 to MAXPROTEINS. The format of a protein file is described in <a class="reference internal" href="#protpdb"><em>Protein File</em></a>.</p>
<div class="highlight-python" id="index-63"><pre>soluteN filename</pre>
</div>
<p>specifies the name of the Nth solute file. Note that the solutes must be numbered sequentially from 1 to MAXSOLUTES. The format of a solute file is described in section <a class="reference internal" href="#solpdb"><em>Solute File</em></a>.</p>
<div class="highlight-python"><pre>solventN filename</pre>
</div>
<p>specifies the name of the Nth solvent file. Unlike the protein and solute files, the solvent file may contain multiple solvent molecules, though the total number of solvent molecules cannot exceed MAXSOLVENTS. The format of a solvent file is described in section <a class="reference internal" href="#solventpdb"><em>Solvent File</em></a>.</p>
<div class="highlight-python" id="index-64"><pre>grandN filename</pre>
</div>
<p>specifies the name of the Nth GCsolute file. Unlike the protein and solute files, the GCsolute file may contain multiple GCsolute molecules, though the total number of GCsolute molecules cannot exceed MAXSOLVENTS. The format of a GCsolute file is described in section <a class="reference internal" href="#gcpdb"><em>GCsolute File</em></a>.</p>
<div class="highlight-python" id="index-65"><pre>parfile filename</pre>
</div>
<p>Specify the name of a forcefield parameter file. You can specify as many parameter files as you wish. The list of parameter files is read from top to bottom, such that if any paramater files contain contradictory information, the last parameters read by ProtoMS are used. The format of the parameter file is described in section <a class="reference internal" href="#parfil"><em>Parameter / Forcefield Files</em></a> .</p>
</div>
<div class="section" id="running-a-simulation">
<span id="runcmd"></span><h2>Running a Simulation<a class="headerlink" href="#running-a-simulation" title="Permalink to this headline">¶</a></h2>
<p id="index-66">There are two main keywords related to running a simulation. These are <cite>chunk</cite> and <cite>dump</cite>. All individual actions (commands which ProtoMS should perform only as it is prompted to do so) are handled with <cite>chunk</cite> lines. Actions which ProtoMS should perform with a certain frequency <em>while</em> the simulation is running, are handled with <cite>dump</cite> lines. We can start by talking about chunks.</p>
<p>A simulation can be run as a sequence of chunks. Different things may be accomplished in each chunk, e.g. running some steps of equilibration, printing the protein coordinates to a PDB or redirecting a stream to a new file. Chunks may be mixed and matched, and you can run as many chunks as you desire within a single simulation. You specify a chunk using the command</p>
<div class="highlight-python"><pre>chunk chunk command</pre>
</div>
<p>Chunks are executed in the order they appear in the command file.</p>
<div class="section" id="equilibration-and-production">
<h3>Equilibration and Production<a class="headerlink" href="#equilibration-and-production" title="Permalink to this headline">¶</a></h3>
<p>The meat of a simulation is equilibration and production. In ProtoMS equilibration is defined as sampling without the collection of free energy or energy averages, while production is sampling with the collection of free energy and energy averages. Equilibration and production are specified using the equilibrate and simulate chunks, e.g.</p>
<div class="highlight-python" id="index-67"><pre>chunk equilibrate 50</pre>
</div>
<p>performs 50 steps of equilibration.</p>
<div class="highlight-python" id="index-68"><pre>chunk simulate 1000</pre>
</div>
<p>performs 1000 steps of production.</p>
<p>Additional options may be passed to these two chunks to control the probability of different types of move and the frequency of printing out move and energy details to the MOVE and ENERGY streams. These options are</p>
<div class="highlight-python" id="index-69"><div class="highlight"><pre><span class="n">printmove</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Print move and energy information every N moves.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">protein</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of protein moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solute</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of solute moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solvent</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of solvent moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gcsolute</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of gcsolute moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">insertion</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of insertion moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">deletion</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of deletion moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">theta</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of GCsolute theta moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sample</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of GCsolute sample moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">volume</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>Set the relative probability of volume moves to N.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">newprob</span>
</pre></div>
</div>
<p>Reset relative move probabilities to zero.</p>
<p>Note that succeeding equilibration or production chunks inherit the move probabilities and printing frequency of preceeding simulation or equilibration chunks. I thus recommend that you use the newprob option to reset the move probabilities for each equilibration or production chunk you run.</p>
<p>The following examples illustrate the use of these options;</p>
<div class="highlight-python"><pre>chunk newprob equilibrate 500 printmove=10 protein=1 solvent=1000</pre>
</div>
<p>Perform 500 steps of equilibration, printing move and energy information every 10 moves, making on average 1 protein move for every 1000 solvent moves (and performing no other types of move).</p>
<div class="highlight-python"><pre>chunk equilibrate 100 solute=500</pre>
</div>
<p>Perform 100 steps of equilibration. Because this chunk will inherit from the previous chunk, the move and energy information will still be printed every 10 moves, and still, on average 1 protein move will be made every 1000 solvent moves. However this line has added that on average 500 solute moves should be made for every 1000 solvent moves, thus the probability of a protein move is now 1 in 1501, the probablity of a solute move is 500 in 1501, and the probability of a solvent move is 1000 in 1501.</p>
<div class="highlight-python"><pre>chunk simulate 500 printmove=1 newprob volume=1 solvent=300</pre>
</div>
<p>Now perform 500 steps of production, printing move and energy information every move, performing no protein moves, and 1 volume move for every 300 solvent moves.</p>
<p>A couple of <em>simulate-like</em> commands are specifically related to GBSA simulations.</p>
<div class="highlight-python" id="index-70"><pre>chunk splitgbsasimulate 100 10 solute=1 protein=9</pre>
</div>
<p>The above command should only be used if you are doing an implicit solvent simulation (e.g, you turned on the surface and born keywords). This will cause to run 10 moves with a crude GBSA potential and then perform an acceptance test based on the difference of energies between the crude GBSA potential and the GBSA potential you set with the cutoff, born and surface keywords. This will be repeated 100 times. Here the move probabilities were set to 1 and 9 for solute and protein, but could be other figures. After this keyword has been used it is advised to use the following keyword.</p>
<p><em>WARNING: this command is deprecated.</em> For instance, it does not support the dump commands</p>
<div class="highlight-python" id="index-71"><pre>chunk resetgb</pre>
</div>
<p>This will cause the total energy of the system to be calculated fully and the Born radii to be correctly updated. Periodic usage of this command, along with the previous one, avoids drifts in the total energy of the system.</p>
</div>
<div class="section" id="results-and-restarts">
<h3>Results and Restarts<a class="headerlink" href="#results-and-restarts" title="Permalink to this headline">¶</a></h3>
<p>As well as controlling the sampling, you can also control the collection and output of results using simulation chunks, and the reading and writing of restart files.</p>
<div class="highlight-python" id="index-72"><pre>chunk results reset</pre>
</div>
<p>Reset all averages to zero and start collection of results from scratch.</p>
<div class="highlight-python"><pre>chunk results write</pre>
</div>
<p>Write out the energy and free energy averages to the RESULTS stream. It is probably a good idea to do this a some point before the end of the simulation.</p>
<div class="highlight-python"><pre>chunk results write myfile.txt</pre>
</div>
<p>Does the same as above, but redirects the RESULTS stream to myfile.txt before the results are written.</p>
<div class="highlight-python"><pre>chunk results writeinst myfile.txt</pre>
</div>
<p>Does the same av <cite>write</cite> but instead write instantaneous energies (the energies of the current snapshot) rather than average energies. This can be useful for some analyses.</p>
<div class="highlight-python" id="index-73"><pre>chunk restart write</pre>
</div>
<p>Write a restart file for the current configuration to the RESTART stream.</p>
<div class="highlight-python"><pre>chunk restart write myfile.txt</pre>
</div>
<p>Does the same as above, but redirects the RESTART stream to myfile.txt before the restart file is written.</p>
<div class="highlight-python"><pre>chunk restart read myfile.txt</pre>
</div>
<p>Read in a restart file from the file myfile.txt.</p>
<p>Note that all the <cite>chunk averages</cite> lines above are equally valid, if <cite>results</cite> is written instead of <cite>averages</cite>:</p>
<div class="highlight-python"><pre>chunk results write myfile.txt</pre>
</div>
</div>
<div class="section" id="pdb-output">
<h3>PDB Output<a class="headerlink" href="#pdb-output" title="Permalink to this headline">¶</a></h3>
<p id="index-74">You can use a simulation chunk to output a PDB of the current configuration. The output can be tailored to include only the parts of the system that you are interested in. This is useful if you are trying to conserve disk usage. You can output PDBs using the ‘pdb’ chunk</p>
<div class="highlight-python"><pre>chunk pdb all</pre>
</div>
<p>Output a PDB of all proteins and solutes to the PDB stream</p>
<div class="highlight-python"><pre>chunk pdb protein=all</pre>
</div>
<p>Output a PDB of all proteins to the PDB stream</p>
<div class="highlight-python"><pre>chunk pdb protein=2</pre>
</div>
<p>Output a PDB of protein 2 to the PDB stream</p>
<div class="highlight-python"><pre>chunk pdb solute=all</pre>
</div>
<p>Output a PDB of all solutes to the PDB stream</p>
<div class="highlight-python"><pre>chunk pdb solute=1</pre>
</div>
<p>Output a PDB of solute 1 to the PDB stream</p>
<p>The output PDB can be controlled via additional commands added to the above lines, e.g.:</p>
<div class="highlight-python"><pre>chunk pdb all solvent=all</pre>
</div>
<p>Output the PDB including all solvent molecules.</p>
<div class="highlight-python"><pre>chunk pdb solute=1 solvent=5.0</pre>
</div>
<p>Output a PDB including all solvent molecules within 5.0A of whatever else is printed - in this case solute 1.</p>
<div class="highlight-python"><pre>chunk pdb protein=1 showdummies</pre>
</div>
<p>Output a PDB that also includes dummy atoms.</p>
<div class="highlight-python"><pre>chunk pdb solute=all showhidden</pre>
</div>
<p>Output a PDB that also includes hidden solute molecules (solutes that are used to perform geometry perturbations).</p>
<div class="highlight-python"><pre>chunk pdb all file=myfile.txt</pre>
</div>
<p>Redirect the PDB stream to myfile.txt then print the PDB.</p>
<div class="highlight-python"><pre>chunk pdb all solvent=all standard</pre>
</div>
<p>Output a PDB that have a more standard format than normal, such that it can be viewed and interpreted correctly in most programs.</p>
</div>
<div class="section" id="restraints">
<span id="index-75"></span><h3>Restraints<a class="headerlink" href="#restraints" title="Permalink to this headline">¶</a></h3>
<p>ProtoMS supports a number of restraining potentials which can be used to modify the potential energy function and bias the simulation towards particular configurations. To use a restraint in ProtoMS you must first assign an id number to a particular atom or set of atoms, using the following command</p>
<div class="highlight-python"><pre>chunk id add int1 type int2 atname resname|resnumber</pre>
</div>
<p>where <cite>int1</cite> is the index numberr for this id. So if this if the first id you create you may want to use the number 1. type can be SOLUTE or SOLVENT or PROTEIN depending on where the atom you want to tagg is. <cite>atname</cite> is the name of the atom (e.g CA), <cite>resname</cite> is the name of the residue the atom is in if you are dealing with a SOLUTE or SOLVENT. However if it the atom is in a protein, then you must use the PDB residue number.
Once you have specified a few ids, you can create restraints using these ids and the following command</p>
<div class="highlight-python"><pre>chunk restraint add id1[-id2-id3-id4] type1 type2 [other parameters]</pre>
</div>
<p>where <cite>id1</cite> to <cite>id4</cite> designate up to four ids. <cite>type1</cite> designate the type of the restraint. It can be either <cite>cartesian</cite>,`bond` or <cite>dihedral</cite>. In the first case the restraint is applied in cartesian coordinates and will apply to only one atom (<cite>id1</cite>). In the second case, it is applied in internal coordinates, and will apply to only two atoms (<cite>id1</cite>-<cite>id2</cite>). In the last case it is applied to four atoms (<cite>id1</cite>-<cite>id2</cite>-<cite>id3</cite>-<cite>id4</cite>) and in internal coordinates. <cite>type2</cite> designate the functional form of the restraint. It can be <cite>harmonic</cite> or <cite>flatbottom</cite>. Each functional form requires additional parameters. The following options are currently possible:</p>
<div class="highlight-python" id="index-76"><pre>chunk restraint add id1 cartesian harmonic xrest yrest zrest krest</pre>
</div>
<p>For a cartesian harmonic restraint you need to specify the coordinates of the anchoring point and the value of the force constant.</p>
<div class="highlight-python"><pre>chunk restraint add id1 cartesian flattbottom xrest yrest zrest krest wrest</pre>
</div>
<p>For a flatbottom restraint you must in addition specify the width of the flat region of the potential.</p>
<div class="highlight-python" id="index-77"><pre>chunk restraint add id1-id2 bond harmonic krest</pre>
</div>
<p>For a bond restraint you must specify only the force constant</p>
<div class="highlight-python" id="index-78"><pre>chunk restraint add id1-id2-id3-id4 dihedral harmonic theta krest</pre>
</div>
<p>For a dihedral harmonic restraint you must specify the target equilibrium angle and the force constant. This restraint does not work on solvent molecules and on protein backbone atoms.</p>
<p>The following example shows how to add a harmonic potential restraint between a ligand atom and a protein atom.</p>
<div class="highlight-python"><pre>chunk id add 1 SOLUTE 1 N2 LI8</pre>
</div>
<p>This chunk will create id number 1 which will point to solute atom 1 (the first atom in the solute pdb file), named c00, from residue L10.</p>
<div class="highlight-python"><pre>chunk id add 2 PROTEIN 1 O 318</pre>
</div>
<p>This chunk will create id number 2 which will point to protein pdb loaded as protein1 by ProtoMS. The atom named O in residue 318 will be selected. Note that 318 is the residue number that appear in the PDB file. It is not necessarily the 318th residue to be loaded by ProtoMS in this protein.</p>
<div class="highlight-python"><pre>chunk restraint add 1-2 bond harmonic 5.0 3.33</pre>
</div>
<p>This chunk will cause a restraint to be added between the atoms id 1 and 2 points to. The functional form of this restraint will be a harmonic potential that is function of the distance between these two atoms. The force constant will be 5 kcal mol - 1. A - 2 and the equilibrium distance 3.33 angstrom.</p>
<p id="index-79">Applying a hardwall restraint is slightly different</p>
<div class="highlight-python"><pre>chunk id add 1 SOLUTE 2 O00 WAT</pre>
</div>
<p>This chunk will create id number 1 which will point to solute number 2, looking at the O00 atom of resname WAT</p>
<div class="highlight-python"><pre>chunk hardwall 1 25.890 16.895 59.083 1.8 1000000000</pre>
</div>
<p>This chunk will apply a hardwall restraint to the center of geometry of the solute number 2. The form of this restraint is spherical, with a radius of 1.8 and will be centered at the point defined by the coordinates 25.890 16.895 59.083. If the center of geometry of the molecule attempts to leave this radius then a huge penalty is applied, preventing the move. Equally, if any atom from another molecule tries to occupy the hardwall region then the penalty is applied.</p>
<p>A hardwall restraint can also be applied on the initial position of the center of geometry of a ligand. In this case, no coordinates need to be specified, and the lines results:</p>
<div class="highlight-python"><pre>chunk hardwall 1 1.8 1000000000</pre>
</div>
<p>This option should be quite useful when the ligand simply wants to be kept in its initial position.</p>
</div>
<div class="section" id="frequent-output-generation">
<h3>Frequent output generation<a class="headerlink" href="#frequent-output-generation" title="Permalink to this headline">¶</a></h3>
<p>Incidental generation of output files might not be convenient either for the production of results and restart files nor for PDB outputs. Consistently, there is an alternative option which allows for the generation of these files <em>while</em> the <cite>simulate</cite> chunk is running.</p>
<p id="index-80">This is controlled with the alternative key word dump:</p>
<div class="highlight-python"><pre>dump frequency command</pre>
</div>
<p>This manner of output generation can be applied to all commands included in <a class="reference internal" href="#results-and-restarts">Results and Restarts</a> secction, as well as <a class="reference internal" href="#pdb-output">PDB output</a> section.</p>
<p>An example of a dump line would be:</p>
<div class="highlight-python"><pre>dump 100000 results write results</pre>
</div>
<p>This line, given as input for ProtoMS, will append results information to the <cite>results</cite> file every 100000 moves, thoughout the <cite>simulate</cite> part of your simulation.</p>
<p>It is important to note how the appending behaviour variates. For frequent results and PDB printing, new results will be appended to the existent file. However for the restart generation, the existing file will be overwritten every time and the old restart will be moved to another file. Consistently these imput lines:</p>
<div class="highlight-python"><pre>dump 100 results write results
dump 100 pdb all file=all.pdb
dump 100 restart write restart
dump 100 averages reset
chunk simulate 400 solvent=10 solute=5 volume=1</pre>
</div>
<p>Will generate four results reports all appended to the file <cite>results</cite>, four PDB conformations of the system appended to <cite>all.pdb</cite>, but only one restart report (the last printed) in the file <cite>restart</cite>.</p>
<p>Dump lines can be written in any order, and they all will be applied while the <cite>simulate</cite> chunk is running.</p>
</div>
<div class="section" id="miscellaneous">
<span id="misccmd"></span><h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h3>
<p>As well as running the simulation, there are also a collection of other things that you can do in a simulation chunk. These are</p>
<div class="highlight-python" id="index-81"><pre>chunk singlepoint</pre>
</div>
<p>Calculate the energy of the current system and output it to the SPENERGY stream. This is useful if you just want to use ProtoMS to evaluate a forcefield energy. You can set up the input files, turn off all streams, direct stream SPENERGY to STDOUT and run a simulation that only consists of this ‘singlepoint’ chunk.</p>
<div class="highlight-python" id="index-82"><pre>chunk soluteenergy N</pre>
</div>
<p>Calculate the energy of solute N. This calculates the energy of solute N and outputs the components of this energy in great detail. This is useful for debugging a forcefield or for collecting average energy components that are more finely divided than those normally collected.</p>
<div class="highlight-python" id="index-83"><pre>chunk fakesim</pre>
</div>
<p>Performs one step of simulation, without doing anything other than adding the energies to the averages. This can be useful for debugging purposes.</p>
<div class="highlight-python" id="index-84"><pre>chunk retienergy 0.2</pre>
</div>
<p>The RETI free energy method requires the calculation of the energy at the neighbouring two <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows at the end of the simulation. This chunk will calculate the energy at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows 0.2 above and below the reference state, and will output the results to the RETI stream.</p>
<div class="highlight-python" id="index-85"><pre>chunk lambda 0.5</pre>
</div>
<p>Sets <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> to 0.5. Will calculate and return the change in energy associated with this change in <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. This is useful if you wish to perform a slow growth or fast growth free energy simulation. You could also use this in conjunction with the ‘averages print’ and ‘averages reset’ chunks to calculate the free energy of all windows across <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> within a single simulation. This is because the window widths are preserved by the change in <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>, thus if the <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> windows were 0.1 0.2 0.4 before the change, then they would be 0.4 0.5 0.7 after the change. Note that the values of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> are clamped between 0.0 and 1.0.</p>
<div class="highlight-python"><pre>chunk lambda 0.5 0.6 0.4</pre>
</div>
<p>As above, except set the <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> values of the forwards and backwards windows to 0.6 and 0.4 respectively.</p>
<div class="highlight-python"><pre>chunk lambda delta 0.1</pre>
</div>
<p>As above except instead of directly setting <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>, change <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> by 0.1. This will also increase the value of <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> for the for- wards and backwards windows by 0.1.</p>
<div class="highlight-python" id="index-86"><pre>chunk freeenergy 0.3 0.5</pre>
</div>
<p>Calculate quantities need for free energy estimators. This will calculate the derivative of the potential with respect to <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> as needed for thermodynamic integration, and energies at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> =0.3 and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> =0.5 as needed for Bennett Acceptance Ratio method. All of these energies will be printed to the INFO and ENERGY streams.</p>
<div class="highlight-python" id="index-87"><pre>chunk fixresidues 1 all</pre>
</div>
<p>Fix all of the residues of protein 1.</p>
<div class="highlight-python"><pre>chunk fixresidues 1 1-10 12 14 16-20</pre>
</div>
<p>Fix the residues of protein 1. Only fix residues 1 to 10, 12, 14 and 16 to 20.</p>
<div class="highlight-python"><pre>chunk fixresidues 1 none</pre>
</div>
<p>Unfix all of the residues of protein 1.</p>
<div class="highlight-python" id="index-88"><pre>chunk fixbackbone 1 all</pre>
</div>
<p>Fix the backbone of all residues of protein 1. This chunk has the same syntax as the fixresidues chunk.</p>
<div class="highlight-python"><pre>chunk fixbackbone 1 none 20-35</pre>
</div>
<p>Unfix all of the residues of protein 1, then fix the backbone of residues 20-35. This ensures that only the backbone of residues 20-35 is fixed.</p>
<div class="highlight-python"><pre>chunk12 transrot 1 0.0 0.0</pre>
</div>
<p>Set the translation and rotation displacements for solute 1 to zero. This overrides the values read in the template file. The first floating point number is the translation displacement and the second one is the rotation displacement and is optional. Can be useful for pure solvent and gas-phase calculations.</p>
<div class="highlight-python" id="index-89"><pre>setstream info=stdout move=off</pre>
</div>
<p>Direct the INFO stream to STDOUT and turn the MOVE stream off.</p>
<div class="highlight-python"><pre>setstream restart=myfile.txt warning=stderr</pre>
</div>
<p>Direct the RESTART stream to myfile.txt and the WARNING stream to STDERR. solvate]</p>
<div class="highlight-python" id="index-90"><pre>chunk solvent box xdim ydim zdim [xorig yorig zorig xmax ymax zmax]</pre>
</div>
<p>This command can be used to replicate a solvent file loaded as solvent1 such that the final solvent occupies a box of dimensions xdim ydim zdim with origin (0,0,0). Alternatively the origin can be specified along with the maximum coordinates of the cubix box. solvate2]</p>
<div class="highlight-python"><pre>chunk solvent cap xorig yorig zorig rad</pre>
</div>
<p>As before but the output will be a spherical cap of solvent centered at the specified origin and with a radius rad. The last two commands can be used to create large solvent boxes when needed. Once this chunk has been performed, you should save a pdb of the system using the chunk pdb and then edit the output file such that it can load as ProtoMS solvent pdb. The process of replicating the solvent molecules can be quite memory consuming and you may find you have to recompile ProtoMS so that it can handle a large number of solvent molecules, particularly if the coordinates of the system you want to solvate are far away from the coordinates of the solvent molecules in the input solvent box.</p>
</div>
</div>
<div class="section" id="setup-and-analysis-tools">
<h2>Setup and analysis tools<a class="headerlink" href="#setup-and-analysis-tools" title="Permalink to this headline">¶</a></h2>
<p>As there are many options that can be set in ProtoMS, we provide a range of setup tools that can be used to setup the most common type of simulations. The main tool is called <tt class="docutils literal"><span class="pre">protoms.py</span></tt> and is document in the next <a class="reference external" href="protomspy.html">chapter</a>. For more advanced use, one can use the individual setup tools as documented <a class="reference external" href="tools.html">here</a>.</p>
<p>In order to perform analysis of the ProtoMS simulations, there is a range of tools than be used. They are documented <a class="reference external" href="tools.html">here</a>.</p>
</div>
</div>
<div class="section" id="input-files">
<h1>Input Files<a class="headerlink" href="#input-files" title="Permalink to this headline">¶</a></h1>
<p>ProtoMS can read in five types of input file</p>
<ul class="simple">
<li><strong>Parameter / Forcefield file</strong> These provide the forcefield parameters used in a simulation, and the templates (z-matricies) that are used to specify the connectivity and flexibility of the simulated molecules.</li>
<li><strong>Protein file</strong> These are simple PDB format files that contain the coordinates of the protein chains to be simulated. Only one protein chain may be contained within each protein PDB file.</li>
<li><strong>Solute file</strong> These are simple PDB format files that contain the coordinates of the solutes to be simulated. Only one solute may be contained within each solute PDB file.</li>
<li><strong>Solvent file</strong> These are simple PDB format files that contain the coordinates of the solvent molecules to be simulated. Multiple solvent molecules may be contained within each solvent file.</li>
<li><strong>Restart file</strong> These are files used by ProtoMS to save and restore the coordinates of all of the molecules in the system.</li>
</ul>
<p>ProtoMS is insensitive to case, so you can mix upper case and lower case within these files without affecting how
they are read.</p>
<div class="section" id="parameter-forcefield-files">
<span id="parfil"></span><h2>Parameter / Forcefield Files<a class="headerlink" href="#parameter-forcefield-files" title="Permalink to this headline">¶</a></h2>
<p>The parameter file is the most powerful, and hence the most complicated of all of the input files read by ProtoMS. The parameter file provides all of the forcefield parameters that are used in a simulation, and it also provides all of the templates that provide the connectivity and z-matrices of all of the loaded molecules. The parameter file uses a word based format, meaning that you can leave as many spaces between words on a line as you like, and you do not have to worry about lining up data into particular columns.</p>
<p>The general format of a parameter file is shown below:</p>
<div class="highlight-python"><pre># comment lines start with a '#'

mode clj
#.... charge / Lennard Jones forcefield parameters

mode bond
#.... bond parameters

mode template
#.... templates

#parameter file uses a word-based format, so leave as many spaces as
#you want between words, e.g.
       mode            clj

mode bond   #comments can also go at the end of any lines, like this!

MoDe DiHeDrAl  # you can use whatever case you want (though try to make
               # things readable!</pre>
</div>
<p>How ProtoMS reads the parameter file is controlled by which <tt class="docutils literal"><span class="pre">mode</span></tt> the file has been set. There are several different modes, and as figure 3.5 shows, it is possible to change between modes within a single file. The different modes are</p>
<ul class="simple">
<li><strong>info</strong> This mode is used to read in control information for the forcefield.</li>
<li><strong>clj</strong> This mode is used to read in the charge and Lennard Jones (clj) parameters for the simulation.</li>
<li><strong>bond</strong> This mode is used to read in the bond parameters for the simulation.</li>
<li><strong>angle</strong> This mode is used to read in the angle parameters.</li>
<li><strong>ureybradley</strong> This mode is used to read in the Urey-Bradley parameters.</li>
<li><strong>dihedral</strong> This mode is used to read in the dihedral parameters.</li>
<li><strong>template</strong> This mode is used to read in the templates (z-matricies) used in the simulation. The template format is quite complex, so is described in the next section.</li>
</ul>
<p>ProtoMS will only read lines that are valid within the mode that is being read. If ProtoMS could not read a line, or finds an incorrectly formatted line, then ProtoMS will print a message to the WARNING stream and will skip that line. It is therefore very important that you check the WARNING stream if you are writing or modifying a parameter file. To help you, ProtoMS will write out detailed information about a loaded parameter file to the DETAIL stream. You should check this output to ensure that any changes you make to a parameter file are being
correctly loaded by ProtoMS.</p>
<p>ProtoMS can be asked to load as many forcefield files as you desire. Each parameter or template within the forcefield files has either a numerical or name based ID. If two forcefield files have parameters or templates that share the same ID, then ProtoMS will use the value that was read last. ProtoMS will of course warn you that it has overwritten an earlier parameter (by outputting a message to the WARNING stream) but this behaviour could still trip you up! To help you, all of the parameters that use numerical IDs in the forcefield files supplied with ProtoMS use IDs that are between 1 and 2999. You can thus use numerical IDs that are greater than or equal to 3000 without worrying about a clash.</p>
<p id="index-91"><strong>mode info</strong></p>
<p>This mode is used to read in control information for the forcefield. This information is used to set parameters that affect which functions are used to evaluate the forcefield, and to set the values of forcefield-global parameters. The following lines are valid within this mode</p>
<div class="highlight-python"><pre>ljcombine type</pre>
</div>
<p>where <em>type</em> can be <cite>arithmetic</cite> or <cite>geometric</cite>. This sets the combining rules used for the Lennard Jones <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> parameter to either the arithmetic mean (as used by AMBER), or the geometric mean (as used by OPLS). See equations <a href="#equation-arithmetriccomb">(3)</a> and <a href="#equation-geometriccomb">(4)</a> for the functional forms of these combining rules.</p>
<div class="highlight-python"><pre>scl14coul float</pre>
</div>
<p>This sets the 1-4 coulombic scaling factor, e.g. for OPLS the value should be 0.5 (see eq <a href="#equation-intrapot1">(9)</a>).</p>
<div class="highlight-python"><pre>scl14lj float</pre>
</div>
<p>This sets the 1-4 Lennard Jones scaling factor, e.g. for OPLS the value should be 0.5 (see eq <a href="#equation-intrapot1">(9)</a>).</p>
<p id="index-92"><strong>mode clj</strong></p>
<p>This mode is used to read in the charge and Lennard Jones (clj) parameters used by the simulation (see equations <a href="#equation-intermol1">(1)</a> and <a href="#equation-intrapot3">(11)</a>). Only one type of line is valid within this mode</p>
<div class="highlight-python"><pre>par id amber proton-number charge sigma epsilon</pre>
</div>
<p><em>id</em> is the unique identifying number for this clj parameter. This can be any number from 1 to MAXCLJ (by default this is 10000). If this ID is the same as an already read CLJ parameter, then ProtoMS will write a warning to the WARNING stream, and will overwrite the old CLJ parameter with the new parameter. To help prevent unintentional ID clashes, then the forcefields supplied with ProtoMS only use parameter IDs from 1 to 2000, and the solvent models supplied with ProtoMS use parameter IDs 2001 to 2999. You are thus free to use parameter IDs from 3000 in your own parameter files.</p>
<p><em>amber</em> is the AMBER atom type associated with this clj parameter. The AMBER atom type is a two letter code that is used to identify the atom for the purposes of assigning bond, angle, dihedral or Urey-Bradley parameters. If this is a parameter for a dummy or non-chemical parameter, then the AMBER atom type should be ‘??’. Note that the AMBER type is case sensitive. This is different to other parts of ProtoMS, and is required as the GAFF forcefield uses case to distinguish between different AMBER types.</p>
<p><em>proton-number</em> is the number of protons in the atom associated with this clj parameter, e.g. 1 for hydrogen, 6 for carbon or 8 for oxygen.</p>
<p><em>charge</em>, <em>sigma</em> and <em>epsilon</em> are the partial charge (in |e|), and Lennard Jones <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> (A) and <img class="math" src="_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/> (kcal mol-1 ) parameters associated with this clj parameter, e.g.</p>
<div class="highlight-python"><pre>par 2001 OW 8 -0.834 3.15061 0.1521 # TIP3P oxygen</pre>
</div>
<p>specifies the clj parameter for oxygen in TIP3P water, with parameter number 2001, AMBER atom type ‘OW’ proton number 8, a partial charge of -0.834 |e|, σ = 3.15061 A and ε = 0.1521 kcal mol-1 .</p>
<p>Parameter ID 0 is a special clj parameter used to represent a null atom. This null atom has charge, <img class="math" src="_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> and <img class="math" src="_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/> values of 0.0, an AMBER atom type of ‘DM’ and a proton number of 0.</p>
<p id="index-93"><strong>mode bond</strong></p>
<p>This mode is used to read in the bond parameters used by the simulation. Two types of line are valid within this mode</p>
<div class="highlight-python"><pre>par id force-constant bond-length</pre>
</div>
<p><tt class="docutils literal"><span class="pre">id</span></tt> is an identifying number from 1 to MAXBNDPARAM (default 5000) that is used to uniquely identify a bond. As in the case of the clj parameters, new parameters with the same ID number will overwrite old parameters with that ID number, and the parameter files supplied with ProtoMS will only use IDs from 1 to 2999, so you can safely use parameters 3000 and up.</p>
<p><tt class="docutils literal"><span class="pre">force-constant</span></tt> is the force constant (<img class="math" src="_images/math/2da9b480f4929b470c155bb7b1c926cb05a458db.png" alt="k_{bond}"/>, see eq <a href="#equation-bondpot">(5)</a>) for the bond parameter. The units of <img class="math" src="_images/math/2da9b480f4929b470c155bb7b1c926cb05a458db.png" alt="k_{bond}"/> are kcal mol-1 A-2 . <tt class="docutils literal"><span class="pre">bond-length</span></tt> is the equilibrium bond length (<img class="math" src="_images/math/630f232dcbff18b52c950e05ea525a8a119ff77b.png" alt="r_0"/> ), in units of A.</p>
<p>The second type of line valid in this mode is used to associate a pair of AMBER atom types with a bond parameter</p>
<div class="highlight-python"><pre>atm amb1 amb2 id</pre>
</div>
<p>This line specifies the bond between atoms with AMBER atom types <tt class="docutils literal"><span class="pre">amb1</span></tt> and <tt class="docutils literal"><span class="pre">amb2</span></tt> is assigned the parameters from bond ID <tt class="docutils literal"><span class="pre">id</span></tt>. Note that this bond parameter does not need to have been loaded when this line of the parameter file is being read, as bond parameters are not assigned until after all parameter files have been read. If none of the bond parameter files provide this bond ID, then ProtoMS will print a message to the WARNING stream and will set the bond ID to 0. As in the case of the clj parameters, 0 is a special parameter used to specify a null bond, whose bond parameters, and thus energy, are all 0.0. In addition, any bond involving an AMBER atom with a null clj parameter (i.e. having AMBER atom type ‘DM’) will be automatically set to use bond parameter 0. It is not possible to have a non-null bond parameter for bonds that involve dummy atoms.</p>
<p>These bond atm lines are indexed by the AMBER pair amber1-amber2. If this AMBER pair has already been loaded then its parameter is overwritten with the new parameter. Note that bonds are symmetrical, thus bond index amb1-amb2 is equal to amb2-amb1.</p>
<p id="index-94"><strong>mode angle</strong></p>
<p>This mode is used to read in the angle parameters used in the simulation and its format and behaviour is almost identical to that used in the bond mode. Again, only two types of line are valid within the angle mode</p>
<div class="highlight-python"><pre>par id force-constant angle-size</pre>
</div>
<p>and</p>
<div class="highlight-python"><pre>atm amb1 amb2 amb3 id</pre>
</div>
<p><tt class="docutils literal"><span class="pre">id</span></tt> is an indentifying number from 1 to MAXANGPARAM (default 5000) that is used to uniquely identify an angle parameters. <tt class="docutils literal"><span class="pre">force-constant</span></tt> is the force constant (<img class="math" src="_images/math/ea7b0ca11cd67679c638250e784c211e8124e120.png" alt="k_{angle}"/> , see eq <a href="#equation-angpot">(6)</a>) for the angle parameter, in units of kcal mol-1 degree-2 . <tt class="docutils literal"><span class="pre">angle-size</span></tt> is the equilibrium angle size (<img class="math" src="_images/math/62df86ba6c84c9e8a5008f0ad6bbefa5d9cf301f.png" alt="\theta_0"/>) in units of degrees. Angle ID 0 is the null angle, and the forcefield files supplied with ProtoMS will only use angle IDs from 1 to 2999.</p>
<p>The atm line is again very similar to that in the bond mode, with in this case the angle between atoms with AMBER types <tt class="docutils literal"><span class="pre">amb1-amb2-amb3</span></tt> being assigned angle parameter id. Angles are also symmetric, so <tt class="docutils literal"><span class="pre">amb1-amb2-amb3</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">amb3-amb2-amb1</span></tt>. Like the bond mode, any angle involving dummy atoms (AMBER type ‘DM’) will automatically be set to use the angle parameter 0. It is not possible to use a non-null angle parameter over an angle involving dummy atoms.</p>
<p id="index-95"><strong>mode ureybradley</strong></p>
<p>This mode is used to read in Urey-Bradley parameters (see eq <a href="#equation-ubpot">(7)</a>), and its format is identical to that of the angle mode. There are only two valid lines in this mode</p>
<div class="highlight-python"><pre>par id force-constant uby-size</pre>
</div>
<p>and</p>
<div class="highlight-python"><pre>atm amb1 amb2 amb3 id</pre>
</div>
<p>In this case force-constant refers to the Urey-Bradley force constant (<img class="math" src="_images/math/fd201fa83d1d0b4814a1a758c1f4a75a156bd7ed.png" alt="k_{uby}"/> ), in units of kcal mol-1 A -2 and <tt class="docutils literal"><span class="pre">uby-size</span></tt> refers to the equilibrium Urey-Bradley length (<img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/> ) in units of A. Everything else about this mode is identical to that of the bond mode.</p>
<p id="index-96"><strong>mode dihedral</strong></p>
<p>This mode is used to read in the dihedral parameters that are used in the simulation. There are three types of line that are value in this mode. The first of these is used to provide the parameters for a single dihedral cosine term :</p>
<blockquote>
term term-id k1 k2 k3 k4</blockquote>
<p><tt class="docutils literal"><span class="pre">term-id</span></tt> is an ID number from 1 to MAXDIHTERMS (default 5000) that uniquely identifies this dihedral cosine term. <tt class="docutils literal"><span class="pre">k1</span></tt> to <tt class="docutils literal"><span class="pre">k4</span></tt> are the values of the four constants (<img class="math" src="_images/math/7f2f57887b2e2f63a617b6a4b7a7d466c26c4342.png" alt="k_1"/> to <img class="math" src="_images/math/da4ccd7a2fe7fb7e9ba88a8a75c7a37f0b9867e6.png" alt="k_4"/> ) that control the dihedral cosine term (see eq <a href="#equation-dihepot">(8)</a>). <tt class="docutils literal"><span class="pre">k1</span></tt> has units of kcal mol-1 , <tt class="docutils literal"><span class="pre">k2</span></tt> and <tt class="docutils literal"><span class="pre">k3</span></tt> are dimensionless, and <tt class="docutils literal"><span class="pre">k4</span></tt> is in units of degrees.</p>
<p>A full dihedral parameter is composed from the sum of individual dihedral cosine terms. The second valid line in the dihedral mode specifies which terms are associated with which parameters, e.g</p>
<div class="highlight-python"><pre>par id 3 10 32</pre>
</div>
<p>specifies that dihedral parameter <tt class="docutils literal"><span class="pre">id</span></tt> is formed as the sum of dihedral cosine terms 3, 10 and 32. You may specify as many dihedral cosine terms on this line as you wish from 1 to MAXDIHTERMSPERDIHEDRAL (default 6). As in the bond, angle and ureybradley modes, <tt class="docutils literal"><span class="pre">id</span></tt> is a uniquely identifying number, in this case from 1 to MAXDIHPARAM (default 5000), with ID 0 referring to the special, null dihedral.</p>
<p>As in the case of the bond, angle and ureybradley modes, the AMBER atom set is used to associate dihedral parameters with actual dihedrals in a molecule. The final valid line associates the AMBER atom types of the four  atoms in the dihedral with the dihedral parameter ID, e.g</p>
<div class="highlight-python"><pre>atm amb1 amb2 amb3 amb4 id</pre>
</div>
<p>Because dihedrals are symmetrical, <tt class="docutils literal"><span class="pre">amb1-amb2-amb3-amb4</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">amb4-amb3-amb2-amb1</span></tt>.</p>
<p id="index-97"><strong>mode born</strong></p>
<p>This mode is used to read the Generalised Born parameters that are used in the simulation. A valid line is</p>
<div class="highlight-python"><pre>par id atype iborn scalefac</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">atype</span></tt> is an AMBER/GAFF atom type, <tt class="docutils literal"><span class="pre">iborn</span></tt> is an intrinsic born radius and scalefac a scaling factor for Pairwise Descreening Approximation calculations. These parameters have been optimised to be used with the AMBER or GAFF force fields.</p>
<p id="index-98"><strong>mode surface</strong></p>
<p>This mode is used to read surface area parameters that are used in the simulation. A valid line is</p>
<div class="highlight-python"><pre>par id atype radius surftens</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">atype</span></tt> is an AMBER/GAFF atom type, <tt class="docutils literal"><span class="pre">radius</span></tt> is the radius of the atom and <tt class="docutils literal"><span class="pre">surftens</span></tt> the surface tension of this atom type, which relates the solvent accessible surface area of this atom to a non polar energy. These parameters have been optimised to be used with the AMBER or GAFF force fields.</p>
</div>
<div class="section" id="templates">
<span id="temref"></span><h2>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h2>
<p>Templates are used to assign the z-matrix and forcefield parameters to loaded molecules. Templates are read in using the template mode of the parameter / forcefield file. Different types of template are used with the different types of molecules in ProtoMS</p>
<ul class="simple">
<li><strong>proteins</strong> The backbone of each protein residue is assigned via a chain template. The sidechain of each residue is assigned via a residue template.</li>
<li><strong>solutes</strong> Solutes are assigned via solute templates.</li>
<li><strong>solvents</strong> Solvents are assigned via solvent templates.</li>
<li><strong>GCsolutes</strong> GCsolutes are assigned via GCsolute templates.</li>
</ul>
<p><strong>Chain Templates</strong></p>
<p>Chain templates are used to assign the z-matrix and parameters of the backbone of protein residues. The start of a new chain template is indicated by the line</p>
<div class="highlight-python"><pre>chain name</pre>
</div>
<p>where name is the name of the chain template. This name uniquely identifies this chain template. If another chain template has been loaded with this name, then this chain template will overwrite it and a message will be output to the WARNING stream.</p>
<p>The valid lines that comprise a chain template are</p>
<div class="highlight-python"><pre>bbatom id nam par0 par1</pre>
</div>
<p>This line identifies which are the four bbatoms of the residue. <tt class="docutils literal"><span class="pre">id</span></tt> identifies which bbatom this atom is (from 1 to 4), <tt class="docutils literal"><span class="pre">nam</span></tt> gives the name of the atom (maximum of four characters), and <tt class="docutils literal"><span class="pre">par0</span></tt> and <tt class="docutils literal"><span class="pre">par1</span></tt> are the CLJ parameters for this atom at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0, and these must refer to a valid CLJ parameter (from 0 to MAXCLJ, default 10000). Note that CLJ parameter 0 is used to assign a dummy atom. The name of the atom is the same as that given in the PDB file for the protein, and is limited to a maximum of four characters. The atom name must uniquely identify the atom within the residue, so this name must not be used elsewhere within this chain template, or in any residue templates that connect to this chain template</p>
<div class="highlight-python"><pre>atom nam par0 par1 bndnam angnam dihnam</pre>
</div>
<p>This line identifies any extra atoms that are part of the backbone. <tt class="docutils literal"><span class="pre">nam</span></tt>, <tt class="docutils literal"><span class="pre">par0</span></tt> and <tt class="docutils literal"><span class="pre">par1</span></tt> have the same meanings as for the bbatom line. This is a z-matrix line, and <tt class="docutils literal"><span class="pre">bndnam</span></tt>, <tt class="docutils literal"><span class="pre">angnam</span></tt> and <tt class="docutils literal"><span class="pre">dihnam</span></tt> are the names of the atoms that are the reference from which the coordinates of this atom are generated (bond, angle and dihedral atoms). Note that this line does not state that there is a bond, angle or dihedral with these atoms. This line only says that these three atoms are used to construct this extra atom. Note that the atoms in a residue are built in sequence, so the bond, angle and dihedral atoms in this line must refer to atoms that were previously listed in the chain template.</p>
<div class="highlight-python"><pre>zmat nam bndval angval dihval</pre>
</div>
<p>This line provides the default values of the internal z-matrix coordinates for the atom called <tt class="docutils literal"><span class="pre">nam</span></tt>. <tt class="docutils literal"><span class="pre">bndval</span></tt>, <tt class="docutils literal"><span class="pre">angval</span></tt> and <tt class="docutils literal"><span class="pre">dihval</span></tt> are the default values of the bond length, angle size and dihedral size. This line is optional, and is only required if you either want ProtoMS to construct this atom if it is missing from the PDB file, or if you want ProtoMS to reset bond and angles to default values.</p>
<div class="highlight-python"><pre>bond nam1 nam2</pre>
</div>
<p>This line adds a bond between atoms name <tt class="docutils literal"><span class="pre">nam1</span></tt> and <tt class="docutils literal"><span class="pre">nam2</span></tt>. These two atom names must be present in the chain template. ProtoMS will not automatically add any bonds between atoms (except inter-residue bonds), so you must add all bonds that are present in the chain template. ProtoMS will use all of these explicitly added non-dummy bonds between atoms to generate all of the implicit angles and dihedrals within the backbone. Additional arguments may be present on this line to control the type of bond that is added, e.g.</p>
<div class="highlight-python"><pre>bond nam1 nam2 dummy</pre>
</div>
<p>adds a dummy bond between atoms <tt class="docutils literal"><span class="pre">nam1</span></tt> and <tt class="docutils literal"><span class="pre">nam2</span></tt>. A dummy bond is really a non-bond, as it has no energy, and its presence forces ProtoMS to treat atoms nam1 and nam2 as though they were not bonded together. You can make this bond flexible by adding the flex argument to the bond line, e.g.</p>
<div class="highlight-python"><pre>bond nam1 nam2 flex delta</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">delta</span></tt> is the maximum change in the bond length attempted in a Monte Carlo move in A. Note that you can only make degrees of freedom flexible if they are used in the construction of the z-matrix, i.e. atom <tt class="docutils literal"><span class="pre">nam1</span></tt> must be constructed via a bond with <tt class="docutils literal"><span class="pre">nam2</span></tt>, or <tt class="docutils literal"><span class="pre">nam2</span></tt> constructed from <tt class="docutils literal"><span class="pre">nam1</span></tt>.</p>
<p>The forcefield parameters for this bond will normally be assigned via the AMBER atom types of the constituent atoms. It is possible to override this assignment by explicitly assigning bond parameters, e.g.</p>
<div class="highlight-python"><pre>bond nam1 nam2 param par0 par1</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">par0</span></tt> and <tt class="docutils literal"><span class="pre">par1</span></tt> are the bond parameter IDs for this bond at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0. The bond parameter IDs must refer to valid bond parameters (0 to MAXBNDPARAM, default 5000), where parameter 0 is used to refer to a null bond. You can use parameter 0 to state that two atoms are bonded, but that the energy of the bond should not be evaluated, e.g.</p>
<div class="highlight-python"><pre>bond nam1 nam2 param 0 0</pre>
</div>
<p>Angles and Urey-Bradley terms and dihedrals in the chain template are specified almost identically as for the bond line, e.g.</p>
<div class="highlight-python"><pre>angle nam1 nam2 nam3</pre>
</div>
<p>adds an angle between atoms named <tt class="docutils literal"><span class="pre">nam1-nam2-nam3</span></tt>,</p>
<div class="highlight-python"><pre>ureybradley nam1 nam2 nam3</pre>
</div>
<p>adds a Urey-Bradley term between atoms named <tt class="docutils literal"><span class="pre">nam1-nam2-nam3</span></tt>, and</p>
<div class="highlight-python"><pre>dihedral nam1 nam2 nam3 nam4</pre>
</div>
<p>adds a dihedral between atoms named <tt class="docutils literal"><span class="pre">nam1-nam2-nam3-nam4</span></tt>. <tt class="docutils literal"><span class="pre">dummy</span></tt> and <tt class="docutils literal"><span class="pre">param</span></tt> options may be added to all of these lines, and <tt class="docutils literal"><span class="pre">flex</span></tt> may be added to the angle and dihedral lines (where delta is given in units of degrees).</p>
<p>ProtoMS uses the bonds specified in the template to work out where all of the implicit angles and dihedrals are in the backbone. You do not need to include implicit (additional) angles or dihedrals in the template file, and you can just the template to just the flexible angles and dihedrals. However there are some cases where you would not wish an implicit angle or dihedral to be evaluated, for example the dihedral energy may only need to be evaluated via one of the dihedrals around a bond, and not via any additional dihedrals. If this is the case then you will need to add those additional dihedrals to the template and use the dummy keyword to specify that these are dummy dihedrals and that their energy should not be evaluated.</p>
<p>It is not possible to add multiple bonds between the same pair of atoms, or multiple angles to the same triplet of atoms etc. ProtoMS will only use the first definition of a bond, angle, dihedral or Urey-Bradley term and will ignore any further attempts to set them.</p>
<p>As an example, the chain template for an amino acid backbone in the middle of a chain is as follows</p>
<div class="highlight-python"><pre>#
#       --  HN      O  --
#        |   |      |  |
#   res-1| --N--CA--C--|res+1
#        |       |     |
#       --       X     --
#
mode template
chain aacenter
bbatom 1  N  3  3
bbatom 2  CA 6  6
bbatom 3  C  1  1
bbatom 4  O  2  2
atom  HN 4 4  N  CA  C
zmat  HN 1.010 119.8 180.0
bond  O  C
bond  C  CA
bond  CA N
bond  HN N
angle HN N CA flex 3.0
dihedral HN N CA C flex 3.0
# Now the parameters
mode clj
par 3 N  7 -0.570 3.250 0.170 # N, sp2 N in amide
par 6 CH 6  0.200 3.800 0.080 # CA, sp3 C with 1 H
par 1 C  6  0.500 3.750 0.105 # C, carbonyl C
par 2 O  8 -0.500 2.960 0.210 # O, carbonyl O
par 4 H  1  0.370 0.000 0.000 # HN, amide hydrogen</pre>
</div>
<p>This shows that it can be convienient to combine the chain template with the CLJ parameters for the template into a single parameter file.</p>
<p><strong>Residue Templates</strong></p>
<p>Residue templates are used to assign the z-matrix and forcefield parameters for the sidechains of protein residues. The format of a residue templates is almost identical to that of a chain template.</p>
<p>As an example, here is the residue template for OPLS united atom alanine</p>
<div class="highlight-python"><pre># ALANINE
#
#     N-CA-C
#        |
#       CB
#
mode template
residue ALA
info rotate 0.5 translate 1.0
backbone first aanterm middle aacenter last aacterm single aasingle
atom  CB  7 7 CA N C
zmat  CB  1.525 111.1 -120.0
bond  CB CA
angle CB CA N flex 0.5
#parameters
mode clj
par 7 C3 6  0.000 3.910 0.160 # CB, sp3 with 3 H</pre>
</div>
<p>The start of a new residue template is signalled by the line</p>
<div class="highlight-python"><pre>residue name</pre>
</div>
<p>where name is the name of the residue template. This name uniquely identifies the template and because residues locate templates via the residue name, the residue template name is limited to a maximum of four characters. The lines that comprise a residue template are</p>
<div class="highlight-python"><pre>info rotate rotdel translate trandel</pre>
</div>
<p>This line provides information about the residue template. The option <tt class="docutils literal"><span class="pre">rotate</span></tt> <tt class="docutils literal"><span class="pre">rotdel</span></tt> specifies that the backbone rotation move would rotate the backbone by a maximum of <tt class="docutils literal"><span class="pre">rotdel</span></tt> degrees. The option translate <tt class="docutils literal"><span class="pre">trandel</span></tt> specifies that the backbone translation move would translate the backbone by a maximum of <tt class="docutils literal"><span class="pre">trandel</span></tt> A. Both of these options are optional, and may appear in any order on this line. If these options are not given, then the default translation and rotation values are both 0.0.</p>
<div class="highlight-python"><pre>backbone position chain</pre>
</div>
<p>This line states which chain templates are associated with this residue template for different positions of the residue within the protein, e.g.</p>
<div class="highlight-python"><pre>backbone first aanterm middle aacenter last aacterm single aasingle</pre>
</div>
<p>states that this residue template uses the chain template called <tt class="docutils literal"><span class="pre">aanterm</span></tt> if this was the first residue in the protein, <tt class="docutils literal"><span class="pre">aacenter</span></tt> if this residue was in the middle of the protein, <tt class="docutils literal"><span class="pre">aacterm</span></tt> if this was the last residue in the protein, and <tt class="docutils literal"><span class="pre">aasingle</span></tt> if this was the only residue in the protein. You can place as many positions on this line as you wish, with possible positions being first, middle, last and single. You do not need to specify a chain template for every one of these positions, but ProtoMS will print a message to the WARNING stream if it needs a position that has not been specified.</p>
<p>The remaining lines in the residue template are the <tt class="docutils literal"><span class="pre">atom</span></tt>, <tt class="docutils literal"><span class="pre">zmat</span></tt>, <tt class="docutils literal"><span class="pre">bond</span></tt>, <tt class="docutils literal"><span class="pre">angle</span></tt>, <tt class="docutils literal"><span class="pre">ureybradley</span></tt> and <tt class="docutils literal"><span class="pre">dihedral</span></tt> lines, which have exactly the same meaning and formats as those in the chain template lines. Note that the names of atoms in the residue template must be different to those in any of its associated chain templates. Also note that you can (and indeed will have to!) refer to atoms that are present in the associated chain templates. In the example in above you can see that the only atom in the residue template is the united-atom ‘CB’, and that this is built from the ‘CA’, ‘N’ and ‘C’ atoms of its associated chain templates. This means that all of the chain templates associated with this residue template must include atoms named ‘CA’, ‘N’ and ‘C’. If these atoms don’t exist then ProtoMS will print many messages to the WARNING stream, and the simulation will fail.</p>
<p>ProtoMS will use the non-dummy bonds present in the residue template to find all of the implicit (additional) angles and dihedrals. If one of the bonds connect the sidechain to the backbone (one of the bonds should!), then the implicit angles and dihedrals between the sidechain and backbone will also be found. If you do not want the energy of these implicit angles and dihedrals to be evaluated then you need to specify them in the residue template with the <tt class="docutils literal"><span class="pre">dummy</span></tt> option set.</p>
<p>It is possible for a residue template to contain no atoms! While this may sound strange, it is necessary for residues such as glycine in united atom forcefields, or for some terminating residues (e.g. methylamine). The following example is the residue template for OPLS united atom glycine</p>
<div class="highlight-python"><pre># GLYCINE - this consists only of the glycine backbones
#
#    --C--CA--N--
#
mode template
residue GLY
info rotate 0.5 translate 1.0
backbone first glynterm middle glycenter last glycterm single glysingle
# glycine has no atoms, or internals!</pre>
</div>
<p><strong>Solute templates</strong></p>
<p>Solute templates are used to assign the z-matrix and forcefield parameters to solute molecules. An example solute template for a united atom biphenyl is shown blelow</p>
<div class="highlight-python"><pre>mode template   # make sure that the parameter file is being read in
                # in template mode

#                 |
#     CH3--CH2    |     CH2--CH3        Biphenyl, built as two residues,
#    /        \   |    /        \             PH1 and PH2
#  CH4        CH1-|-CH1         CH4
#    \        /   |    \        /        Note that each atom in a residue
#     CH5--CH6    |     CH6--CH5         must have a unique name but
#  PH1            |              PH2     that atoms in different residues
#                                        may have the same name
solute biphenyl
info translate 1.0 rotate 5.0

# Atoms in the first, PH1 residue
#
atom CH1 PH1  20 20  DM3 DUM  DM2 DUM  DM1 DUM  # First three atoms are built
atom CH2 PH1  20 20  CH1 PH1  DM3 DUM  DM2 DUM  # from the auto-generated
atom CH3 PH1  20 20  CH2 PH1  CH1 PH1  DM3 DUM  # dummy atoms (DM1-DM2-DM3)
atom CH4 PH1  20 20  CH3 PH1  CH2 PH1  CH1 PH1
atom CH5 PH1  20 20  CH4 PH1  CH3 PH1  CH2 PH1
atom CH6 PH1  20 20  CH5 PH1  CH4 PH1  CH3 PH1

# Atoms in the second, PH2 residue
#
atom CH1 PH2  20 20  CH1 PH1  CH2 PH1  CH3 PH1
atom CH2 PH2  20 20  CH1 PH2  CH1 PH1  CH2 PH1
atom CH3 PH2  20 20  CH2 PH2  CH1 PH2  CH1 PH1
atom CH4 PH2  20 20  CH3 PH2  CH2 PH2  CH1 PH2
atom CH5 PH2  20 20  CH4 PH2  CH3 PH2  CH2 PH2
atom CH6 PH2  20 20  CH5 PH2  CH4 PH2  CH3 PH2
# Bonds between atoms - residue PH1
bond CH1 PH1  CH2 PH1
bond CH2 PH1  CH3 PH1
bond CH3 PH1  CH4 PH1
bond CH4 PH1  CH5 PH1
bond CH5 PH1  CH6 PH1
bond CH6 PH1  CH1 PH1
# interconnecting bond
bond CH1 PH1  CH1 PH2
# bonds in residue PH2
bond CH1 PH2  CH2 PH2
bond CH2 PH2  CH3 PH2
bond CH3 PH2  CH4 PH2
bond CH4 PH2  CH5 PH2
bond CH5 PH2  CH6 PH2
bond CH6 PH2  CH1 PH2

# only one flexible dihedral - interconnecting dihedral
dihedral CH2 PH2  CH1 PH2  CH1 PH1  CH2 PH1  flex 5.0</pre>
</div>
<p>The format for a solute template is very similar to that of a residue template. The main difference is that while residue atoms are uniquely identified by thier atom name, solute atoms are uniquely identified by the combined atom name and residue name, e.g. the biphenyl atom CH2 PH2 is a different atom to CH2 PH1.</p>
<p>A new solute template is started with the line</p>
<div class="highlight-python"><pre>solute name</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">name</span></tt> is the uniquely identifying name of the solute template. As with the other templates, if a solute template with this name already exists, then it is overwritten by the new template. The name of the solute template can be any length up to 300 characters that can include spaces. Valid solute names thus include ‘biphenyl’ and ‘test ligand 132B’ Note that ProtoMS is insensitive to case, so it doesn’t matter how you capitalise the solute name as ProtoMS will ignore it. The solute names ‘biphenyl’, ‘BIPHENYL’ and ‘BiPhenyl’ are all equivalent. ProtoMS will also strip the spaces before and after the solute name, and will replace multiple spaces within the name with single spaces, e.g. ‘ test ligand 132B ’ is equivalent to ‘test ligand 132B’.</p>
<p>The format and meaning of the valid lines in a solute template file are very similar to those of a residue and chain template. The line</p>
<div class="highlight-python"><pre>info rotate rotdel translate trandel</pre>
</div>
<p>has exactly the same format for a solute template as it does for a residue template, and the meaning is very similar. In this case this line sets the maximum amounts that the solute molecule as a whole will be rotated and translated by, in units of A and degrees respectively. This line is optional, and it is not present then the default maximum rotation and translation amounts are both zero. Note that translation and rotation of a solute is about the location of the first automatically added dummy atom at the center of geometry of the solute.</p>
<div class="highlight-python"><pre>atom nam res par0 par1 bnd bndres ang angres dih dihres</pre>
</div>
<p>This line has a very similar meaning to the atom line of the residue and chain templates. In this case, this line identifies the solute atom called <tt class="docutils literal"><span class="pre">nam</span></tt>, in residue named <tt class="docutils literal"><span class="pre">res</span></tt>, and assigns it the CLJ parameters <tt class="docutils literal"><span class="pre">par0</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and <tt class="docutils literal"><span class="pre">par1</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0. The bond, angle and dihedral z-matrix atoms that are used to build this atom are the atom named <tt class="docutils literal"><span class="pre">bnd</span></tt> in residue <tt class="docutils literal"><span class="pre">bndres</span></tt>, the atom named <tt class="docutils literal"><span class="pre">ang</span></tt> in residue <tt class="docutils literal"><span class="pre">angres</span></tt> and the atom named <tt class="docutils literal"><span class="pre">dih</span></tt> in residue <tt class="docutils literal"><span class="pre">dihres</span></tt>. These z-matrix atoms must have appeared in the solute template before this atom. Note that this line does not add a bond, angle or dihedral between any of these atoms. The atom lines only specify how to move and construct the solute, not how to evaluate its energy.</p>
<div class="highlight-python"><pre>bond nam1 res1 nam2 res2</pre>
</div>
<p>This line adds a bond between solute atoms <tt class="docutils literal"><span class="pre">nam1</span></tt> in residue <tt class="docutils literal"><span class="pre">res1</span></tt> and <tt class="docutils literal"><span class="pre">nam2</span></tt> in residue <tt class="docutils literal"><span class="pre">res2</span></tt>. You can make this bond flexible by using the <tt class="docutils literal"><span class="pre">flex</span></tt> keyword in the same way as described for the chain and residue templates (as long as this bond is used in one of the atom z-matrix lines to construct one of the atoms). You can also use the same <tt class="docutils literal"><span class="pre">dummy</span></tt> keyword as the chain and residue templates to turn this into a dummy bond. As in those cases, a dummy bond is a non-bond, and has the effect of stating that the two atoms are not bonded together. The forcefield parameters for this bond are obtained via the AMBER types of the two solute atoms. However these parameters may be overridden through the use of the param keyword as used in the chain and residue templates, e.g.</p>
<div class="highlight-python"><pre>bond nam1 res1 nam2 res2 param par0 par1</pre>
</div>
<p>This line states that this bond uses bond parameter <tt class="docutils literal"><span class="pre">par0</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and bond parameter <tt class="docutils literal"><span class="pre">par1</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0. The angles, Urey Bradley terms and dihedrals in the solute are specified in a very similar manner</p>
<div class="highlight-python"><pre>angle nam1 res1 nam2 res2 nam3 res3

ureybradley nam1 res1 nam2 res2 nam3 res3

dihedral nam1 res1 nam2 res2 nam3 res3 nam4 res4</pre>
</div>
<p>the <tt class="docutils literal"><span class="pre">dummy</span></tt>, <tt class="docutils literal"><span class="pre">flex</span></tt> and <tt class="docutils literal"><span class="pre">param</span></tt> options may be used with these lines, with the exception of the <tt class="docutils literal"><span class="pre">ureybradley</span></tt> line, which cannot use the <tt class="docutils literal"><span class="pre">flex</span></tt> option. ProtoMS only uses the bonds listed in the solute template to work out which atoms are bonded together. ProtoMS does not try to guess which atoms are bonded together, so you will need to add all bonds that exist in the solute to the template file to ensure that the intramolecular energy is calculated correctly. ProtoMS will use these explicitly added, non-dummy bonds to work out all of the implicit (additional) angles and dihedrals in the solute. You do not need to include any additional angles or dihedrals in the solute template as they are added automatically by ProtoMS. If you do not want the energy of an additional angle or dihedral to be evaluated then you will need to add it to the template with the dummy option set. This is the same behaviour as in the chain and
residue templates.</p>
<p>Solute templates have one extra type of valid line compared to chain or residue templates. This line is used to describe how the geometry of the solute changes with <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/></p>
<div class="highlight-python"><pre>variable nam res type val0 val1</pre>
</div>
<p><tt class="docutils literal"><span class="pre">nam</span></tt> and <tt class="docutils literal"><span class="pre">res</span></tt> are the name and residue of the atom that changes geometry with <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. <tt class="docutils literal"><span class="pre">typ</span></tt> can be either <em>bond</em>, <em>angle</em> or <em>dihedral</em> and describes whether the bond, angle or dihedral changes with <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>, with <tt class="docutils literal"><span class="pre">val0</span></tt> giving its value at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and <tt class="docutils literal"><span class="pre">val1</span></tt> giving its value at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0. These variable geometry lines are very useful for free energy calculations where an atom is being ‘switched off’ by turning it into a dummy atom. You can use the variable geometry line to shrink the bond length to its z-matrix bonded atom, thus having the effect of pulling it within the van der waals sphere of the bonded atom. This prevents instabilities that may arise when the atom is close to being fully switched off.</p>
<p>Another use for variable geometry lines is to perform free energy calculations along structural coordinates, e.g. pulling two molecules apart. You can perform these sorts of calculations in ProtoMS by loading both molecules as a single solute, with no bonds between the two molecules. You could then use a variable geometry line to change the distance between the two molecules with respect to <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>.</p>
<p>Yet another use of geometry variation is to calculate the energy along an internal degree of freedom, e.g. by performing a torsion drive for the purposes of generating a dihedral forcefield parameter.</p>
<p>While <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> may be used to change the forcefield parameters of any atom of any molecule in the entire system, only solutes may have their geometry changed with respect to <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>. This is because geometry variations are implemented by making two copies of the solute and using these to shadow the original, reference solute. While you will not see these shadow solutes, they will reduce the number of solutes that you can load by two for every solute of variable geometry that you load. This means that while you can load a maximum of 50 solutes, you can only load a maximum of 16 solutes that have variable geometry.</p>
<p><strong>Solvent Templates</strong></p>
<p>Solvent molecules are implemented as rigid molecules in ProtoMS, so they do not require a z-matrix, nor do they have any internal degrees of freedom or energy terms. Solvent templates are thus much more simple than chain, residue and solute templates as they are only used to assign the forcefield parameters of the solvent molecules. An example solvent template for TIP4P water is shown in below</p>
<div class="highlight-python"><pre>#
# TIP4P (T4P)
#
#     O00       dist(OH) = 0.9572 A
#   /  |  \     dist(OM) = 0.15 A
# H01 M03 H02   ang(HOH) = 104.52 deg
#

mode clj
par 2003  OW  8  0.000  3.15363  0.1550
par 2004  HW  1  0.520  0.0      0.0
par 2005  ??  0 -1.040  0.0      0.0

mode template
solvent T4P
info translate 0.15 rotate 15.0
atom O00 2003 2003
atom H01 2004 2004
atom H02 2005 2005
atom M03 2006 2006</pre>
</div>
<p>A new solvent template is signified by the line</p>
<div class="highlight-python"><pre>solvent name</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">name</span></tt> is the uniquely identifying name of the solvent template. As in the cases of the other templates, if a solvent template with this name has been previously loaded, then it is overwritten. Solvent molecules are named using the residue name column from the PDB file, so the solvent name is limited to four characters. There are only two types of line that are valid within a solvent template. These are an info line, that has the same meaning as that in the solute templates, and</p>
<div class="highlight-python"><pre>atom nam par0 par1</pre>
</div>
<p>which states that the solvent atom called <tt class="docutils literal"><span class="pre">nam</span></tt> has CLJ parameters <tt class="docutils literal"><span class="pre">par0</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 0.0 and <tt class="docutils literal"><span class="pre">par1</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0. The file <em>solvents.ff</em> in the <em>parameter</em> directory contains the solvent templates for a large number of standard solvents. All of the CLJ parameters used in this file range from 2001 to 2999.</p>
<p><strong>GCsolute Templates</strong></p>
<p>GCsolute molecules are implemented as rigid molecules in ProtoMS, like solvents, so they do not require a z-matrix, nor do they have any internal degrees of freedom or energy terms. GCsolutes templates are thus much more simple than chain, residue and solute templates as they are only used to assign the forcefield parameters of the GCsolute molecules. An example GCsolute template for TIP4Pg water is shown below</p>
<div class="highlight-python"><pre>mode template
grand WAT
info translate 0.15 rotate 15
atom   O00  8003 8003
atom   H01  8004 8004
atom   H02  8004 8004
atom   M03  8005 8005
mode clj
#parameter atm proton-num charge(|e|) sigma(A) epsilon(kcal mol-1)
par  8003   OW    8    0.000      3.15363    0.1550
par  8004   HW    1    0.520      0.0        0.0
par  8005   ??    0   -1.040      0.0        0.0</pre>
</div>
<p>A new GCsolute template is signified by the line</p>
<div class="highlight-python"><pre>grand name</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">name</span></tt> is the uniquely identifying name of the GCsolute template. As in the cases of the other templates, if a GCsolute template with this name has been previously loaded, then it is overwritten. GCsolute molecules are named using the residue name column from the PDB file, so the name is limited to four characters. There are only two types of line that are valid within a GCsolute template. These are an info line, that has the same meaning as that in the solute templates, and :</p>
<blockquote>
atom nam par0 par1</blockquote>
<p>which states that the GCsolute atom called <tt class="docutils literal"><span class="pre">nam</span></tt> has CLJ parameters <tt class="docutils literal"><span class="pre">par0</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>  = 0.0 and <tt class="docutils literal"><span class="pre">par1</span></tt> at <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> = 1.0. GCsolute templates should have values of CLJ parameters used in the files ranging from 8001 to 8999.</p>
</div>
<div class="section" id="protein-file">
<span id="protpdb"></span><h2>Protein File<a class="headerlink" href="#protein-file" title="Permalink to this headline">¶</a></h2>
<p>Proteins are loaded from protein files. The names of the protein files are specified using the proteinN command described in section <a class="reference internal" href="#incmd"><em>Specifying input files</em></a>. The protein file is just a standard PDB format file. The name of the protein contained within this file is taken from the HEADER line of the PDB. e.g.:</p>
<div class="highlight-python"><pre>HEADER p38 kinase</pre>
</div>
<p>The protein name may contain spaces, though ProtoMS will strip any spaces before or after the name, and will collapse multiple spaces into a single space (much like it does with the solute name).</p>
<p>ProtoMS tries to follow the PDB format when it reads in PDB lines (see <a class="reference external" href="http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2">http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2</a> frame.html). Atom names and coordinates are given on lines that start with ATOM or HETATM. As with the rest of ProtoMS, the capitalisation of these keywords is not important. Unlike the rest of ProtoMS, these lines have a strict format with respect to in which column each piece of data is recorded.</p>
<p>ProtoMS constructs the protein chain from the residue order that it reads in from the PDB file. This means that if a protein file contains residues numbered 5, 10 and 2, in that order, then ProtoMS will construct a protein chain with the sequence 5-10-2. ProtoMS will not try to be clever and numerically order your residues for you! One requirement when loading a protein PDB is that all atoms that are part of a residue are together within the PDB file. It is not possible to scatter atoms from one residue throughout the entire PDB file. In addition, all residues in the protein must have a unique residue number, and all atoms within the same residue must have unique names. ProtoMS loads the protein and assigns residue templates based on the residue names that it finds in the PDB filele. If ProtoMS cannot find a residue template that matches the residue name then it prints a message to the WARNING stream and then skips the residue. ProtoMS will use the residue and chain templates that it finds to work out which atom names should be present in the residue. If the PDB file provides an atom that matches the atom name, then ProtoMS assigns that atom from the template. If the PDB file does not provide an atom that matches the name, then if the atom name corresponds to one of the required bbatoms, then ProtoMS will print a severe message to the WARNING stream and will then skip the residue. If the missing atom is not a bbatom, then if the residue or chain templates provide zmat information for that atom then the coordinates for the atom are constructed automatically (and a message output to the WARNING stream). If no zmat information is available for this atom, then it is skipped and a severe message is output to the WARNING stream. Finally, if the PDB file provides an atom that is not part of the template, then that atom is skipped.</p>
<p>ProtoMS can only read a single protein chain from a PDB file. This means that you must split multi-chain PDB files into several files, and that PDBs using the ‘A’ or ‘B’ chain notation will be read incorrectly. If ProtoMS reads TER line, then it will print a message to the WARNING stream, and will then skip the rest of the PDB file. ProtoMS is capable of reading a wide variety of PDB files, and of fixing many of the errors that it encounters. Despite this, I would recommend that you do not just use a PDB direct from the databank, but that you first preprocess the PDB with another software package to ensure that the PDB is correct, and that polar hydrogens and titratable residues are included correctly.</p>
</div>
<div class="section" id="solute-file">
<span id="solpdb"></span><h2>Solute File<a class="headerlink" href="#solute-file" title="Permalink to this headline">¶</a></h2>
<p>Solute input files are very similar to protein input files. Solute files are standard PDB format coordinate files. The name of the solute is read from the HEADER line in an identical manner to the name of a protein, e.g.:</p>
<div class="highlight-python"><pre>header biphenyl</pre>
</div>
<p>The solute name is used to locate the solute template, which is used to assign the z-matrix and forcefield parameters of the solute.</p>
<p>The solute PDB file has the same format as a standard PDB, with the requirements that all atoms belonging to a residue are together in the PDB, that each residue name is unique, and that all atom names within a residue are unique.</p>
<p>As is the case for protein files, ProtoMS will only read a single solute from each solute PDB file, and will skip the rest of the solute PDB if it encounters a TER line. It is intended that a future version of ProtoMS will remove this restriction.</p>
<p>ProtoMS will use the solute name to find the solute template for this molecule, and will then try to locate each atom from the template within the PDB file. If the atom does not exist then ProtoMS can automatically build the missing atom as long as its zmat information has been provided. If ProtoMS cannot build the atom then it skips it, after writing severe messages to the WARNING stream. If the PDB contains atoms that are not listed in the template then these atoms are ignored.</p>
</div>
<div class="section" id="gcsolute-file">
<span id="gcpdb"></span><h2>GCsolute File<a class="headerlink" href="#gcsolute-file" title="Permalink to this headline">¶</a></h2>
<p>GCsolute input files are very similar to protein input files, except that multiple GCsolutes can be loaded at once. GCsolute files are standard PDB format coordinate files. The name of each solvent molecule is taken from the residue name, and it is this name that is used to locate the template for each GCsolute molecule.</p>
</div>
<div class="section" id="solvent-file">
<span id="solventpdb"></span><h2>Solvent File<a class="headerlink" href="#solvent-file" title="Permalink to this headline">¶</a></h2>
<p>Solvent input files are very similar to protein and solute input files. Solvent files are standard PDB format coordinate files. Unlike the protein and solute files, many solvent molecules may be contained within each solvent input file. The name of each solvent molecule is taken from the residue name, and it is this name that is used to locate the template for each solvent molecule. ProtoMS will then try to locate each atom from the template within the PDB file. If the atom cannot be found then ProtoMS will write a severe message to the WARNING stream and will skip that atom. If the PDB contains atoms that are not part of the template then they are skipped. Note that ProtoMS will take the coordinates of the solvent molecule from the PDB file and will make no attempt to ensure that the internal geometry of the solvent molecule is correct for the template model (e.g. that
TIP4P water has an O-H bond length of 0.9572 A).</p>
<p>If multiple solvent files are loaded, then the solvents from the newer files are appended onto the list of solvents loaded from the previous file. If solvent file 1 contains 340 solvent molecules, and solvent file 2 contains 10 solvent molecules, then the solvents from file 1 will be loaded as solvent molecules 1-340, and those from solvent file 2 will be loaded as solvent molecules 341-350.</p>
<p><strong>Boundary conditions</strong></p>
<p>As well as containing the coordinates of the solvent molecules, the solvent file may be used to specify the parameters needed for the boundary conditions. To do this, the solvent file must include a HEADER line that has one of the following formats</p>
<div class="highlight-python"><pre>HEADER box dimx dimy dimz</pre>
</div>
<p>This states that the solvent file contains a box of solvent of dimensions <cite>dimx</cite> A by <cite>dimy</cite> A by <cite>dimz</cite> A, with the box centered on the origin. Note that ProtoMS will not check to see if this information is correct, so you will need to ensure that that no solvent molecules lie outside of this box.</p>
<div class="highlight-python"><pre>HEADER box ox oy oz tx ty tz</pre>
</div>
<p>This states that the solvent file contains a box of solvent with the bottom-left-back corner located at coordinates (<cite>ox</cite>,`oy`,`oz`) A and the top-right-front corner located at coordinates (<cite>tx</cite>,`ty`,`tz`) A. Again ProtoMS will not check that this information is accurate!</p>
<div class="highlight-python"><pre>HEADER cap ox oy oz rad k</pre>
</div>
<p>This states that the solvent file contains solvent molecules restrained to be within a spherical cap of <cite>radius</cite> rad A, centered at coordinates (<cite>ox</cite>,`oy`,`oz`) A, using a half-harmonic force constant of k kcal mol-1 A -2 . ProtoMS will not check to see whether or not this information is accurate.</p>
<p>Only one HEADER line may be included in each solvent file. How ProtoMS interprets these HEADER lines depends on which boundary conditions had been set for the simulation.</p>
<ol class="arabic simple">
<li>If no boundaries had been set for the simulation, then any information in the solvent files is ignored.</li>
<li>If a solvent cap had been set for the simulation, then any information in the solvent files is ignored and the solvent cap parameters are taken from the simulation parameter.</li>
<li>If a solvent box had been set then the solvent box dimensions are initially taken from the simulation parameter. However if any of the loaded solvent files specify the solvent box size then the solvent box dimensions are increased to encompass both the initial dimensions and the solvent box dimensions.</li>
</ol>
<p>4. If ‘solvent’ boundaries had been set for the simulation then the boundaries used will be those obtained from the first solvent file that is loaded that contains a HEADER line. If none of the loaded solvent files contain a HEADER line then a warning is printed and no boundary conditions are used. Note that by default ‘solvent’ boundaries are set for all simulations.
Warnings are printed if solvent files contain conflicting boundary types (e.g. specifying a box when a spherical solvent cap is used), or if multiple solvent files supply solvent cap parameters. If multiple solvent files supply solvent box dimensions then the box is increased to the minimum size necessary to encompass all of the solvent boxes.</p>
<p>To make things simple, I recommend that you use one solvent file to describe your boundary conditions, and use the default option of specifying solvent boundaries via the solvent file (use <tt class="docutils literal"><span class="pre">boundary</span> <span class="pre">solvent</span></tt> in your command file, or do not supply a <tt class="docutils literal"><span class="pre">boundary</span></tt> value as <tt class="docutils literal"><span class="pre">solvent</span></tt> is the default).</p>
<p>ProtoMS will print out the boundary dimension to any output PDB file if that file contains solvent molecules.</p>
</div>
<div class="section" id="restart-file">
<h2>Restart File<a class="headerlink" href="#restart-file" title="Permalink to this headline">¶</a></h2>
<p>The restart file is used to save the coordinates of the entire system to a high precision such that they can be loaded up at a future point, or by another ProtoMS simulation. The format of the restart file is not yet fixed, so unfortunately there is the possibility that different versions of ProtoMS may not be able to read each other’s restart files. This is considered a bug, and it is a development aim to stabilise the restart file format.</p>
<p>The restart file has deliberately been written as a human-readable text file. This means that the restart file is larger than it could be, but that it should be possible to manually edit a restart file, and understand its contents. If you wish to save space then I recommend that you compress the restart file via bzip2 or gzip. While the
restart file is human-readable and editable, I recommend that you do not attempt to change the restart file unless you have a good understanding of the writerestart.F and readrestart.F source files that are used by ProtoMS to read and write them.</p>
<p>The restart file only contains the coordinates of the entire system and the parameters needed for the boundary conditions. This file does not contain energies or energy averages, as these are output via the RESULTS stream. The restart file does not contain information about the connectivity or setup of the system as these are contained in the command file and the protein, solute, solvent and parameter files.</p>
<p>You can write a restart file at any point during your simulation, and you can write as many restart files as you wish. This means that you can start your simulation with a bit of equilibration, and write a restart file for the final equilibrated configuration, and then run some production. This is a strategy used by many of the examples in the next chapter.</p>
<p>You can read a restart file at any point during your simulation, and you can read restart files as many times as you desire during a simulation. A restart file merely resets the coordinates of the system to those saved when the restart file was written. This means that you could run multiple chunks of a simulation from the same equilibrated configuration by reading in a restart file from the equilibrated configuration before performing each chunk of production. Note that you can only read a restart file into the same system that was used to write that restart file. If you try to load an incompatible restart file then the program will print lots of warnings and will probably close down!</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="protomspy.html" title="protoms.py"
             >next</a> |</li>
        <li class="right" >
          <a href="compilation.html" title="Compilation and Installation"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2015, C. J. Woods, J Michel, M. Bodnarchuk, S. Genheden, R. Bradshaw, G. Ross, C. Cave-Ayland, A. I. Cabedo Martinez, J. Graham.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.6.
    </div>
  </body>
</html>