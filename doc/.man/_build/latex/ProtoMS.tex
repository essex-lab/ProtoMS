%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{ProtoMS Documentation}
\date{Jul 31, 2018}
\release{3.4}
\author{C. J. Woods, \and J. Michel, \and M. Bodnarchuk, \and S. Genheden, \and R. Bradshaw, \and G. Ross, \and C. Cave-Ayland, \and A. I. Cabedo Martinez, \and H. Bruce-Macdonald, \and J. Graham, \and Marley Samways}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
ProtoMS is short for “Prototype Molecular Simulation”, and is a software package that was originally designed by Dr. Christopher Woods to perform protein-ligand binding free energy calculations during his PhD. Dr. Julien Michel and Dr. Michael Bodnarchuk latter added numerous features and used the program extensively during their PhDs. Dr. Samuel Genheden, Dr. Richard Bradshaw, Dr. Gregory Ross, Dr. Chris Cave-Ayland, Dr. Ana Cabedo Martinez, Hannah Bruce-Macdonald and James Graham have since then made numerous additions to the code among them a complete revision of the tools used to setup and analyse the simulation results.

The program is routinely used by several members of the research group of Professor Jonathan Essex for the development of new techniques to perform free energy calculations. This document has been written to try and explain how to use ProtoMS.

The user manual has been written as a reference manual, with extensive hyperlinking to allow you to quickly dip in and out to find the information you need. While you could read it from start to end, it would be a boring and repetitive read and you probably wouldn’t learn much! We recommend that you engage with the tutorials that come with ProtoMS. You can then use the links in those descriptions to dip in and out of the user manual, thus obtaining a more detailed knowledge of how the examples, and thus ProtoMS, work.


\section{Formatting}
\label{\detokenize{introduction:formatting}}
The following formats are used throughout this document. Program commands or contents of files will be written in monotype, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperature} \PYG{n+nb}{float}
\end{sphinxVerbatim}

where float is a floating point option to the command. If this option is given a value (e.g. 25.0), then it is written like this

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperature} \PYG{l+m+mf}{25.0}
\end{sphinxVerbatim}

The following options are standard to many commands
\begin{itemize}
\item {} 
\sphinxstylestrong{float} A floating point number.

\item {} 
\sphinxstylestrong{integer} An integer. Most integer options given to ProtoMS are positive integers, greater than 0. This will always be made clear with the command.

\item {} 
\sphinxstylestrong{logical} A logical, true or false option. Possible values for this option are true or false, yes or no or on or off, depending on your personal preference.

\item {} 
\sphinxstylestrong{filename} This is the name of a file. Note that while ProtoMS is mostly case insensitive, file handling is dependent on the operating system you are using, so the filenames may be case sensitive. UNIX/Linux are examples of operating systems where case is important, while case is not important for Windows.

\end{itemize}


\chapter{Compilation and Installation}
\label{\detokenize{compilation:compilation-and-installation}}\label{\detokenize{compilation::doc}}
The ProtoMS package supplies the following files and directories;
\begin{itemize}
\item {} 
\sphinxstylestrong{CMakeLists.txt} This file configures ProtoMS prior to compiling.

\item {} 
\sphinxstylestrong{data} This directory contains a number of useful files, e.g. pre-equilibrated boxes and some template files

\item {} 
\sphinxstylestrong{doc} This directory contains documentation

\item {} 
\sphinxstylestrong{README} File that contains brief installation instructions for ProtoMS, and any last minute addendums or errata that arrived too late to make it into the manual!

\item {} 
\sphinxstylestrong{parameter} This directory contains all of the standard parameter files that describe the standard forcefields implemented in ProtoMS.

\item {} 
\sphinxstylestrong{protoms.py} A tool to setup common ProtoMS calculations

\item {} 
\sphinxstylestrong{python} This directory contains the python library component of ProtoMS

\item {} 
\sphinxstylestrong{src} This directory contains all of the source code for the main program

\item {} 
\sphinxstylestrong{tools} This directory contains numerous useful scripts to setup and analyse ProtoMS simualtions.

\item {} 
\sphinxstylestrong{tutorial} This directory contains a number of examples that demonstrate applications of ProtoMS.

\end{itemize}


\section{Programming Language}
\label{\detokenize{compilation:programming-language}}\label{\detokenize{compilation:fortran77}}
ProtoMS is written in slightly extended Fortran 77. The extensions used are
\begin{itemize}
\item {} 
The maximum line length is up to 132 characters, rather than 72.

\item {} 
Variable, subroutine and function names are greater than 6 characters.

\item {} 
\sphinxcode{\sphinxupquote{do/enddo}} loops are used rather than \sphinxcode{\sphinxupquote{do/continue}}.

\item {} 
Fortran \sphinxcode{\sphinxupquote{include}} is used to include the contents of other files.

\item {} 
The \sphinxcode{\sphinxupquote{flush}}, \sphinxcode{\sphinxupquote{getarg}} and \sphinxcode{\sphinxupquote{getenv}} non-standard intrinsic functions are used.

\item {} 
ProtoMS performs string manipulation using the \sphinxcode{\sphinxupquote{len}} function. In addition, the string manipulation assumes the same string handling behaviour as the GNU Fortran compiler (g77), so there is the possibility of strange formatting bugs when using different compilers.

\item {} 
The \sphinxcode{\sphinxupquote{Date}} and \sphinxcode{\sphinxupquote{Time}} Fortran 90 intrinsic subroutine is used to get the current time. This is used to provide a default seed to the random number generator. This can be removed by commenting out the relavant lines in \sphinxcode{\sphinxupquote{getoptions.F}}, though you will need to provide a random number seed manually.

\end{itemize}


\section{Requirements}
\label{\detokenize{compilation:requirements}}
The \sphinxstyleemphasis{MC program} has the following requirements:
\begin{itemize}
\item {} 
Fortan compiler, GNU (\sphinxurl{https://gcc.gnu.org/}) or Intel recommended

\item {} 
Python (\sphinxurl{https://www.python.org/}), required to compile and run ProtoMS

\item {} 
CMake (\sphinxurl{http://www.cmake.org/}), required to compile ProtoMS

\end{itemize}

Optional:
\begin{itemize}
\item {} 
MPI, recommended OpenMPI (\sphinxurl{http://www.open-mpi.org/}) or MPICH (\sphinxurl{https://www.mpich.org/}) - some functions will be unavailable without MPI

\end{itemize}

The \sphinxstyleemphasis{ProtoMS tools} have the following requirements:
\begin{itemize}
\item {} 
Python, version 2.7, version 3.5 or newer

\item {} 
NumPy (\sphinxurl{http://www.numpy.org/})

\item {} 
SciPy (\sphinxurl{http://www.scipy.org/})

\item {} 
Matplotlib (\sphinxurl{http://www.matplotlib.org/})

\item {} 
pymbar (\sphinxurl{https://github.com/choderalab/pymbar})

\end{itemize}

Optional:
\begin{itemize}
\item {} 
AmberTools (\sphinxurl{http://www.ambermd.org/})          : Required to parameterise small molecules

\end{itemize}

The tools are written in python (\sphinxurl{https://www.python.org/}) and are compatible with version 2.7 as well as version 3.5, 3.6 and 3.7.

A docker image that contains all of the installation dependencies is available. See {\hyperref[\detokenize{compilation:using-docker}]{\sphinxcrossref{\DUrole{std,std-ref}{Using Docker}}}} below.


\section{Installing ProtoMS}
\label{\detokenize{compilation:installing-protoms}}
ProtoMS has been written using the GNU Fortran compilers (\sphinxurl{https://gcc.gnu.org/}), on the Linux operating system. ProtoMS is thus known to work well with this compiler and Linux. ProtoMS has also been compiled and tested using the Intel Fortran Compiler. ProtoMS has been compiled with other compilers but not extensively tested. It is therefore strongly advised to use either GNU or Intel compilers with ProtoMS.

You also need an MPI package to perform simulations that require multiple processes, e.g. replica exchange. Such libraries should be available on most modern computers and clusters. The MPI compilers in the GNU package is called mpiff77. ProtoMS has been compiled with both OpenMPI (\sphinxurl{http://www.open-mpi.org/}) and MPICH (\sphinxurl{https://www.mpich.org/}). However, note that this is \sphinxstyleemphasis{not} a requirement any more. ProtoMS will compile without OpenMPI, but you won’t be able to run for instance replica exchange.

Building ProtoMS is done with \sphinxstyleemphasis{cmake} \sphinxurl{http://www.cmake.org/}, thus you need this package installed on your machine. Before proceeding it is important that your environment is properly configured. In particular, since version 3.4, ProtoMS installs the Python package \sphinxstyleemphasis{protomslib} into your python environment. If you are using a virtual environment this must be activated so that cmake can locate the correct python interpreter. To prepare the build, type the following in a terminal from the root directory of the code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{n}{build}
\PYG{n}{cd} \PYG{n}{build}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

At this point you should check the output of cmake. Unless you’re expecting it not to, cmake should have found an appropriate Fortran compiler,  MPI library and Python interpreter. Check that the paths and versions of these correspond to those you expect. If they do not, see {\hyperref[\detokenize{compilation:custom-build}]{\sphinxcrossref{\DUrole{std,std-ref}{Customising the Build}}}} for details on how to customise these. Also note that if cmake has found the system python interpreter (usually /usr/bin/python) it will attempt to install protomslib into a system location requiring root access. Again {\hyperref[\detokenize{compilation:custom-build}]{\sphinxcrossref{\DUrole{std,std-ref}{Customising the Build}}}} covers how to change the Python installation target. If you’re happy with what cmake has found then type:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make} \PYG{n}{install}
\end{sphinxVerbatim}

and \sphinxstyleemphasis{cmake} will perform the necessary checks before it continues with the installation of ProtoMS. The executable will be placed in the top level of the folder hierarchy.

In order for ProtoMS to find the relevant parameter files it is necessary to set the environmental variable \sphinxcode{\sphinxupquote{\$PROTOMSHOME}} to the installation directory of ProtoMS. This variable is used as a shortcut in the tutorials and by the Python tools. ProtoMS is also able to substitute this variable when it is used in ProtoMS command files.

Once building is complete it is highly recommended to run the test suite that comes with ProtoMS to test that the build was successful. From the build directory created above simply type:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ctest} \PYG{o}{\PYGZhy{}}\PYG{n}{V}
\end{sphinxVerbatim}

All tests should be expected to pass and the above command will provide detailed output. The most common reason for failures is the need to set the correct environment variables. Notably \sphinxcode{\sphinxupquote{\$AMBERHOME}} for the setup tests and \sphinxcode{\sphinxupquote{\$PROTOMSHOME}}, as described above. Another reason for occasional failures is slight formatting and rounding differences between compilers, this can lead to values differing at the final decimal place in results files and such failures can be safely ignored.


\section{Customising the Build}
\label{\detokenize{compilation:customising-the-build}}\label{\detokenize{compilation:custom-build}}
\sphinxstylestrong{Tips on using cmake}

The job of cmake is to attempt to locate all of the necessary dependencies for the installation and create a Makefile that will compile ProtoMS. It searches your system for the required components and sets a number of internal variables that store their locations. After being run cmake stores its output in the build directory in a file called CMakeCache.txt. This can be useful after the fact to check which dependencies were found but equally if being run subsequently cmake will prefer to use cached values instead of updating dependencies. For this reason it can be a good idea to delete CMakeCache.txt if you find you need to run cmake more than once or cmake does not appear to be behaving as expected.

\sphinxstylestrong{Manually specify cmake variables}
\begin{quote}

The locations that cmake will search for dependencies are quite comprehensive, however they are also dependent on the system in use and the value of current environment variables. Thus cmake may not be able to find the required libraries even if they’re present in your system or may find the wrong versions. To coerce cmake into finding the relevant dependencies you can try:
\begin{enumerate}
\item {} 
Setting environment variables - The \$PATH environment variable is checked by cmake for relevant executables e.g. gfortran, mpirun. Prepending to or rearranging entries in the PATH makes dependencies discoverable by cmake. The FC environment variable is a standard method for manually specifying the Fortran compiler.

\item {} 
Manually setting cmake variables - Whilst cmake attempts to automatically discover correct values for dependencies you may find that setting them manually is easier. This can be performed interactively using the \sphinxcode{\sphinxupquote{ccmake}} utility. If you execute \sphinxcode{\sphinxupquote{ccmake ..}} from the build directory you will be presented with a interface showing the current value of cmake variables. Press \sphinxcode{\sphinxupquote{t}} to see more values. You can edit values from this menu before pressing \sphinxcode{\sphinxupquote{c}} to configure (any problems should be flagged by cmake here) and \sphinxcode{\sphinxupquote{g}} to generate a new Makefile and exit.

\item {} 
Manually setting cmake variables on the command line - If you prefer the value of any cmake variable can be specified directly from the command line. The \sphinxcode{\sphinxupquote{-D}} flag to cmake can be used repeatedly for this purpose. For instance - \sphinxcode{\sphinxupquote{cmake -DCMAKE\_Fortran\_COMPILER=gfortran ..}} - sets the value of the  variable CMAKE\_Fortran\_COMPILER to gfortran. You can use \sphinxcode{\sphinxupquote{ccmake}} to determine the names of variables to set.

\end{enumerate}
\end{quote}

\sphinxstylestrong{Installation of protomslib}

You can customise the installation of the python library component by specify a value for the cmake variable PYTHON\_INSTALL\_OPTIONS (see above). The value of this variable will be appended like so to the command below which is executed by cmake:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python setup.py install \PYGZdl{}PYTHON\PYGZus{}INSTALL\PYGZus{}OPTIONS
\end{sphinxVerbatim}

To see the available options you can run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python \PYGZdl{}PROTOMSHOME/python/setup.py install \PYGZhy{}\PYGZhy{}help
\end{sphinxVerbatim}

The most frequently useful options are \sphinxcode{\sphinxupquote{-{-}user}}, that requests an installation into \sphinxcode{\sphinxupquote{\$HOME/.local}}, and \textendash{}prefix that allows an installation root directory to be specified manually.


\section{Using Docker}
\label{\detokenize{compilation:using-docker}}\label{\detokenize{compilation:id1}}
Version 3.4 of ProtoMS is also available via docker. Downloading and running the image can be accomplished easily with the command:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{it} \PYG{n}{jessexgroup}\PYG{o}{/}\PYG{n}{protoms}\PYG{p}{:}\PYG{l+m+mf}{3.4}
\end{sphinxVerbatim}

The image is based on the python:3.6.6 image with additional installation of the relevant python dependencies as well as amber tools 18. To construct your own docker images from scratch see \sphinxcode{\sphinxupquote{Dockerfile\_test}} and \sphinxcode{\sphinxupquote{Dockerfile}} in the root ProtoMS directory and the instructions therein. This will allow you to use newer versions of the dependencies than are available via the public image.


\chapter{Design of ProtoMS}
\label{\detokenize{protoms:design-of-protoms}}\label{\detokenize{protoms::doc}}
\index{design}\ignorespaces 
ProtoMS is a powerful simulation program that is capable of being used in many different ways. ProtoMS was originally designed to perform Monte Carlo free energy calculations on protein-ligand systems, so a lot of the terminology and ideas associated with ProtoMS derive from protein-ligand Monte Carlo methodology. While the code was originally designed with this use in mind, the framework is sufficiently flexible to allow the study of a wide range of different systems, using a wide range of simulation methodology.

At the core of ProtoMS are four central concepts;
\begin{itemize}
\item {} 
\sphinxstylestrong{Proteins/Solutes/Solvents/GCSolutes} ProtoMS divides all molecules to be simulated into ‘proteins’, ‘solutes’ and ‘solvent’.

\item {} 
\sphinxstylestrong{Classical Forcefields} ProtoMS Uses a generic classical forcefield to calculate the energy of the molecules. This forcefield may be specialised such that ProtoMS is able to implement a wide range of modern molecular mechanics forcefields.

\item {} 
\sphinxstylestrong{Perturbations} ProtoMS provides support for free energy calculations by allowing forcefields and geometries to be perturbed using a \(\lambda\) coordinate. The forcefield for any protein, solute or solvent may be perturbed, and the geometry of any solute may be perturbed.

\item {} 
\sphinxstylestrong{Generic Moves} ProtoMS is designed around the concept a ‘move’. The move can do anything, from a Monte Carlo translation of solvent to a docking type move on a solute. A simulation is constructed by stringing a collection of moves together.

\end{itemize}


\section{Proteins / Solutes / Solvents / GCSolutes}
\label{\detokenize{protoms:proteins-solutes-solvents-gcsolutes}}
ProtoMS divides all of the molecules loaded within a system into solvents, GCsolutes, solutes and proteins
\begin{itemize}
\item {} 
\sphinxstylestrong{solvents}  A solvent is any rigid molecule. Solvents may only be translated and rotated, and by default, 75000 solvent molecules may be loaded, each consisting of up to 10 atoms. Solvent molecules do not have to be small - a rigid lipid molecule could be modelled as a solvent. There is no requirement for the solvents loaded in a system to be the same. Indeed every solvent loaded could be a different type of molecule!

\item {} 
\sphinxstylestrong{GCsolutes} Like a solvent molecule, GCsolutes are rigid. They have the same properties as previously described for solvents, except GCsolutes are restrained to a defined region in the simulation.

\item {} 
\sphinxstylestrong{solutes} A solute is any flexible molecule. Solutes can be translated and rotated, and change their internal geometry. By default 60 solutes, each composed of 10 residues, each composed of 100 atoms may be loaded simultaneously. Solute molecules are described using z-matrices, thus a solute molecule is perhaps what you would be most familiar with from other Monte Carlo simulation programs. Note that you can describe a protein molecule as a solute, and that you do not need to load it up as a ‘protein’.

\item {} 
\sphinxstylestrong{proteins} A protein is any flexible chain molecule (polymer). A protein is composed of a linear chain of residues, with interresidue bonds connecting one residue to the next. By default, ProtoMS can load up to 3 proteins simultaneously, each protein consisting of 1000 residues, each consisting of up to 34 atoms.

\end{itemize}

\index{Solvents}\ignorespaces 
\sphinxstylestrong{Solvents}

Solvents are loaded into ProtoMS from PDB files (see section {\hyperref[\detokenize{protoms:solventpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Solvent File}}}}). Each solvent molecule is identified by its residue name (the fourth column in the PDB file), e.g. ProtoMS identifies the TIP4P solvent with the residue name ‘T4P’. ProtoMS loads the coordinates of the solvent from the PDB file, and then assigns the parameters for the solvent from a solvent template (see section {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}). The solvent template contains the information necessary to identify all of the atoms in the solvent molecule and to assign forcefield parameters to each atom. Note that this version of ProtoMS uses the coordinates of the solvent molecule that are present in the PDB file. ProtoMS does not yet have the capability to modify these coordinates to ensure that the internal geometry of the solvent is correct for the solvent model. This means that as solvents are only translated and rotated, the internal geometry of
the solvent molecule loaded at the start of the simulation will be identical to that at the end of the simulation.

\index{GCSolutes}\ignorespaces 
\sphinxstylestrong{GCSolutes}

Like solvents, GCsolutes are loaded into ProtoMS from PDB files (see section {\hyperref[\detokenize{protoms:gcpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{GCsolute File}}}}). Each GCsolute molecule is identified by its residue name (the fourth column in the PDB file). ProtoMS loads the coordinates of the GCsolute from the PDB file, and then assigns the parameters for the GCsolute from a GCsolute template (see section {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}). This template contains the information necessary to identify all of the atoms in the solvent molecule and to assign forcefield parameters to each atom. Alongside translational and rotational moves, the intermolecular energy between the GCsolute and the system can be sampled.

\index{Solutes}\ignorespaces 
\sphinxstylestrong{Solutes}

Solutes are also loaded into ProtoMS from PDB files (see section {\hyperref[\detokenize{protoms:solpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Solute File}}}}). Each solute molecule is identified by its solute name, which is given in the HEADER record of the PDB file. ProtoMS obtains the coordinates of the solute from the PDB file, and will then find a solute template that matches this solute name (see {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}). The solute template is used to build the z-matrix for the solute, and to assign all of the forcefield parameters. The solute template is also used to assign the connectivity of the solute and to define the flexible internal coordinates. The solute molecule is constructed using the z-matrix, with the reference being three automatically added dummy atoms, called ‘DM1’, ‘DM2’ and ‘DM3’, all part of residue ‘DUM’. These dummy atoms are automatically added by ProtoMS at the geometric center of the solute, as a right angled set of atoms pointing along the major and minor axes of the solute.

\index{Proteins}\ignorespaces 
\sphinxstylestrong{Proteins}
Proteins are loaded into ProtoMS via PDB files (see section {\hyperref[\detokenize{protoms:protpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Protein File}}}}). Each PDB file may only contain a single protein chain. ProtoMS constructs the linear chain of molecules based on the order of residues that it reads from the PDB file, and will ignore the residue number read from the PDB file. This means that you must ensure that you have the residues ordered correctly within the PDB file. ProtoMS assigns to each residue both a chain template (see section {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}), that describes the backbone of the residue, and a residue template (see section {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}), that describes the sidechain. The residue template is located based on the name of the residue given in the fourth column in the PDB file (e.g. ‘ASP’ or ‘HIS’). The chain template is located based on the chain template associated with the residue template for the position of the residue within the chain. For example, residue ‘ASP’ has a standard amino acid backbone chain template if this residue was in the middle of the chain, an NH+ capped backbone chain template 3 if this was the first residue of the chain (and thus at the n-terminus), and a CO\textendash{} capped backbone chain template 2 if this were the last residue of the chain (and thus at the c-terminus). If the protein consisted of only one residue, then the zwitterionic amino acid chain template would be used for ‘ASP’.

ProtoMS obtains the coordinates of each residue from the PDB file, and will then use the residue and chain templates to build the z-matrix for each residue, and to assign all of the forcefield parameters.

\phantomsection\label{\detokenize{protoms:bbatoms}}
Proteins are moved in a different manner in ProtoMS compared to other Monte Carlo packages that are available. Each residue is moved independently, using both the internal geometry moves defined by the template z-matrix, and by backbone translation and rotation moves of the chain atoms (see figure above).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{backbone}.png}
\caption{Four atoms from each protein residue are designated as backbone atoms (bbatoms). For most residues these atoms are the N, CA, C and O atoms respectively. The four backbone atoms for two neighbouring residues are shown above. The protein backbone move moves the last three bbatoms of one residue and the first bbatom of the next residue. This is because the moves assumes that these four bbatoms form a rigid triangle (as is shown by the grey lines). The four atoms are translated and rotated as a rigid triangle, with the origin of rotation of the triangle centered on the intersection of the vector between bbatoms 2 and 1, and the vector between bbatoms 3 and 4 (marked as a red dot directly above the C=O bond). Because this triangle is translated and rotated as a rigid unit, all atoms connected to the atoms of this triangle will also be translated and rotated as a rigid unit.}\label{\detokenize{protoms:id2}}\end{figure}

Four special backbone atoms (bbatoms) are identified in the chain-backbone of each residue. These atoms form the reference from which the rest of the residue atoms are built. These four atoms can be translated and rotated as a rigid unit via protein backbone moves (see figure above). As the rest of the residue is constructed from these bbatoms, the rest of the residue is thus also translated and rotated. Because the bbatoms are translated and rotated as a rigid unit, the internal geometry of these backbone atoms are held constant throughout the simulation. This means that the internal geometry of the bbatoms is taken from the PDB file, and may not be modified by the chain or residue templates. It is also not possible to build missing bbatoms, so they must all be present in the PDB file.

Once the coordinates and z-matrices of each residue have been assigned, interresidue bonds are added between the first bbatom of each residue and the third bbatom of the previous residue (e.g. for ‘ASP’, bonds would be added from the ‘N’ atom of the ‘ASP’ residue to the ‘C’ atom of the preceeding amino acid residue). If the length of this bond is less than 4 A then this bond is added as a real bond, and its energy is evaluated as part of the forcefield. However, if the length is greater than 4 A, then this bond will be added as a dummy bond, and a warning message output. This is useful in cases where you wish to load up a protein scoop, e.g. from around the active site. This option should be used with care in conjunction with backbone moves.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Table 1.0 The default value of the maximum number of proteins, GCsolutes, solutes and solvents that may be loaded simultaneously by ProtoMS. These values may be changed by editing the \sphinxstyleliteralintitle{\sphinxupquote{dimensions.inc}} file located in the src directory, and recompiling ProtoMS.}\label{\detokenize{protoms:id3}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Values
\\
\hline
MAXPROTEINS
&
Maximum number of proteins
&
3
\\
\hline
MAXRESIDUES
&
Maximum number of residues per protein
&
1000
\\
\hline
MAXSCATOMS
&
Maximum number of atoms per protein residue
&
30
\\
\hline
MAXSOLUTES
&
Maximum number of solutes
&
60
\\
\hline
MAXSOLUTERESIDUES
&
Maximum number of residues per solute
&
10
\\
\hline
MAXSOLUTEATOMSPERRESIDUE
&
Maximum number of solute atoms per residue
&
100
\\
\hline
MAXSOLVENTS
&
Maximum number of solvent molecules
&
75000
\\
\hline
MAXSOLVENTS
&
Maximum number of GCsolute molecules
&
75000
\\
\hline
MAXSOLVENTATOMS
&
Maximum number of atoms per solvent
&
10
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Limits}

ProtoMS is written using slightly extended Fortran 77 (see {\hyperref[\detokenize{compilation:fortran77}]{\sphinxcrossref{\DUrole{std,std-ref}{Programming Language}}}}). This means that the maximum numbers of loaded proteins, solutes and solvents has to be set at compile time. Table 1.0 gives the default values for the maximum number of proteins, solutes and solvents. Please note that you may change these numbers to fit the system that you are interested in, e.g. if you were investigating a single protein in a lipid bilayer then you may choose to model the lipid as a solute (thus requiring a large increase in the number of solute molecules, but a decrease in the number of solute residues), and you could reduce the maximum number of protein molecules to one. By balancing the numbers of protein, solutes and solvents you should find that you are able to load up the system that you want to simulate.

\index{Forcefields}\ignorespaces 

\section{Classical forcefields}
\label{\detokenize{protoms:classical-forcefields}}\label{\detokenize{protoms:index-5}}
ProtoMS was designed to perform simulations using a range of different molecular mechanics (MM) forcefields. To achieve this aim, a generic forcefield has been implemented, and this can be specialised into a specific, traditional forcefield. Specifically, ProtoMS supports the use of the Amber ff99, ff99SB and ff14SB protein forcefields, along with OPLS 96. The General Amber Forcefield (GAFF) is used for solutes, whilst various solvent forcefield models including TIP3P, TIP4P, SPC and SPC/E can be used.

The forcefield in ProtoMS is comprised of several terms;

\index{Intermolecular Potential}\index{Coulomb Potential}\index{van der Waals Potential}\ignorespaces 
\sphinxstylestrong{Intermolecular Potential}

An intermolecular potential acts between all molecules within the system. The intermolecular potential between a pair of molecules, \sphinxstyleemphasis{A} and \sphinxstyleemphasis{B}, \(U_{molecule} (A, B)\), with \sphinxstyleemphasis{A} consisting of \(n_A\) atoms and \sphinxstyleemphasis{B} consisting of \(n_B\) atoms, is formed as the sum of the non-bonded potential, \(U_{nb} (i, j)\) between each pair of atom sites, \sphinxstyleemphasis{i} and \sphinxstyleemphasis{j}, between the two molecules, scaled by a constant, \sphinxstyleemphasis{scl}, e.g.
\begin{equation}\label{equation:protoms:intermol1}
\begin{split}U_{molecule}(A,B) = scl(R)\times\biggl( \sum_{i=1}^{n_A} \sum_{j=1}^{n_B} U_{nb}(i,j) \biggr)\end{split}
\end{equation}
where \sphinxstyleemphasis{R} is the shortest distance between a pair of atom sites between the molecules. The scaling factor is set according to
\begin{align*}\!\begin{aligned}
&R \ge r_{cut} \rightarrow scl = 0.0 \\\\
&r_{cut}-r_{feather} \le R \le r_{cut} \rightarrow scl = \frac{r_{cut}^2-R^2}{r_{cut}^2-(r_{cut}-r_{feather})^2} \\\\
&R \le r_{feather} \rightarrow scl = 1.0,\\
\end{aligned}\end{align*}
where \(r_{cut}\) and \(r_{feather}\) are the non-bonded cutoff and feather parameters.

The non-bonded potential between the pair of atoms is evaluated as the sum of the Coulombic and Lennard-Jones (LJ) potentials between the atoms,
\begin{equation}\label{equation:protoms:intermol2}
\begin{split}U_{nb}(i,j) = \frac{q_i q_j}{4\pi\epsilon_{0} r(i,j)} + 4\epsilon_{ij}\biggl[ \biggl(\frac{\sigma_{ij}}{r(i,j)}\biggr)^{12} - \biggl(\frac{\sigma_{ij}}{r(i,j)}\biggr)^6 \biggr],\end{split}
\end{equation}
where \(q_i\) and \(q_j\) are the partial charges on the two atom sites, \sphinxstyleemphasis{r(i, j)} is the distance between the atom sites, \(\epsilon_0\) is the permittivity of free space and \(\sigma_{ij}\) and \(\epsilon_{ij}\) are the Lennard Jones parameters for the atom site pair \sphinxstyleemphasis{i} and \sphinxstyleemphasis{j}. The LJ parameters for an atom site pair are calculated as the average of the LJ parameters for the same site pair.

\index{combination rules}\ignorespaces 
Either the arithmetic average is used, or the geometric average is used, e.g.
\begin{equation}\label{equation:protoms:arithmetriccomb}
\begin{split}\sigma_{ij} = 0.5\times(\sigma_{ii} + \sigma_{jj}).\end{split}
\end{equation}\begin{equation}\label{equation:protoms:geometriccomb}
\begin{split}\epsilon_{ij} = \sqrt{\epsilon_{ii}\times\epsilon_{jj}}.\end{split}
\end{equation}
The AMBER family of forcefields use the arithmetic average for \(\sigma\), and the geometric average for \(\epsilon\), while the OPLS family of forcefields use the geometric average for both parameters. The intermolecular potential is formed as the sum of the non-bonded potential over all pairs of atom sites. It should be noted that an atom site does not necessarily need to lie at the center of each atom, and it may lie between atoms, or at the location of any lone pairs. Individual atoms may possess many atom sites, or even no atom sites.

\index{Bond Potential}\ignorespaces 
\sphinxstylestrong{Bond Potential}

A bond potential acts over all of the explicitly added, non-dummy bonds within a molecule. ProtoMS makes no attempt to find any implicit bonds within a molecule, and it is not possible to add a bond between atoms of different molecules. The energy of each bond, \(U_{bond}\) , is evaluated according to
\begin{equation}\label{equation:protoms:bondpot}
\begin{split}U_{bond}(r) = k_{bond}\bigl(r-r_0\bigr)^2,\end{split}
\end{equation}
where \sphinxstyleemphasis{r} is the bond length, \(k_{bond}\) is the force constant for the bond, and \(r_0\) is the equilibrium bond length. The total bond energy of a molecule is the sum of the bond energies for all of the bonds within the molecule, and the total bond energy of the system is the sum of the bond energies for each of the molecules in the system.

\index{Angle Potential}\ignorespaces 
\sphinxstylestrong{Angle Potential}

An angle potential acts over all angles between atoms that are connected by non-dummy bonds, and over all
non-dummy angles that have been explicitly added to the molecule. The energy of each angle, Uangle , is evaluated
according to
\begin{equation}\label{equation:protoms:angpot}
\begin{split}U_{angle}(\theta) = k_{angle}\bigl(\theta-\theta_0\bigr)^2,\end{split}
\end{equation}
where \(\theta\) is the size of the angle, \(k_{angle}\) is the force constant for the angle, and \(\theta_0\) is the equilibrium angle size. The total angle energy of a molecule is the sum of the angle energies for each of the angles within the molecule, and the total energy of the system is the sum of the angle energies for each of the molecules in the system.

\index{Urey-Bradley Potential}\ignorespaces 
\sphinxstylestrong{Urey-Bradley Potential}

A Urey-Bradley potential may act between the first and third atoms of some of the angles that are evaluated for the angle potential. If this is the case, then a Urey-Bradley energy is added onto the angle energy. The Urey-Bradley energy, \(U_{uby}\), is evaluated according to
\begin{equation}\label{equation:protoms:ubpot}
\begin{split}U_{uby}(x) = k_{uby}\bigl(x-x_0\bigr)^2,\end{split}
\end{equation}
where \sphinxstyleemphasis{x} is the distance between the first and third atoms, \(k_{uby}\) is the Urey-Bradley force constant, and \(x_0\) is the equilibrium distance.

\index{Dihedral Potential}\ignorespaces 
\sphinxstylestrong{Dihedral Potential}

A dihedral potential acts over all dihedrals between atoms that are connected by non-dummy bonds, and over all non-dummy dihedrals that have been explicitly added to the molecule. Such explicitly added dihedrals may be used to add improper dihedrals that maintain the stereochemistry of chiral centers. The energy for each dihedral, \(U_{dihedral}\), is formed as the sum of \sphinxstyleemphasis{n} cosine terms,
\begin{equation}\label{equation:protoms:dihepot}
\begin{split}U_{dihedral}(\phi) = \sum_{i=1}^{n} k_{i1}\bigl[1.0 + k_{i2}\bigl(cos(k_{i3}\phi + k_{i4})\bigr)\bigr],\end{split}
\end{equation}
where \(k_{i1}\) to \(k_{i4}\) are dihedral parameters and \(\phi\) is the size of the dihedral. The total dihedral energy of a molecule is the sum of the dihedral energies for each of the dihedrals in the molecule, and the total dihedral energy of the system is the sum of the dihedral energies of each of the molecules.

\index{Intramolecular non-bonded Potential}\ignorespaces 
\sphinxstylestrong{Intramolecular non-bonded Potential}

An intramolecular non-bonded potential acts between all intramolecular pairs of atoms that are either not connected by a non-dummy bond, or are not both connected to a third atom by a non-dummy bond. To make this more clear, if two atoms are connected by a non-dummy bond then they are said to be 1-2 bonded. If two atoms are both connected to a third atom by non-dummy bonds, then they are said to 1-?-3, or 1-3 bonded. Similarly, if the pair of atoms are connected together via two atoms via non-dummy bonds, then they are said to be 1-?-?-4, or 1-4 bonded. An intramolecular non-bonded potential does not act over 1-2 or 1-3 bonded pairs within a molecule, but does act over 1-4 bonded pairs and above. Note that ProtoMS only looks at the non-dummy bonds between atoms, and will not consider whether or not there are non-dummy angles, Urey-Bradley or dihedral terms involving these atoms.

The intramolecular non-bonded potential of a molecule, \(U_{intra}\) is the sum of the non-bonded energy between all 1-5 and above pairs of atoms within the molecule, plus the sum of the non-bonded energy between all 1-4 atoms scaled by a 1-4 scaling factor, e.g.
\begin{equation}\label{equation:protoms:intrapot1}
\begin{split}U_{intra} = &\sum_{\text{1-5+ i j pairs}} U_{coul}(i,j) + U_{lj}(i,j) + \sum_{\text{1-4 i j pairs}} scl_{coul} U_{coul}(i,j) + scl_{lj} U_{lj}(i,j),\end{split}
\end{equation}
where
\begin{equation}\label{equation:protoms:intrapot2}
\begin{split}U_{coul}(i,j) = \frac{q_i q_j}{4\pi\epsilon_{0} r},\end{split}
\end{equation}
and
\begin{equation}\label{equation:protoms:intrapot3}
\begin{split}U_{lj}(i,j) = 4\epsilon_{ij}\biggl[ \biggl(\frac{\sigma_{ij}}{r}\biggr)^{12} - \biggl(\frac{\sigma_{ij}}{r}\biggr)^6 \biggr].\end{split}
\end{equation}
Equations \eqref{equation:protoms:intrapot2} and \eqref{equation:protoms:intrapot3} are the Coulomb and Lennard Jones equations, as seen in the intermolecular potential in equations \eqref{equation:protoms:intermol1} and \eqref{equation:protoms:intermol2}. \(scl_{coul}\) and \(scl_{lj}\) are the Coulomb and Lennard Jones scaling factors.

\index{GBSA Potential}\ignorespaces 
\sphinxstylestrong{Generalized Born Surface Area potential}

While free energy simulations are usually conducted in explicit solvent, ProtoMS supports Generalized Born Surface Area (GBSA) implicit solvent models. Relatively few free energy implicit solvent studies have been conducted and such option should be tested carefully before embarking onto expensive free energy simulations. The GBSA theory assumes that the total solvation free energy of a molecule A is a sum of a polar and non-polar energy term:
\begin{equation}\label{equation:protoms:gb1}
\begin{split}\Delta G_{solv} = \Delta G_{pol} + \Delta G_{nonpol}\end{split}
\end{equation}
The second term, is simply proportional to the solvent accessible surface area (SASA) of the molecule, times a parameter that depends on the atom types present in the molecule. The first term is more complex and derived from the following equation :
\begin{equation}\label{equation:protoms:gb2}
\begin{split}\Delta G_{pol} = -\frac{1}{2}(\frac{1}{\epsilon_{vac}}-\frac{1}{\epsilon_{solv}})  \sum_{i}\sum_{j} \frac{q_{i}q_{j}}{\sqrt{r^{2}_{ij} + B_{i}B_{j} e^{\frac{-r^{2}_{ij}}{4B_{i}B_{j}}}   } }\end{split}
\end{equation}
\(\epsilon_{vac}\) and \(\epsilon_{solv}\) are the dielectric constants of the vacuum and the solvent respectively, \(q_{i}\) the atomic partial charge of atom \sphinxstyleemphasis{i}, \(r_{ij}\) the distance between a pair of atoms \sphinxstyleemphasis{ij}, and \(B_{i}\) is the effective Born radius of atom \sphinxstyleemphasis{i}.

The effective Born Radius \(B_{i}\) is in essence the spherically averaged distance of the solute atom to the solvent. An accurate estimate of this quantity is essential to calculate high quality solvation free energies. It is however fairly complex to compute as it formalyl involves an integral over the position of all the atoms in the system. While numerical techniques can calculate such value, they are too slow to be of practical use in a simulation. In ProtoMS, the effective Born radii are calculated using the Pairwise Descreening Approximation (PDA) method.
\begin{align*}\!\begin{aligned}
{\frac{1}{B_i}} = \frac{1}{\alpha _{i}} - \frac{1}{2} \sum_{j \not= i} \lbrack \frac{1}{L_{ij}}-\frac{1}{U_{ij}}+\frac{r_{ij}}{4}(\frac{1}{U_{ij}^{2}}-\frac{1}{L_{ij}^{2}}) +\frac{1}{2r_{ij}}ln\frac{L_{ij}}{U_{ij}} + \frac{S_{j}^{2}\alpha_{j}^{2}}{4r_{ij}}(\frac{1}{L_{ij}^{2}}-\frac{1}{U_{ij}^{2}} ) \rbrack\\
L_{ij} &= 1 \quad if \quad r_{ij} + S_{j}\alpha_{j} \leq \alpha_{i} \\\\
L_{ij} &= \alpha_{i} \quad if \quad r_{ij} - S_{j}\alpha_{j} \leq \alpha_{i}  <r_{ij} + S_{j}\alpha_{j}\\\\
L_{ij} &= r_{ij} - S_{j}\alpha_{j} \quad if \quad \alpha_{i} \leq r_{ij} - S_{j}\alpha_{j}\\\\
U_{ij} &= 1 \quad if \quad  r_{ij} + S_{j}\alpha_{j} \leq \alpha_{j}\\\\
U_{ij} &= r_{ij} + S_{j}\alpha_{j} \quad if \quad \alpha{i} <  r_{ij} + S_{j}\alpha_{j}\\\\
\end{aligned}\end{align*}
where \(r_{ij}\) is the distance between a pair of atoms \sphinxstyleemphasis{ij} and \(\alpha_{i}\) is the intrinsic Born radius of atom \sphinxstyleemphasis{i}, that is, the Born radius that atom \sphinxstyleemphasis{i} would adopt if it was completely isolated. Finally \(S_{j}\) is a scaling factor which compensates for systematic errors introduced by this approximate Born radii calculation.

As the name says, the technique approximate the descreening (the extent to which a nearby atom j displaces a volume that would have otherwise been occupied by solvent) by a fast summation of pairwise terms. It is however not rigorous and has to be parameterised carefully to yield robust performance. The PDA method tend to systematically underestimate the Born radius of buried atoms because it incorrectly assign high dielectric constants to numerous small voids and crevices that exist between atoms in a protein and are not occupied by water. To increase accuracy, a re-scaling technique has been implemented.
\begin{equation*}
\begin{split}{\frac{1}{B_i}}  = \frac{1}{\alpha _{i}} - Itanh\big( \alpha \psi - \beta \psi^{2} + \gamma \psi^{3}  \big)\end{split}
\end{equation*}
where \sphinxstyleemphasis{I} is the summation term from the PDA calculation, \(\psi\), \(\alpha\), \(\beta\) and \(\gamma\) are parameters taken from the litterature.

The rescaling option has not been used extensively in ProtoMS and should be used with caution. It appears it may prove useful when simulation buried protein binding sites.

The GBSA force field implemented in ProtoMS was parameterised to be used with the AMBER99 and the GAFF force fields. While alternative force fields could be used, a loss of accuracy could be expected.

GBSA simulations are order of magnitude more efficient than explicit solvent simulations of small isolated molecules. However, they slow
down rapidly when the size of the system increases. This is especially notable in Monte Carlo simulations where a small movement of part of a system formally warrants the computation the entire solvation energy of the system. This issue arises because the GBSA energy terms are not strictly pairwise decomposable.  It is possible to use however different techniques to increase the speed of a GBSA simulation. Cutoffs in the calculation of the Born radii are introduced and in addition the update of pairwise GB energies can be skipped if the Born radii of either atoms have not changed more than a certain threshold value after a MC move. Because this option will introduce energy drifts, it is advised to periodically recalculate rigorously the GB energy. In addition, a more complex Monte Carlo move is implemented in ProtoMS. This option allows to conduct a simulation with a crude GBSA model and a low cutoff for the non bonded energy terms. Normally the  predicted macroscopic properties would suffer from such crude treatment of intermolecular energies. However, periodically, a special acceptance test is employed to remove the bias introduced by the crude potential and ensure that the equilibrium density of states generated by the Monte Carlo simulation converges to the equilibrium density of states suitable for the standard biomolecular potential.

Actual speedups using either techniques are system dependent and optimisation of the different parameters can be a complex task. It is advised to use the default parameters described latter in the manual.

\sphinxstylestrong{Caveats}

ProtoMS implements this forcefield mostly as described. However there are a few shortcuts that are taken to improve the efficiency of the code. These shortcuts are based on the three-way split of the molecules of the system into solvents, solutes and proteins
\begin{itemize}
\item {} 
\sphinxstylestrong{solvents} As solvents are rigid, there is no need to evaluate any of the intramolecular potentials. ProtoMS thus only evaluates the intermolecular energy of solvent molecules.

\item {} 
\sphinxstylestrong{solutes} ProtoMS evaluates the forcefield of solute molecules exactly as described, with no shortcuts.

\item {} 
\sphinxstylestrong{proteins}. ProtoMS implements a protein as a chain of residues. As these molecules can be large, and typically larger than the non-bonded cutoff, ProtoMS implements the non-bonded cutoff differently for proteins. Instead of evaluating the non-bonded cutoff for the protein as a whole, ProtoMS implements a residue-based cutoff, with the cutoff scaling factors evaluated individually for each residue. Additionally, the intramolecular non-bonded energy is also scaled according to the non-bonded cutoffs given in equation \eqref{equation:protoms:intermol1}. If you do not want to use residue based cutoffs, then it is possible to tell ProtoMS to use a molecule based cutoff, in which case the forcefield for proteins will be evaluated exactly as described with no shortcuts.

\end{itemize}

\index{Perturbations}\ignorespaces 

\section{Perturbations}
\label{\detokenize{protoms:perturbations}}\label{\detokenize{protoms:index-14}}
ProtoMS is capable of calculating the relative free energy of two systems. ProtoMS does this by perturbing one system into the other through the use of a \(\lambda\)-coordinate. If A and B are the two systems of interest, then the forcefield is constructed such that at \(\lambda\) = 0.0 the forcefield represents system A, at \(\lambda\) = 1.0 the forcefield represents system B, and at \(\lambda\) value inbetween, the forcefield represents a hybrid of A and B.

ProtoMS implements two methods of perturbing between systems A and B;
\begin{itemize}
\item {} 
\sphinxstylestrong{Single topology} System A is perturbed into system B by scaling the forcefield parameters such that the model morphs from A to B.

\item {} 
\sphinxstylestrong{Dual topology} System A and B are simulated together, with \(\lambda\) scaling the total energies of A and B such that one system is turned off as the other is turned on.

\end{itemize}

\index{Single Topology}\ignorespaces 
\sphinxstylestrong{Single Topology Calculations}

ProtoMS assigns two sets of parameters to every single forcefield term; one parameter represents that term at \(\lambda=0.0\) (\(par_0\)), the other represents that term at \(\lambda=1.0\) (\(par_1\)). \(\lambda\) is used to linearly scale between these two parameters to obtain the value of the parameter at each value of \(\lambda\) (\(par_\lambda\))
\begin{equation}\label{equation:protoms:lambdamix}
\begin{split}par_\lambda = (1.0-\lambda) \times par_0 + \lambda \times par_1.\end{split}
\end{equation}
This equation is used to scale the charge, \(\sigma\) and \(\epsilon\) parameters assigned to each atom site (see equations \eqref{equation:protoms:intermol1}), and the force constants (\(k_{bond}\), \(k_{angle}\) and \(k_{uby}\)) and equilibrium sizes (\(r_0\), \(\theta_0\) and \(x_0\)) for the bond, angle and Urey-Bradley terms (see equations \eqref{equation:protoms:bondpot}, \eqref{equation:protoms:angpot} and \eqref{equation:protoms:ubpot}). This equation is not used to scale the dihedral parameters, as the functional form of the dihedral potential is more complicated. Rather than scale the dihedral parameters, ProtoMS uses \(\lambda\) to scale the total energy of each dihedral;
\begin{equation}\label{equation:protoms:dihmix}
\begin{split}U_{dihedral}(\phi)_\lambda = (1.0-\lambda)\times U_{dihedral}(\phi)_0 + \lambda \times U_{dihedral}(\phi)_1,\end{split}
\end{equation}
where \(U_{dihedral}(\phi)_0\) is the dihedral energy using the parameters for \(\lambda=0.0\), \(U_{dihedral}(\phi)_1\) is the dihedral energy using the parameters for \(\lambda=1.0\), and \(U_{dihedral}(\phi)_\lambda\) is the scaled dihedral energy at that value of \(\lambda\).

Any and all parts of the forcefield can be scaled. This includes all of the forcefield parameters of any solutes, all of the parameters of any proteins, and all parameters of any solvent molecules. While this is very useful, and enables perturbations of any and all parts of the system, there are many cases where just changing the forcefield parameters is not sufficient to smoothly morph from one system into the other. There are many cases where the geometry of the molecules needs to be changed with \(\lambda\). Fortunately ProtoMS provides this capability for solute molecules. Any internal coordinates that are part of the z-matrix of a solute molecule may perturbed with \(\lambda\). Geometry variations are a powerful tool as they allow for very complicated, yet very smooth transitions between two systems to be described. A good example of such a transition is the annihilation of the hydrogen atoms as a methyl group is morphed into a single hydrogen.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{alchemy}.png}
\caption{Geometry variations allow for a smoother transition between two systems, for example here a methyl group is smoothly converted into a hydrogen.}\label{\detokenize{protoms:id4}}\end{figure}

As well as enabling smooth transitions between systems, geometry variations may be used to calculate potentials of mean force along structural coordinates.

\index{Dual Topology}\ignorespaces 
\sphinxstylestrong{Dual Topology Calculations}

A dual topology method to calculate free energy changes is also available in ProtoMS. In the single topology method force field terms were linearly interpolated so that they match the force field parameters suitable for particular molecule at either end of the perturbation (\(\lambda\) 0.0 or \(\lambda\) 1.0). As two molecules often differ not only in their force field terms but also their geometry, it is often necessary to modify the internal coordinates as well. This is relatively easy In simple cases (morphing a methyl group into a hydrogen group) but for larger, complex, perturbations this is often cumbersome if not impossible. In the dual topology method no geometry variations are attempted. However, the interaction energy of a pair of solutes with their surroundings (solvent, protein, other solutes), is gradually turned on or off with the coupling parameter.
\begin{equation}\label{equation:protoms:doubletopu}
\begin{split}U(\lambda) = U_{0} + \lambda U(S_{2}) + (1 - \lambda) U(S_{1})\end{split}
\end{equation}
Equation \eqref{equation:protoms:doubletopu} thus shows that at any given value of \(\lambda\), the total energy of the system consists in a term \(U_{0}\) that is independent of the perturbation and a term \(U(S_{2})\) and \(U(S_{1})\) which is a function of the intermolecular energies of the pair of solutes for which a free energy change is to be calculated.

A dual topology setup is simpler and more generally applicable than a single topology setup. However dual topology approaches suffer from a number of technical difficulties which are mainly related to the fact that if a solute does not have any intermolecular interaction with its surroundings, it can drift anywhere in the simulation box. This usually causes the free energy difference to converge very very slowly (in practice not at all). To overcome these difficulties, the dual topology technique implemented in ProtoMS constrains a pair of solutes to stay together by the introduction of dummy bond between the center of geometry of the two solutes. As this does not prove to be sufficient to avoid convergence issues, a soft-core non bonded energy function is also implemented. In essence, the function that computes the intermolecular energy of the solutes is modified such that when a solute is not fully interacting with its surroundings, it’s Lennard-Jones and couloumbic energies are softened such that atomic overlaps do not result in very large, positive, energies. The solute is effectively ‘softer’. There are three soft-core versions implemented in ProtoMS. The original implementation in ProtoMS for a solute
that is being turned off is described by equation \eqref{equation:protoms:uljsoftmod}.
\begin{equation}\label{equation:protoms:uljsoftmod}
\begin{split}U_{non bonded,\lambda}= (1-\lambda) 4{\epsilon}_{ij} \left[ \left( \frac{ \sigma_{ij}^{12} }{ ( \lambda \delta \sigma_{ij} + r_{ij}^{2} )^{6}} \right) - \left( \frac{ \sigma_{ij}^{6} }{ (\lambda \delta \sigma_{iJ}  + r_{ij}^{2})^{3} } \right) \right] +  \frac{(1-\lambda)^{n} q_{i}q_{j}} {4\pi{\epsilon}_{0}\sqrt{(\lambda +  r_{ij}^{2})}}\end{split}
\end{equation}
where the parameters n and \(\delta\) control the softness of the Coulombic and Lennard-Jones interactions respectively.

An alternative that has been useful in some applications is described by equation \eqref{equation:protoms:uljsoftmod2}
\begin{equation}\label{equation:protoms:uljsoftmod2}
\begin{split}U_{non bonded,\lambda}= (1-\lambda) 4{\epsilon}_{ij} \left[  \left( \frac{ \sigma_{ij}^{12} }{ ( \lambda \delta \sigma_{ij}^6 + r_{ij}^{6} )^{2}} \right) -  \left( \frac{ \sigma_{ij}^{6} }{ \lambda \delta \sigma_{iJ}^6  + r_{ij}^{6} } \right) \right] +  \frac{(1-\lambda)^{n} q_{i}q_{j}} {4\pi{\epsilon}_{0} \left [ \lambda \delta_c +  r_{ij}^{6} \right ]^{1/6}}\end{split}
\end{equation}
with an additional softness parameter \(\delta_c\) for the Coulombic interactions.

Third, the soft-core implementation in the latest version of the Amber package is available and is described by equation \eqref{equation:protoms:uljsoftmod3}
\begin{equation}\label{equation:protoms:uljsoftmod3}
\begin{split}U_{non bonded,\lambda}= (1-\lambda) 4{\epsilon}_{ij} \left[ \left( \frac{ \sigma_{ij}^{12} }{ ( \lambda \delta \sigma_{ij}^6 + r_{ij}^{6} )^{2}} \right) - \left( \frac{ \sigma_{ij}^{6} }{ \lambda \delta \sigma_{iJ}^6 + r_{ij}^{6} } \right) \right] +  \frac{(1-\lambda)^{n} q_{i}q_{j}} {4\pi{\epsilon}_{0} \sqrt{( \lambda \delta_c +  r_{ij}^{2})}}\end{split}
\end{equation}

\section{Generic Moves}
\label{\detokenize{protoms:generic-moves}}\label{\detokenize{protoms:moves}}
ProtoMS conducts a simulation by performing a sequence of moves on the system. The following moves are currently implemented
\begin{itemize}
\item {} 
\sphinxstylestrong{Residue moves} Standard Monte Carlo (MC) moves on protein residues.

\item {} 
\sphinxstylestrong{Solute moves} Standard MC moves on solute molecules.

\item {} 
\sphinxstylestrong{Solvent moves} Standard MC moves on solvent molecule.

\item {} 
\sphinxstylestrong{Volume moves} Monte Carlo moves that change the volume of the system. These are used to run constant pressure simulations.

\item {} 
\sphinxstylestrong{GCSolute moves} Standard MC moves on GCsolute molecules.

\item {} 
\sphinxstylestrong{Insertion moves} MC moves which selects a GCsolute with a \(\theta\) value of 0 and turns it to 1

\item {} 
\sphinxstylestrong{Deletion moves} MC moves which selects a GCsolute with a \(\theta\) value of 1 and turns it to 0

\item {} 
\sphinxstylestrong{Theta moves} MC moves which sample the value of \(\theta\) on a GCsolute molecule

\item {} 
\sphinxstylestrong{Sample moves} MC moves which sample the value of \(\theta\) on a GCsolute molecule whilst applying a biasing potential \(\lambda\)-moves Monte Carlo moves that change \(\lambda\). These may be used to perform umbrella sampling free energy simulations.

\item {} 
\sphinxstylestrong{Dual potential moves} Works only with implicit solvent simulations. Allows to sample rapidly configurations with a crude potential but correct for errors with a specific acceptance test.

\end{itemize}

\index{Residue Moves}\ignorespaces 
\sphinxstylestrong{Residue Moves}
A residue move is a Monte Carlo move on a single protein residue. Obviously, for a residue move to be be performed, at least one protein that has flexible residues must be loaded. Each residue move comprises the following steps
\begin{enumerate}
\item {} 
A protein is picked randomly from the set of proteins that have flexible residues. Note that each protein is weighted equally, so each protein has an equal chance of being chosen, regardless of how many flexible residues it contains. This behaviour is likely to change in future versions of the code, as ideally the probability of choosing to move a protein should be proportional to the number of flexible residues.

\item {} 
One of the flexible residues within the protein is chosen randomly from the set of all flexible residues in the protein. Again, there is no weighting of residues, so each flexible residue has an even chance of being chosen, despite the size of each residue.

\item {} 
If the backbone of this residue is flexible, then a random number between 1 and 3 is generated. If the random number is equal to 1, then only a backbone move on the residue will be attempted. If the random number is equal to 2 then only a sidechain move will be attempted, where all of the flexible internals of the residue are moved. If the random number is equal to 3 then a backbone and sidechain move are attempted simultaneously. If the backbone of this residue is fixed, then only a sidechain move is attempted.

\item {} 
The change in energy that results from this move is evaluated, and then tested according to the Metropolis criterion to decide whether or not to accept the move.

\item {} 
If the move is accepted, then the new configuration of the residue is saved. If the move was rejected then the original configuration of the residue is restored.

\end{enumerate}

You can change the flexibility of any residue in any protein by using the fixbackbone and fixresidues commands described in section {\hyperref[\detokenize{protoms:misccmd}]{\sphinxcrossref{\DUrole{std,std-ref}{Miscellaneous}}}}. All residues of all proteins are flexible by default, and have flexible backbones. Note that the backbone move is still experimental and not thouroughly tested. I recommend that you fix the backbone of all residues for production simulations. You control the maximum amounts that the residue moves via the residue template (see {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}). The actual amount that a residue moves by will be based on random values generated within the limits of the maximum amounts set in the residue template, e.g. if the maximum change of an angle was \(5.0^\circ\) , then the angle will be changed by a random value generated evenly between \(-5.0^\circ\) and \(+5.0^\circ\).

\index{Solute Moves}\ignorespaces 
\sphinxstylestrong{Solute Moves}
A solute move is a Monte Carlo move on a single solute molecule. Obviously, for a solute move to be performed, at least one solute molecule must be loaded. Each solute move comprises the following steps
\begin{enumerate}
\item {} 
A solute is picked randomly from the set of loaded solutes. Each solute is weighted equally, regardless of its size or numbers of degrees of freedom.

\item {} 
One of the residues is chosen at random within the solute. Again, each residue is weighted equally, regard- less of its size.

\item {} 
All of the flexible internals of this residue are changed, and the whole solute molecule is randomly translated, and rotated around its center of geometry.

\item {} 
The change in energy associated with this move is evaluated and then tested via the Metropolis criterion to decide whether or not to accept the move.

\item {} 
If the move is accepted then the new configuration of the solute is saved. If the move was rejected then the original configuration is restored. You can control the maximum amounts that the solute moves via the solute template (see {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}).

\end{enumerate}

\index{Solvent Moves}\ignorespaces 
\sphinxstylestrong{Solvent Moves}

A solvent move is a Monte Carlo move on a single solvent molecule. Obviously, for a solvent move to be performed, at least one solvent molecule must be loaded. Each solvent move comprises the following steps
\begin{enumerate}
\item {} 
A solvent molecule is randomly chosen from the set of loaded solvent molecules. If preferential sampling is turned on (see {\hyperref[\detokenize{protoms:parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Simulation parameters}}}}), then the solvent molecules closest to the preferred solute have a relatively higher weight, so will be more likely to be chosen. If preferential sampling is off, then each solvent is weighted equally, regardless of its relative size or proximity to a solute.

\item {} 
The solvent molecule is randomly translated and rotated around its center of geometry.

\item {} 
The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion if preferential sampling was turned off, or via a biased Monte Carlo test if preferential sampling were turned on.

\item {} 
If the move was accepted then the new solvent configuration is saved, otherwise the original configuration is restored.

\end{enumerate}

You can control the maximum amounts that the solvent is translated and rotated by by editing its solvent template (see {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}).

\index{Volume Moves}\ignorespaces 
\sphinxstylestrong{Volume Moves}

A volume move is a Monte Carlo move that changes the volume of the system. This is needed to be able to perform Monte Carlo simulations at constant pressure (i.e. using the NPT ensemble). For a volume move to be performed you need to have loaded a box of solvent molecules, and be running using periodic boundary conditions. A volume move is comprised of the following steps
\begin{enumerate}
\item {} 
A random change in volume is chosen within the range set via the maxvolchange command (see {\hyperref[\detokenize{protoms:parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Simulation parameters}}}}).

\item {} 
The volume of the system is changed by this amount by scaling all of the coordinates evenly from the center of the simulation box.

\item {} 
The change in energy associated with this change in volume is evaluated and used to decide whether or not to accept this move via the constant pressure Monte Carlo test, for the system pressure set via the pressure command (see {\hyperref[\detokenize{protoms:parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Simulation parameters}}}}).

\item {} 
If the move is accepted then the new system configuration is saved, otherwise the original system configuration is restored.

\end{enumerate}

\index{GCSolute Moves}\ignorespaces 
\sphinxstylestrong{GCsolute Moves}

A GCsolute move is a Monte Carlo move on a single Gcsolute molecule. Each GCsolute move comprises the following steps
\begin{enumerate}
\item {} 
A GCsolute molecule is randomly chosen from the set of loaded GCsolute molecules.  The value of \(\theta\) is examined; if it is set to 0 then another is chosen until the examined \(\theta\) value is 1.  If no GCsolutes with \(\theta=1\) are available then the GCsolute move is counted as rejected.

\item {} 
The GCsolute molecule is randomly translated and rotated around its center of geometry. If it attempts to leave the confines of its predefined cubic region then it experiences a huge energetic penalty, ensuring that the Metropolis move is rejected.

\item {} 
The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.

\item {} 
If the move was accepted then the new GCsolute configuration is saved, otherwise the original configuration is restored.

\end{enumerate}

You can control the maximum amounts that the GCsolute is translated and rotated by by editing its template (see {\hyperref[\detokenize{protoms:temref}]{\sphinxcrossref{\DUrole{std,std-ref}{Templates}}}}). If performing a jaws simulation then a GCsolute is chosen at random in 1. without examining its \(\theta\) value.

\index{Insertion Moves}\ignorespaces 
\sphinxstylestrong{Insertion Moves}

An insertion move is a Monte Carlo move on a single GCsolute molecule, whereby the \(\theta\) value of a GCsolute is turned from 0 to 1. Each insertion move comprises the following steps;
\begin{enumerate}
\item {} 
A GCsolute molecule is randomly chosen from the set of loaded GCsolute molecules. The value of \(\theta\) is examined; if it is set to 1 then another is chosen until the examined \(\theta\) value is 0

\item {} 
The GCsolute molecule is given a random position and orientation within the GCMC region.

\item {} 
The value of \(\theta\) for that GCsolute molecule is set to 1, and the new energy associated with this value of \(\theta\) is calculated

\item {} 
The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
If the move was accepted then the new value of \(\theta\) for that GCsolute molecule is saved, otherwise the original value of 0 is restored.

\end{enumerate}

\index{Deletion Moves}\ignorespaces 
\sphinxstylestrong{Deletion Moves}

A deletion move is a Monte Carlo move on a single GCsolute molecule, whereby the \(\theta\) value of a GCsolute is turned from 1 to 0. Each deletion move comprises the following steps
\begin{enumerate}
\item {} 
A GCsolute molecule is randomly chosen from the set of loaded GCsolute molecules. The value of \(\theta\) is examined; if it is set to 0 then another is chosen until the examined \(\theta\) value is 1. If no GCsolutes with \(\theta=1\) are available then the deletion move is counted as rejected.

\item {} 
The value of \(\theta\) for that GCsolute molecule is set to 0, and the new energy associated with this value of \(\theta\) is calculated

\item {} 
The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.

\item {} 
If the move was accepted then the new value of \(\theta\) for that GCsolute molecule is saved, otherwise the original value of 1 is restored.

\end{enumerate}

\index{Theta Moves}\ignorespaces 
\sphinxstylestrong{Theta Moves}

A theta move is a Monte Carlo move on a single GCsolute molecule, whereby the \(\theta\) value of a GCsolute is sampled. Each theta move comprises the following steps
\begin{enumerate}
\item {} 
A GCsolute molecule is randomly chosen from the set of loaded GCsolute molecules

\item {} 
The value of \(\theta\) for that GCsolute molecule is randomly changed, and the new energy associated with this value of \(\theta\) is calculated

\item {} 
The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.

\item {} 
If the move was accepted then the new value of \(\theta\) for that GCsolute molecule is saved, otherwise the original value of \(\theta\) is restored.

\end{enumerate}

\index{Sample Moves}\ignorespaces 
\sphinxstylestrong{Sample Moves}

A sample move is a Monte Carlo move on a single GCsolute molecule, whereby the \(\theta\) value of a GCsolute is sampled whilst applying a biasing potential, jbias. Each sample move comprises the following steps
\begin{enumerate}
\item {} 
A GCsolute molecule is randomly chosen from the set of loaded GCsolute molecules (typically only one GCsolute molecule is studied in a sample move)

\item {} 
The biasing potential is added onto the value of ieold for that molecule, based upon the volume of the restraint and the applied jbias

\item {} 
The value of \(\theta\) for that GCsolute molecule is randomly changed, and the new energy associated with this value of \(\theta\) is found

\item {} 
The biasing potential is added onto the value of ienew for that molecule, based upon the volume of the restraint and the applied jbias

\item {} 
The change in energy associated with this move is evaluated and used to decide whether or not to accept this move via the Metropolis criterion.

\item {} 
If the move was accepted then the new value of \(\theta\) for that GCsolute molecule is saved, otherwise the original value of \(\theta\) is restored.

\end{enumerate}

\index{Move Probabilities}\ignorespaces 
\sphinxstylestrong{Relative Move Probabilities}

You can specify which moves should be run by passing arguments to the simulate and equilibrate commands (see {\hyperref[\detokenize{protoms:runcmd}]{\sphinxcrossref{\DUrole{std,std-ref}{Running a Simulation}}}}). You can use these commands to assign a weight to each type of move, e.g. 100 for solvent moves, 10 for protein moves, 1 for solute moves and 0 for volume move. The type of move chosen for each step of the simulation is generated randomly based on these set relative weights. These weights mean that on average, in 111 moves, 100 of these moves will be solvent moves, 10 of these moves will be protein moves, 1 of these moves will be solute moves and none of the moves will be volume moves (e.g. no volume moves will be performed). Note that you need to perform some volume moves if you wish to sample from the NPT ensemble!


\chapter{Executing ProtoMS}
\label{\detokenize{protoms:executing-protoms}}
ProtoMS is a simple program that may be used from the command line. Once you have compiled it you should find it in the top directory (it is called simply protoms3). If you run the program you should see that it prints out some information about the program and license, then it complains that nothing has been loaded so it closes down. The interface to ProtoMS has been designed to allow easy integration of ProtoMS with scripts, and to enable simple use from a command file. A ProtoMS input consists of a set of commands and values, e.g. the command \sphinxcode{\sphinxupquote{temperature}} could have the value \sphinxstyleemphasis{25.0} . This would set the simulation temperature to \(25^\circ\) C. The input is passed to ProtoMS via a command file. The above command could thus be input by setting by placing the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperature} \PYG{l+m+mf}{25.0}
\end{sphinxVerbatim}

into a file and have ProtoMS read commands from that file. You specify the command file by passing it to ProtoMS on the command line, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{protoms3} \PYG{n}{mycmdfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

Note that ProtoMS is insensitive to whether commands, variables or contents of files are uppercase or lowercase, so you are free to mix and match capitals and small case wherever you want. The only exception to this is in the specification of filenames, where your operating system may care about case. As an example, depending on your operating system, ProtoMS may fail when the file containing the commands is named in upper case letters.

For replica exchange or ensemble type calculations, you have to execute ProtoMS through an appropriate MPI wrapper, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{16} \PYG{n}{protoms3} \PYG{n}{mycmdfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

\index{Output}\index{Streams}\ignorespaces 

\section{File output}
\label{\detokenize{protoms:file-output}}\label{\detokenize{protoms:index-27}}
If you run ProtoMS from the command line you should see that it prints out a lot of information to the screen (on Unix called standard output, STDOUT). If you look closely at the output you should see that each line of output is preceeded by a tag, such as ‘HEADER’ or ‘INFO’. ProtoMS uses streams to output data, and these tags state which stream the line of data came from. Thus the information at the top of the output that gives the license and version details has been printed to the ‘HEADER’ stream, while the lines stating that ProtoMS is closing down because nothing has been loaded have gone to the ‘FATAL’ stream. ProtoMS uses the following streams
\begin{itemize}
\item {} 
\sphinxstylestrong{HEADER} Used to print the program header.

\item {} 
\sphinxstylestrong{INFO} Used to print general information.

\item {} 
\sphinxstylestrong{WARNING} Warnings are printed to this stream. ProtoMS will generally try to continue if it detects a problem, and will print out information about any errors to the WARNING stream. It is up to you to check the WARNING stream to ensure that your simulation is working correctly.

\item {} 
\sphinxstylestrong{FATAL} If an error is so serious that ProtoMS is forced to shutdown then it will first try to tell you what the problem is by sending text to the FATAL stream.

\item {} 
\sphinxstylestrong{RESTART} The restart file is written to the RESTART stream.

\item {} 
\sphinxstylestrong{PDB} Any output PDB files are written to the PDB stream.

\item {} 
\sphinxstylestrong{MOVE} Information about moves are printed to this stream, e.g. whether or not a move was accepted, and how much progress has been made during the simulation.

\item {} 
\sphinxstylestrong{ENERGY} Information about the energy components for the moves are printed to this stream, e.g. the bond energy of solute 1, or the coulomb energy between protein 1 and the solvent.

\item {} 
\sphinxstylestrong{RESULTS} The results of the simulation are written to the RESULTS stream. These include the free energy averages and energy component averages.

\item {} 
\sphinxstylestrong{DETAIL} The DETAIL stream contains lots of additional detail about the setup of the simulation. This can be very verbose, as it includes complete detail of the connectivity of the system and the loaded forcefield. The DETAIL stream is useful when you are setting a simulation up, though should be turned off when you are running production.

\item {} 
\sphinxstylestrong{SPENERGY} The SPENERGY stream is used to report the results of single point energy calculations.

\item {} 
\sphinxstylestrong{ACCEPT} The ACCEPT stream is used to print information about the numbers of attempted and accepted moves.

\item {} 
\sphinxstylestrong{RETI} The RETI stream is used to report the energies needed by the RETI free energy method.

\item {} 
\sphinxstylestrong{DEBUG} The DEBUG stream is used by the developers to report debugging information during a ProtoMS run. This stream is only active if ‘debug’ is set to true.

\end{itemize}

These streams may be switched on or off, directed to STDOUT, directed to STDERR or directed to a file. You can do this by using the commands

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{streamSTREAM} \PYG{n}{STDOUT}

\PYG{n}{streamSTREAM} \PYG{n}{STDERR}

\PYG{n}{streamSTREAM} \PYG{n}{off}

\PYG{n}{streamSTREAM} \PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n}{file}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

where \sphinxtitleref{STREAM} is the name of the stream that you wish to direct (e.g. streamINFO). ProtoMS is insensitive to case, so you could use the command

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{streaminfo} \PYG{n}{stdout}
\end{sphinxVerbatim}

However, your operating system may be sensitive to case so you should ensure that you use the correct case for filenames.

You are free to direct multiple streams into a single file, or to turn undesired streams off. If a stream is output to STDOUT or STDERR then the name of the stream is prepended to the start of each line. The name is not attached if the stream is directed into a file. The WARNING and FATAL streams are special as unlike the other
streams, these two cannot be turned off. These two streams will be directed to STDERR if they have not been directed elsewhere.

By default, the HEADER, INFO, MOVE and RESULTS streams are directed to STDOUT, the WARNING and FATAL streams are directed to STDERR, and the remaining streams are switched off. Bear this in mind if you think that you should be getting output and you are not - make sure that the stream that contains your output is directed to something!

The streamSTREAM command is used to specify the direction of the stream at the start of the simulation. It is possible to redirect streams while the simulation is running. This is slightly more complicated than then streamSTREAM command, and is described in section {\hyperref[\detokenize{protoms:misccmd}]{\sphinxcrossref{\DUrole{std,std-ref}{Miscellaneous}}}}.

By default ProtoMS overwrites the files specified by the streamSTREAM command. If you want to append to already exisiting files, for instance if you are restarting a simulation, you have to add the option

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{appendstreams} \PYG{n}{on}
\end{sphinxVerbatim}

This option will turn on append mode for all streams, except the \sphinxstylestrong{RESTART} stream that never will be appended.


\section{Simulation parameters}
\label{\detokenize{protoms:simulation-parameters}}\label{\detokenize{protoms:parameters}}
There are many commands to set parameters that you can use to control your simulation. To make it easier to search for those relevant to your calculations, these will be divided in several subsections.

In the subsections below, unless otherwise specified:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{locical}} stands for \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}, \sphinxstyleemphasis{yes} or \sphinxstyleemphasis{no}, \sphinxstyleemphasis{on} or \sphinxstyleemphasis{off} (depending on your personal preference)

\item {} 
\sphinxcode{\sphinxupquote{integer}} or \sphinxcode{\sphinxupquote{int}} stands for any integer number

\item {} 
\sphinxcode{\sphinxupquote{float}} stands for any floating point number

\item {} 
\sphinxcode{\sphinxupquote{string}} stands for a string of characters

\end{itemize}


\subsection{Parameters for developers}
\label{\detokenize{protoms:parameters-for-developers}}
\index{debug}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-28}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{debug} \PYG{n}{logical}
\end{sphinxVerbatim}

This turns on or off debugging output that may be useful for ProtoMS developers. By default \sphinxcode{\sphinxupquote{debug}} is \sphinxstyleemphasis{off}.

\index{testenergy}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-29}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{testenergy} \PYG{n}{logical}
\end{sphinxVerbatim}

This is used to set whether or not to turn on testing of energies. This is useful if you are developing ProtoMS. By default \sphinxcode{\sphinxupquote{testenergy}} is \sphinxstyleemphasis{off}.


\subsection{General parameters}
\label{\detokenize{protoms:general-parameters}}
\index{prettyprint}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-30}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prettyprint} \PYG{n}{logical}
\end{sphinxVerbatim}

Turn on or off pretty printing. With pretty printing turned on, you will see nice starry boxes drawn highlighting certain parts of the output. By default, \sphinxcode{\sphinxupquote{prettyprint}} is \sphinxstyleemphasis{on}.

\index{dryrun}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-31}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dryrun} \PYG{n}{logical}
\end{sphinxVerbatim}

Whether or not to perform a dry run of the simulation. If this is true then all of the files will be loaded up and your commands parsed. If there are any problems then these will be reported in the WARNING stream. No actual simulation will be run, though any files that would be created may be created. While this option is very useful for testing your commands, it is not perfect and cannot check everything. I thus recommend that you also perform a short version of your simulation before you commit yourself to full production. By default \sphinxcode{\sphinxupquote{dryrun}} is off.

\index{ranseed}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-32}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ranseed} \PYG{n}{integer}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{integer}} is any positive integer. This command is used to set the random number seed to be used by the random number generator. The random number seed can be any positive integer, and you will want to specify a seed if you wish to run reproducable simulations. If you do not specify a random number seed then a seed is generated based on the time and date that the simulation started.

\index{temperature}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-33}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperature} \PYG{n+nb}{float}
\end{sphinxVerbatim}

Use this command to specify the simulation temperature in \sphinxstyleemphasis{Celsius}. By default temperature is 25.0 C.

\index{pdbparam}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-34}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pdbparam} \PYG{n}{logical}
\end{sphinxVerbatim}

Whether or not to automatically detect and use, in the simulation, any chunks which might be included in the input PDB files after REMARK. It is most commonly used to include the fixresidues and fixbackbone commands often found at the beginning of a protein scoop. Any chunks included in pdb files will be applied before any other chunk. By default \sphinxtitleref{pdbparam} is on.

\index{cutoff}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-35}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cutoff} \PYG{n+nb}{float}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{float}} is any positive number. This command is used to set the size of the non-bonded cutoff, in Angstroms, used to truncate the intermolecular non-bonded potentials (see eq \eqref{equation:protoms:intermol1}). By default the non-bonded cutoff is 15A.

\index{feather}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-36}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{feather} \PYG{n+nb}{float}
\end{sphinxVerbatim}

To prevent an abrupt cutoff, the non-bonded energy is scaled quadratically down to zero over the last part of the cutoff (see eq \eqref{equation:protoms:intermol1}). The feather command sets the distance over which this scaling occurs, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{feather} \PYG{l+m+mf}{1.3}
\end{sphinxVerbatim}

sets this feathering to occur over the last 1.3A. The default value of the feather is 0.5A.

\index{cuttype}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-37}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cuttype} \PYG{n}{string}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{string}} is either \sphinxstyleemphasis{residue} or \sphinxstyleemphasis{molecule}. This specifies the type of non-bonded cutting to use; either residue, where the cutoff is between protein residues, solute molecules and solvent molecules, or molecule, where the cutoff is between protein molecules, solutes molecules and solvent molecules. By default the \sphinxcode{\sphinxupquote{cuttype}} is \sphinxstyleemphasis{residue}.

\index{pressure}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-38}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pressure} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command sets the pressure of the system in atmospheres. By setting the pressure to a non-zero value you will be able to perform a simulation in the NPT isothermal-isobaric ensemble. Note that you need to perform volume moves (see {\hyperref[\detokenize{protoms:moves}]{\sphinxcrossref{\DUrole{std,std-ref}{Generic Moves}}}}) to be able to run in the NPT ensemble. By default the pressure is equal to zero, and thus a NPT simulation is not performed.

\index{maxvolchange}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-39}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{maxvolchange} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command sets the maximum change in volume for a volume move in cubic Angstroms. This command only has meaning if an NPT simulation is being performed. By default \sphinxcode{\sphinxupquote{maxvolchange}} is equal to the number of solvent molecules divided by ten.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prefsampling} \PYG{n}{integer}
\end{sphinxVerbatim}

This command is used to turn on preferential sampling of the solvent, and to specify which solute is used to define the center of the preferential sampling sphere. The command

\index{prefsampling}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-40}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prefsampling} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

means that the solvents closest to solute 1 will be moved more frequently than those furthest from solute 1. An optional parameter may be used to change the influence of the sphere, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prefsampling} \PYG{l+m+mi}{1} \PYG{l+m+mf}{100.0}
\end{sphinxVerbatim}

will specify a preferential sampling sphere centered on solute 1, with a parameter of 100.0. The larger the parameter, the more highly focussed the influence of the sphere around the closest solvent molecules. By default the parameter is 200.0, and preferential sampling is turned off.

\index{boundary}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-41}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{boundary} \PYG{n}{none}
\end{sphinxVerbatim}

This turns off any boundary conditions, i.e. the simulation will be performed in vacuum.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{boundary} \PYG{n}{periodic} \PYG{n}{dimx} \PYG{n}{dimy} \PYG{n}{dimz}
\end{sphinxVerbatim}

This turns on periodic boundaries, using a orthorhombic box centered on the origin, with dimensions \sphinxcode{\sphinxupquote{dimx}} A by \sphinxcode{\sphinxupquote{dimy}} A by \sphinxcode{\sphinxupquote{dimz}} A. Note that these dimensions may be modified by any loaded solvent file

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{boundary} \PYG{n}{periodic} \PYG{n}{ox} \PYG{n}{oy} \PYG{n}{oz} \PYG{n}{tx} \PYG{n}{ty} \PYG{n}{tz}
\end{sphinxVerbatim}

This turns on periodic boundaries using an orthorhombic box with the bottom-left-back corner at coordinates (\sphinxcode{\sphinxupquote{ox}} , \sphinxcode{\sphinxupquote{oy}} , \sphinxcode{\sphinxupquote{oz}}) A and the top-right-front corner at (\sphinxcode{\sphinxupquote{tx}} , \sphinxcode{\sphinxupquote{ty}} , \sphinxcode{\sphinxupquote{tz}}) A. Note that these dimensions may be modified by any loaded solvent file.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{boundary} \PYG{n}{cap} \PYG{n}{ox} \PYG{n}{oy} \PYG{n}{oz} \PYG{n}{rad} \PYG{n}{k}
\end{sphinxVerbatim}

This turns on solvent cap boundary conditions. Protein and solute molecules will experience no boundary conditions, while solvent molecules will be restrained within a spherical region of radius rad A, centered at coordinates (\sphinxcode{\sphinxupquote{ox}} , \sphinxcode{\sphinxupquote{oy}} , \sphinxcode{\sphinxupquote{oz}}) A. A half-harmonic restraint with force constant \sphinxcode{\sphinxupquote{k}} kcal.mol-1.A-2 is added to the solvent energy if it moves outside of this sphere.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{boundary} \PYG{n}{solvent}
\end{sphinxVerbatim}

This sets the boundary conditions to whatever is set by the loaded solvent files. If no solvent files are loaded then no boundary conditions are used. This is the default option, and the method of setting boundary conditions via a solvent file is described in section {\hyperref[\detokenize{protoms:solventpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Solvent File}}}}


\subsection{GBSA parameters}
\label{\detokenize{protoms:gbsa-parameters}}
\index{surface}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-42}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{surface} \PYG{n}{quality} \PYG{l+m+mi}{3} \PYG{n}{probe} \PYG{l+m+mf}{1.4}
\end{sphinxVerbatim}

This command will cause surface area calculations to be performed during the simulation. \sphinxcode{\sphinxupquote{quality}} can be set to 1,2,3,4 and will result in increasingly precise surface area calculations. For typical simulations, 3 should be fine and 2 will not give a huge error. \sphinxcode{\sphinxupquote{probe}} is the radius of the probe and should be set to 1.4 if you want to calculate the solvent accessible surface area of water, but can be set to 0 if you want to calculate the van der waals surface area of a molecule.

\index{born}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-43}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{born} \PYG{n}{cut} \PYG{l+m+mi}{20} \PYG{n}{threshold} \PYG{l+m+mf}{0.005} \PYG{n}{proteins}
\end{sphinxVerbatim}

This command will enable Generalised Born energy calculations. Thus to run a full GBSA simulation you should use both the surface and born keywords. cut controls the cutoff distance for the computation of the Born radii. If you work with a medium sized protein scoop of circa 100-150 residues, 20 should be fine but you may want a larger value for simulations of large proteins. threshold controls the number of pairwise terms that are not updated when the effective Born radii must be calculated by the Pairwise descreening approximation. The default value
0.005 appear to be a good tradeoff. Increasing it will make the simulation faster but less accurate. proteins activates the rescaling of the Born radii to compensate for systematic errors of the Pairwise Descreening Approximation in large biomolecules. It should be used only when simulating proteins and then its effectiveness has not been yet
convincingly demonstrated.

\sphinxstyleemphasis{WARNING: These commands are considered to be deprecated.} This means that they are not developed any more and have not been tested extensively with newer features. Dump commands are supported with the \sphinxtitleref{simulate} command and one can do simple MC sampling with GB. However, it is not sure that free energy or the replica-exchange commands work satisfactorily.


\subsection{Temperature replica-exchange parameters}
\label{\detokenize{protoms:temperature-replica-exchange-parameters}}
ProtoMS can perform temperature replica-exchange simulations.

\index{temperaturere}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-44}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperaturere} \PYG{n}{integer} \PYG{n+nb}{float} \PYG{n+nb}{float} \PYG{n+nb}{float}
\end{sphinxVerbatim}

is the command to set a replica exchange simulation between the different temperatures given as floats, where \sphinxcode{\sphinxupquote{float}} is any positive float, and temperatures are given en Celsius. In principle, any desired number of temperature values can be used, and the simulation will require to be runned in as many cores as temperature values are provided. The integer value stands for the frequency at which the exchange between the different temperature values is attempted. Please, note that this value should be a multiple of the frequency of printing output when the dump commands are used (see {\hyperref[\detokenize{protoms:frequent-output-generation}]{\sphinxcrossref{Frequent output generation}}}). If no exchange is desired, the frequency of exchange can simply be set to the total number of moves of the simulation.

As an example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperaturere} \PYG{l+m+mi}{20} \PYG{l+m+mf}{25.0} \PYG{l+m+mf}{30.0} \PYG{l+m+mf}{35.0}
\end{sphinxVerbatim}

corresponds to a simulation which will run at three different temperature windows in parallel, and will attempt swaps between the conformations of different temperature windows each 20 moves.

The temperature replica-exchange command can be used in conjuction with the \sphinxcode{\sphinxupquote{lambdare}} command, see below, to add temperature ladders to different values of \(\lambda\).

\index{solutetempering}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-45}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solutetempering} \PYG{l+m+mf}{25.0} \PYG{n}{bndang} \PYG{l+m+mi}{3} \PYG{n}{dih} \PYG{l+m+mi}{1} \PYG{n}{lj} \PYG{l+m+mi}{3} \PYG{n}{coul} \PYG{l+m+mi}{1} \PYG{n}{solu} \PYG{l+m+mi}{2} \PYG{n}{prot} \PYG{l+m+mi}{2} \PYG{n}{solv} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Turns on replica-exchange with solute tempering (REST). It only works if you have specified temperature replica-exchange (see {\hyperref[\detokenize{protoms:temperature-replica-exchange-parameters}]{\sphinxcrossref{Temperature replica-exchange parameters}}}). In this type of simulation the system is simulated at 25.0 Celsius, or the temperature set with this command, and the temperatures set with the \sphinxcode{\sphinxupquote{temperaturere}} command are used to scale the solute energies. The level of scaling for the different energy components can be set with the rest of the options; \sphinxcode{\sphinxupquote{bndang}} controls the internal bond-angle energy terms, \sphinxcode{\sphinxupquote{dih}} the internal dihedral energy term, \sphinxcode{\sphinxupquote{lj}} the internal van der Waals energy, \sphinxcode{\sphinxupquote{coul}} the internal Coulomb energy, \sphinxcode{\sphinxupquote{solu}} the interaction with other solutes, \sphinxcode{\sphinxupquote{prot}} the interaction with the protein and \sphinxcode{\sphinxupquote{solv}} the interaction with solvent molecules. Each argument can be either 1, 2 or 3. If the argument is 1, the energy is scaled with \(\beta_i/\beta_0\), where \(\beta_i\) is the effective inverse temperature of the replica (set with the \sphinxcode{\sphinxupquote{temperaturre}} command) and \(\beta_0\) is the inverse simulation temperature (set with this command). If the argument is 2, the energy is scaled with \((\beta_i+\beta_0)/2\beta_0\) and if the argument 3 the energy is unscaled.

\index{sameseeds}\ignorespaces 
By default ProtoMS will use different random seeds for each replica in a replica exchange simulation. Setting sameseeds to true will prevent this and all replicas will use the random seed provided in the command file. This is primarily available for backwards compatibility:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sameseeds} \PYG{n}{logical}
\end{sphinxVerbatim}

The value of sameseeds is false by default.


\subsection{Free energy calculation parameters}
\label{\detokenize{protoms:free-energy-calculation-parameters}}
To be able to run a single simulation for a given lambda value, you will need to use the following parameters:

\index{lambda}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-47}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n+nb}{float}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{float}} is a number between 0.0 and 1.0. Specify the value of \(\lambda\). If a single value is given then that is used for \(\lambda\). If three values are given then these are used for \(\lambda\), and \(\lambda\) in the forwards and backwards windows, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.6} \PYG{l+m+mf}{0.4}
\end{sphinxVerbatim}

would set \(\lambda\) for the reference state to 0.5, \(\lambda\) for the forwards perturbed state to 0.6, and \(\lambda\) for the backwards perturbed state to 0.4. By default all values of \(\lambda\) are 0.0.

To run several at several values of \(\lambda\)  in parallel and hence perform your full perturbation at once with ProtoMS, you will need the commands shown below. Running your free energy calculation in this manner, you will be able to attempt exchanges between the configurations of your system at the different lambdas, increasing the probability of convergence.

\index{lambdare}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-48}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lambdare} \PYG{n}{integer} \PYG{n+nb}{float} \PYG{n+nb}{float} \PYG{n+nb}{float}
\end{sphinxVerbatim}

is the command to set a replica exchange calculation between the different \(\lambda\) given as floats, where \sphinxcode{\sphinxupquote{float}} is a number between 0.0 and 1.0. In principle, any desired number of \(\lambda\) values can be used, and the simulation will require to be runned in as many cores as \(\lambda\) values are provided. The integer value stands for the frequency at which the exchange between the different \(\lambda\) values is attempted. Please, note that this value should be a multiple of the frequency of printing output when the dump commands are used (see {\hyperref[\detokenize{protoms:frequent-output-generation}]{\sphinxcrossref{Frequent output generation}}}). If no exchange is desired, the frequency of exchange can simply be set to the total number of moves of the simulation.

As an example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lambdare} \PYG{l+m+mi}{20} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.333} \PYG{l+m+mf}{0.667} \PYG{l+m+mf}{1.000}
\end{sphinxVerbatim}

corresponds to a simulation which will run at four different \(\lambda\) windows in parallel, and will attempt swaps between the conformations of different \(\lambda\) windows each 20 moves.

\sphinxstylestrong{With temperature replica-exchange}

\index{temperatureladder}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-49}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperatureladder} \PYG{k}{lambda} \PYG{n+nb}{float} \PYG{n+nb}{float}
\end{sphinxVerbatim}

is one of the commands required to proceed with a simulation including both temperature and \(\lambda\) replica exchange, where \sphinxcode{\sphinxupquote{float}} is each of the \(\lambda\) values where a temperature ladder is desired. All \(\lambda\) values must be among those included after the \sphinxcode{\sphinxupquote{lambdare}} keyword. In principle, the number of temperature ladders can be as high as the number of \(\lambda\) windows.

As an example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temperatureladder} \PYG{k}{lambda} \PYG{l+m+mf}{0.00} \PYG{l+m+mf}{1.00}
\end{sphinxVerbatim}

corresponds to a simulation which runs the \(\lambda\) windowns 0.00 and 1.00 at all temperatures included after the \sphinxcode{\sphinxupquote{temperaturere}} keyword, as far as the corresponding \sphinxcode{\sphinxupquote{lambdaladder}} command line is set accordingly.

\index{lambdaladder}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-50}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lambdaladder} \PYG{n}{temperature} \PYG{n+nb}{float} \PYG{n+nb}{float}
\end{sphinxVerbatim}

is one of the commands required to proceed with a simulation including both temperature and \(\lambda\) replica exchange, where \sphinxcode{\sphinxupquote{float}} is each of the temperature values where a \(\lambda\) ladder is to be placed. All temperature values must be among those included after the \sphinxcode{\sphinxupquote{temperaturere}} keyword. In principle, the number of lambda ladders can be as high as the number of temperatures in temperaturere. The number of cores must be calculated based on the number of \(\lambda\) ladders and temperature ladders, as well as \(\lambda\) and temperature values per ladder, takind into account the cores shared by each \(\lambda\) ladder with each temperature ladder.

As an example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lambdaladder} \PYG{n}{temperature} \PYG{l+m+mf}{25.0} \PYG{l+m+mf}{35.0}
\end{sphinxVerbatim}

corresponds to a simulation which runs all \(\lambda\) windowns at temperatures 25.0 and 35.0, as far as the corresponding \sphinxcode{\sphinxupquote{temperatureladder}} command line is set accordingly.

All replica-exchange commands together:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lambdare} \PYG{l+m+mi}{20} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.333} \PYG{l+m+mf}{0.667} \PYG{l+m+mf}{1.000}
\PYG{n}{temperaturere} \PYG{l+m+mi}{20} \PYG{l+m+mf}{25.0} \PYG{l+m+mf}{30.0} \PYG{l+m+mf}{35.0}
\PYG{n}{temperatureladder} \PYG{k}{lambda} \PYG{l+m+mf}{0.00} \PYG{l+m+mf}{1.00}
\PYG{n}{lambdaladder} \PYG{n}{temperature} \PYG{l+m+mf}{25.0} \PYG{l+m+mf}{35.0}
\end{sphinxVerbatim}

correspond to a simulation where \(\lambda\) windows 0.000 0.333 0.667 1.000 are simulated at 25.0 and 35.0 Celsius, while at temperature 30.0, only \(\lambda\) windows 0.000 and 1.000 will be simulated.

\sphinxstylestrong{Other free energy commands}

\index{dlambda}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-51}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dlambda} \PYG{n+nb}{float}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{float}} is a number between 0.0 and 1.0 (often of the order of 0.001). This command sets the gradient for a free energy calculation. It is required for thermodynamic integration (TI) to be applied on the simulation results.

\index{printfe}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-52}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{printfe} \PYG{n}{string}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{string}} should be either \sphinxcode{\sphinxupquote{off}}, \sphinxcode{\sphinxupquote{bar}} or \sphinxcode{\sphinxupquote{mbar}}. Whether to print the free energy estimates required to proceed with BAR or MBAR calculations. Take into acount that this estimates will take some time. Your simulations may run faster when this option is set to off (default).

In case dual topology is desired, whether it is for a single or multiple \(\lambda\) simulation, the following parameters must be used:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dualtopologyint} \PYG{n}{integer1} \PYG{n}{integer2} \PYG{n}{synctrans} \PYG{n}{syncrot}
\end{sphinxVerbatim}

This turns on the dual topology method of calculating relative free energies, where \sphinxtitleref{int1} is the perturbed solute at \(\lambda\) = 0.0 and \sphinxtitleref{in2} is the solute at \(\lambda\) = 1.0 . If \sphinxcode{\sphinxupquote{synctrans}} is set, the rigid body translations of the two solutes will be synchronised. If \sphinxcode{\sphinxupquote{syncrot}} is set, the rigid body rotations of the two solutes will also be synchronised.

\index{softcore}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-53}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{softcoreint} \PYG{n}{solute} \PYG{n}{integer}
\end{sphinxVerbatim}

This causes the intermolecular energy of solute integer to be softened. Alternatively, you can write \sphinxcode{\sphinxupquote{all}} instead of the solute index and all solutes will have their non bonded energy softened. The softcore is only supported for solutes. May alternatively be used as below.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{softcoreint} \PYG{n}{solute} \PYG{n}{integer} \PYG{n}{atoms} \PYG{n}{int1} \PYG{n}{int2} \PYG{n}{int3}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

The atoms keyword indicates that the interactions of only a subset of atoms within a solute should have their interactions softened. Whilst int1, int2, e.t.c. provide indices specifying atoms based on their ordering within the solute template. In principle, superior numerical convergence can be achieved by applying softcores to only the smallest subset of atoms required to prevent singularities.

\index{softcoreparams}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-54}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{softcoreparams} \PYG{n}{coul} \PYG{l+m+mi}{1} \PYG{n}{delta} \PYG{l+m+mf}{1.5} \PYG{n}{gb} \PYG{l+m+mi}{0} \PYG{n}{old}
\end{sphinxVerbatim}

This causes the solutes non bonded energy to be softened with a parameter \sphinxstyleemphasis{n} set to 1 and \(\delta\) set to 1.5. (see eq \eqref{equation:protoms:uljsoftmod}). The old keyword selects the original soft-core implementation and can be omitted. If conducting a GBSA simulation, this also causes the GB energy to be softened as well. It is recommended to use the same parameter for the Coulombic and Generalised Born energy. The values listed here, seem to work well for a number of relative binding free energy calculations but actual optimum values of these parameters will depend on your system.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{softcoreparams} \PYG{n}{coul} \PYG{l+m+mi}{1} \PYG{n}{delta} \PYG{l+m+mf}{0.2} \PYG{n}{deltacoul} \PYG{l+m+mf}{2.0} \PYG{n}{soft66}
\end{sphinxVerbatim}

This causes the solutes non bonded energy to be softened with a parameter \sphinxstyleemphasis{n} set to 1, \(\delta\) set to 0.2 and \(\delta_c\) set to 2.0. (see eq \eqref{equation:protoms:uljsoftmod2}). The soft66 keyword selects the second soft-core implementation, eq \eqref{equation:protoms:uljsoftmod2} .

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{softcoreparams} \PYG{n}{coul} \PYG{l+m+mi}{1} \PYG{n}{delta} \PYG{l+m+mf}{0.5} \PYG{n}{deltacoul} \PYG{l+m+mf}{12.0} \PYG{n}{amber}
\end{sphinxVerbatim}

This causes the solutes non bonded energy to be softened with a parameter \sphinxstyleemphasis{n} set to 1, \(\delta\) set to 0.5 and \(\delta_c\)  set to 12.0. (see eq \eqref{equation:protoms:uljsoftmod3} ). The amber keyword selects the third soft-core implementation, eq \eqref{equation:protoms:uljsoftmod3}. The values listed here are the default values in the Amber package.


\subsection{GCMC and JAWS parameters}
\label{\detokenize{protoms:gcmc-and-jaws-parameters}}
\index{gcmc}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-55}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gcmc} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

This command tells ProtoMS that it is to perform a GCMC simulation, and that the starting value of \(\Theta\) all of the GCsolutes is 0.

\index{potential}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-56}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{potential} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set a \sphinxstyleemphasis{B}-value of \sphinxcode{\sphinxupquote{float}} (i.e. -8) for moves in the Grand Canonical Ensemble. The value of \sphinxstyleemphasis{B} can be related to the excess chemical by the following equation:
\begin{equation}\label{equation:protoms:bval}
\begin{split}B = \frac{\mu'}{k_{B}T}+\ln \bar{n}\end{split}
\end{equation}
In the equation, \(\bar{n}\) is the number density of the GCsolute multiplied by the simulation subvolume.

\index{potential}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-57}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{multigcmc} \PYG{n}{integer} \PYG{n+nb}{float} \PYG{n+nb}{float} \PYG{n+nb}{float}
\end{sphinxVerbatim}

is the command to run multiple gcmc simulations in parallel with replica exchange between different B values. The integer value sets how often replica exchange moves are attempted, this should be some multiple of how often results files are written. Each \sphinxcode{\sphinxupquote{float}} is the B value for each replica. In principle, the number of B values is not restricted. The simulation will need to be submited to run in parallel with as many cores as B values. As above the random seed used by each replica can be influenced by the sameseeds command.

\index{origin}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-58}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{originx} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the X origin of the defined GCsolute sampling subvolume to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{originy} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the Y origin of the defined GCsolute sampling subvolume to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{originz} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the Z origin of the defined GCsolute sampling subvolume to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the distance along the X coordinate from originx to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the distance along the Y coordinate from originy to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the distance along the Z coordinate from originz to be the specified \sphinxcode{\sphinxupquote{float}}

Alternatively to the origin, the position of the box may be set using its center:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{centerx} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the X center of the defined GCsolute sampling subvolume to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{centery} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the Y center of the defined GCsolute sampling subvolume to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{centerz} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the Z center of the defined GCsolute sampling subvolume to be 9

A different, equally valid expression for the distance or length of the box is the keyword \sphinxtitleref{len?}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lenx} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the distance along the X coordinate from originx to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{leny} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the distance along the Y coordinate from originy to be the specified \sphinxcode{\sphinxupquote{float}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lenz} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the distance along the Z coordinate from originz to be the specified \sphinxcode{\sphinxupquote{float}}

\index{jaws1}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-59}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jaws1} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

This command tells ProtoMS that it is to perform a JAWS stage one simulation, and that the starting value of \(\theta\) all of the GCsolutes is 0.

\index{thres}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-60}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{thres} \PYG{l+m+mf}{0.95}
\end{sphinxVerbatim}

This command will set the \(\theta\) threshold for defining whether a molecule is \sphinxstyleemphasis{on} in the first stage of the JAWS method to be 0.95 (default)

Note here that, in order to run a JAWS stage 1 calculation, you will also need to include softcores. The parameters to do this can be found among the {\hyperref[\detokenize{protoms:free-energy-calculation-parameters}]{\sphinxcrossref{Free energy calculation parameters}}}.

\index{jaws2}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-61}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jaws2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

This command tells ProtoMS that it is to perform a JAWS stage two simulation, and that the starting value of \(\theta\) all of the GCsolutes is 1.

\index{jbias}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-62}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jbias} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This command will set the value of the biasing potential in the second stage of the JAWS algorithm to be \sphinxcode{\sphinxupquote{float}}, in kcal/mol (i.e. 14).


\section{Specifying input files}
\label{\detokenize{protoms:specifying-input-files}}\label{\detokenize{protoms:incmd}}
As well as controlling the simulation, commands are also used to specify the names of the input files that describe the system and forcefield for the simulation. These input files are specified using the following commands

\index{protein, command}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-63}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{proteinN} \PYG{n}{filename}
\end{sphinxVerbatim}

Specifies the name of the Nth protein file, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{protein1} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}

specifies that protein 1 should be loaded from the file protein.pdb. Note that proteins must be numbered sequentially from 1 to MAXPROTEINS. The format of a protein file is described in {\hyperref[\detokenize{protoms:protpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Protein File}}}}.

\index{solute, command}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-64}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{soluteN} \PYG{n}{filename}
\end{sphinxVerbatim}

specifies the name of the Nth solute file. Note that the solutes must be numbered sequentially from 1 to MAXSOLUTES. The format of a solute file is described in section {\hyperref[\detokenize{protoms:solpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Solute File}}}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solventN} \PYG{n}{filename}
\end{sphinxVerbatim}

specifies the name of the Nth solvent file. Unlike the protein and solute files, the solvent file may contain multiple solvent molecules, though the total number of solvent molecules cannot exceed MAXSOLVENTS. The format of a solvent file is described in section {\hyperref[\detokenize{protoms:solventpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Solvent File}}}}.

\index{grand}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-65}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grandN} \PYG{n}{filename}
\end{sphinxVerbatim}

specifies the name of the Nth GCsolute file. Unlike the protein and solute files, the GCsolute file may contain multiple GCsolute molecules, though the total number of GCsolute molecules cannot exceed MAXSOLVENTS. The format of a GCsolute file is described in section {\hyperref[\detokenize{protoms:gcpdb}]{\sphinxcrossref{\DUrole{std,std-ref}{GCsolute File}}}}.

\index{parfile}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-66}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parfile} \PYG{n}{filename}
\end{sphinxVerbatim}

Specify the name of a forcefield parameter file. You can specify as many parameter files as you wish. The list of parameter files is read from top to bottom, such that if any paramater files contain contradictory information, the last parameters read by ProtoMS are used. The format of the parameter file is described in section {\hyperref[\detokenize{protoms:parfil}]{\sphinxcrossref{\DUrole{std,std-ref}{Parameter / Forcefield Files}}}} .


\section{Running a Simulation}
\label{\detokenize{protoms:running-a-simulation}}\label{\detokenize{protoms:runcmd}}
\index{chunk}\ignorespaces 
There are two main keywords related to running a simulation. These are \sphinxtitleref{chunk} and \sphinxtitleref{dump}. All individual actions (commands which ProtoMS should perform only as it is prompted to do so) are handled with \sphinxtitleref{chunk} lines. Actions which ProtoMS should perform with a certain frequency \sphinxstyleemphasis{while} the simulation is running, are handled with \sphinxtitleref{dump} lines. We can start by talking about chunks.

A simulation can be run as a sequence of chunks. Different things may be accomplished in each chunk, e.g. running some steps of equilibration, printing the protein coordinates to a PDB or redirecting a stream to a new file. Chunks may be mixed and matched, and you can run as many chunks as you desire within a single simulation. You specify a chunk using the command

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{command}
\end{sphinxVerbatim}

Chunks are executed in the order they appear in the command file.


\subsection{Equilibration and Production}
\label{\detokenize{protoms:equilibration-and-production}}
The meat of a simulation is equilibration and production. In ProtoMS equilibration is defined as sampling without the collection of free energy or energy averages, while production is sampling with the collection of free energy and energy averages. Equilibration and production are specified using the equilibrate and simulate chunks, e.g.

\index{equilibrate}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-68}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{equilibrate} \PYG{l+m+mi}{50}
\end{sphinxVerbatim}

performs 50 steps of equilibration.

\index{simulate}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-69}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{simulate} \PYG{l+m+mi}{1000}
\end{sphinxVerbatim}

performs 1000 steps of production.

Additional options may be passed to these two chunks to control the probability of different types of move and the frequency of printing out move and energy details to the MOVE and ENERGY streams. These options are

\index{printmove}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-70}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{printmove}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Print move and energy information every N moves.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{protein}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of protein moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solute}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of solute moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solvent}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of solvent moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gcsolute}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of gcsolute moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{insertion}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of insertion moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{deletion}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of deletion moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{theta}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of GCsolute theta moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of GCsolute sample moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{volume}\PYG{o}{=}\PYG{n}{N}
\end{sphinxVerbatim}

Set the relative probability of volume moves to N.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{newprob}
\end{sphinxVerbatim}

Reset relative move probabilities to zero.

Note that succeeding equilibration or production chunks inherit the move probabilities and printing frequency of preceeding simulation or equilibration chunks. I thus recommend that you use the newprob option to reset the move probabilities for each equilibration or production chunk you run.

The following examples illustrate the use of these options;

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{newprob} \PYG{n}{equilibrate} \PYG{l+m+mi}{500} \PYG{n}{printmove}\PYG{o}{=}\PYG{l+m+mi}{10} \PYG{n}{protein}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{solvent}\PYG{o}{=}\PYG{l+m+mi}{1000}
\end{sphinxVerbatim}

Perform 500 steps of equilibration, printing move and energy information every 10 moves, making on average 1 protein move for every 1000 solvent moves (and performing no other types of move).

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{equilibrate} \PYG{l+m+mi}{100} \PYG{n}{solute}\PYG{o}{=}\PYG{l+m+mi}{500}
\end{sphinxVerbatim}

Perform 100 steps of equilibration. Because this chunk will inherit from the previous chunk, the move and energy information will still be printed every 10 moves, and still, on average 1 protein move will be made every 1000 solvent moves. However this line has added that on average 500 solute moves should be made for every 1000 solvent moves, thus the probability of a protein move is now 1 in 1501, the probablity of a solute move is 500 in 1501, and the probability of a solvent move is 1000 in 1501.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{simulate} \PYG{l+m+mi}{500} \PYG{n}{printmove}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{newprob} \PYG{n}{volume}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{solvent}\PYG{o}{=}\PYG{l+m+mi}{300}
\end{sphinxVerbatim}

Now perform 500 steps of production, printing move and energy information every move, performing no protein moves, and 1 volume move for every 300 solvent moves.

A couple of \sphinxstyleemphasis{simulate-like} commands are specifically related to GBSA simulations.

\index{splitgbsasimulate}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-71}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{splitgbsasimulate} \PYG{l+m+mi}{100} \PYG{l+m+mi}{10} \PYG{n}{solute}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{protein}\PYG{o}{=}\PYG{l+m+mi}{9}
\end{sphinxVerbatim}

The above command should only be used if you are doing an implicit solvent simulation (e.g, you turned on the surface and born keywords). This will cause to run 10 moves with a crude GBSA potential and then perform an acceptance test based on the difference of energies between the crude GBSA potential and the GBSA potential you set with the cutoff, born and surface keywords. This will be repeated 100 times. Here the move probabilities were set to 1 and 9 for solute and protein, but could be other figures. After this keyword has been used it is advised to use the following keyword.

\sphinxstyleemphasis{WARNING: this command is deprecated.} For instance, it does not support the dump commands

\index{resetgb}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-72}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{resetgb}
\end{sphinxVerbatim}

This will cause the total energy of the system to be calculated fully and the Born radii to be correctly updated. Periodic usage of this command, along with the previous one, avoids drifts in the total energy of the system.


\subsection{Results and Restarts}
\label{\detokenize{protoms:results-and-restarts}}
As well as controlling the sampling, you can also control the collection and output of results using simulation chunks, and the reading and writing of restart files.

\index{averages}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-73}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{results} \PYG{n}{reset}
\end{sphinxVerbatim}

Reset all averages to zero and start collection of results from scratch.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{results} \PYG{n}{write}
\end{sphinxVerbatim}

Write out the energy and free energy averages to the RESULTS stream. It is probably a good idea to do this a some point before the end of the simulation.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{results} \PYG{n}{write} \PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

Does the same as above, but redirects the RESULTS stream to myfile.txt before the results are written.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{results} \PYG{n}{writeinst} \PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

Does the same as \sphinxtitleref{write} but instead writes instantaneous energies (the energies of the current snapshot) rather than average energies. This can be useful for some analyses.

Note that all the \sphinxtitleref{chunk averages} lines above are equally valid, if \sphinxtitleref{results} is written instead of \sphinxtitleref{averages}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{results} \PYG{n}{write} \PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

\index{restart command}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-74}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restart} \PYG{n}{write}
\end{sphinxVerbatim}

Write a restart file for the current configuration to the RESTART stream.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restart} \PYG{n}{write} \PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

Does the same as above, but redirects the RESTART stream to myfile.txt before the restart file is written.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restart} \PYG{n}{read} \PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

Read in a restart file from the file myfile.txt. The expected behaviour of ProtoMS varies depending on the restart file provided. If the restart file was written from a simulation that DID NOT complete it’s target number of Monte Carlo steps then reading the restart file will cause ProtoMS to attempt to complete the remaining number of required simulation steps. This is ideal for completing simulations that have been inadvertently stopped before completion. This will only work for restart files written by ProtoMS 3.4. To force the simulation step count to start from zero you can edit the restart file and change the value of the entry on the first line to a T. If the restart file was written from a simulation that DID complete it’s target number of Monte Carlo steps then the restart data will simply override the data from the pdb inputs and the simulation step count will start from zero.


\subsection{PDB Output}
\label{\detokenize{protoms:pdb-output}}
\index{pdb command}\ignorespaces 
You can use a simulation chunk to output a PDB of the current configuration. The output can be tailored to include only the parts of the system that you are interested in. This is useful if you are trying to conserve disk usage. You can output PDBs using the ‘pdb’ chunk

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n+nb}{all}
\end{sphinxVerbatim}

Output a PDB of all proteins and solutes to the PDB stream

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{protein}\PYG{o}{=}\PYG{n+nb}{all}
\end{sphinxVerbatim}

Output a PDB of all proteins to the PDB stream

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{protein}\PYG{o}{=}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Output a PDB of protein 2 to the PDB stream

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{solute}\PYG{o}{=}\PYG{n+nb}{all}
\end{sphinxVerbatim}

Output a PDB of all solutes to the PDB stream

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{solute}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

Output a PDB of solute 1 to the PDB stream

The output PDB can be controlled via additional commands added to the above lines, e.g.:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n+nb}{all} \PYG{n}{solvent}\PYG{o}{=}\PYG{n+nb}{all}
\end{sphinxVerbatim}

Output the PDB including all solvent molecules.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{solute}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{solvent}\PYG{o}{=}\PYG{l+m+mf}{5.0}
\end{sphinxVerbatim}

Output a PDB including all solvent molecules within 5.0A of whatever else is printed - in this case solute 1.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{protein}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{showdummies}
\end{sphinxVerbatim}

Output a PDB that also includes dummy atoms.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n}{solute}\PYG{o}{=}\PYG{n+nb}{all} \PYG{n}{showhidden}
\end{sphinxVerbatim}

Output a PDB that also includes hidden solute molecules (solutes that are used to perform geometry perturbations).

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n+nb}{all} \PYG{n}{file}\PYG{o}{=}\PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

Redirect the PDB stream to myfile.txt then print the PDB.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{pdb} \PYG{n+nb}{all} \PYG{n}{solvent}\PYG{o}{=}\PYG{n+nb}{all} \PYG{n}{standard}
\end{sphinxVerbatim}

Output a PDB that have a more standard format than normal, such that it can be viewed and interpreted correctly in most programs.

\index{restraints}\ignorespaces 

\subsection{Restraints}
\label{\detokenize{protoms:restraints}}\label{\detokenize{protoms:index-76}}
ProtoMS supports a number of restraining potentials which can be used to modify the potential energy function and bias the simulation towards particular configurations. To use a restraint in ProtoMS you must first assign an id number to a particular atom or set of atoms, using the following command

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n+nb}{id} \PYG{n}{add} \PYG{n}{int1} \PYG{n+nb}{type} \PYG{n}{int2} \PYG{n}{atname} \PYG{n}{resname}\PYG{o}{\textbar{}}\PYG{n}{resnumber}
\end{sphinxVerbatim}

where \sphinxtitleref{int1} is the index numberr for this id. So if this if the first id you create you may want to use the number 1. type can be SOLUTE or SOLVENT or PROTEIN depending on where the atom you want to tagg is. \sphinxtitleref{atname} is the name of the atom (e.g CA), \sphinxtitleref{resname} is the name of the residue the atom is in if you are dealing with a SOLUTE or SOLVENT. However if it the atom is in a protein, then you must use the PDB residue number.
Once you have specified a few ids, you can create restraints using these ids and the following command

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restraint} \PYG{n}{add} \PYG{n}{id1}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{id2}\PYG{o}{\PYGZhy{}}\PYG{n}{id3}\PYG{o}{\PYGZhy{}}\PYG{n}{id4}\PYG{p}{]} \PYG{n}{type1} \PYG{n}{type2} \PYG{p}{[}\PYG{n}{other} \PYG{n}{parameters}\PYG{p}{]}
\end{sphinxVerbatim}

where \sphinxtitleref{id1} to \sphinxtitleref{id4} designate up to four ids. \sphinxtitleref{type1} designate the type of the restraint. It can be either \sphinxtitleref{cartesian},{}`bond{}` or \sphinxtitleref{dihedral}. In the first case the restraint is applied in cartesian coordinates and will apply to only one atom (\sphinxtitleref{id1}). In the second case, it is applied in internal coordinates, and will apply to only two atoms (\sphinxtitleref{id1}-\sphinxtitleref{id2}). In the last case it is applied to four atoms (\sphinxtitleref{id1}-\sphinxtitleref{id2}-\sphinxtitleref{id3}-\sphinxtitleref{id4}) and in internal coordinates. \sphinxtitleref{type2} designate the functional form of the restraint. It can be \sphinxtitleref{harmonic} or \sphinxtitleref{flatbottom}. Each functional form requires additional parameters. The following options are currently possible:

\index{Cartesian restraint}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-77}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restraint} \PYG{n}{add} \PYG{n}{id1} \PYG{n}{cartesian} \PYG{n}{harmonic} \PYG{n}{xrest} \PYG{n}{yrest} \PYG{n}{zrest} \PYG{n}{krest} \PYG{p}{[}\PYG{k}{lambda}\PYG{p}{]}
\end{sphinxVerbatim}

For a cartesian harmonic restraint you need to specify the coordinates of the anchoring point and the value of the force constant. You may optionally give the keyword lambda at the end of the chunk to scale the energy of the restraint by the value of lambda. This means that when lambda=1 the restraint is on and when lambda=0 the restraint is off. This is useful to calculate the free energy change associated with the introduction of a restraint, although this procedure should not be carried out unless for the bound phase:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restraint} \PYG{n}{add} \PYG{n}{id1} \PYG{n}{cartesian} \PYG{n}{flatbottom} \PYG{n}{xrest} \PYG{n}{yrest} \PYG{n}{zrest} \PYG{n}{krest} \PYG{n}{wrest}
\end{sphinxVerbatim}

For a flatbottom restraint you must in addition specify the width of the flat region of the potential.

\index{bond restraint}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-78}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restraint} \PYG{n}{add} \PYG{n}{id1}\PYG{o}{\PYGZhy{}}\PYG{n}{id2} \PYG{n}{bond} \PYG{n}{harmonic} \PYG{n}{krest}
\end{sphinxVerbatim}

For a bond restraint you must specify only the force constant

\index{dihedral restraint}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-79}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restraint} \PYG{n}{add} \PYG{n}{id1}\PYG{o}{\PYGZhy{}}\PYG{n}{id2}\PYG{o}{\PYGZhy{}}\PYG{n}{id3}\PYG{o}{\PYGZhy{}}\PYG{n}{id4} \PYG{n}{dihedral} \PYG{n}{harmonic} \PYG{n}{theta} \PYG{n}{krest}
\end{sphinxVerbatim}

For a dihedral harmonic restraint you must specify the target equilibrium angle and the force constant. This restraint does not work on solvent molecules and on protein backbone atoms.

The following example shows how to add a harmonic potential restraint between a ligand atom and a protein atom.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n+nb}{id} \PYG{n}{add} \PYG{l+m+mi}{1} \PYG{n}{SOLUTE} \PYG{l+m+mi}{1} \PYG{n}{N2} \PYG{n}{LI8}
\end{sphinxVerbatim}

This chunk will create id number 1 which will point to solute atom 1 (the first atom in the solute pdb file), named c00, from residue L10.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n+nb}{id} \PYG{n}{add} \PYG{l+m+mi}{2} \PYG{n}{PROTEIN} \PYG{l+m+mi}{1} \PYG{n}{O} \PYG{l+m+mi}{318}
\end{sphinxVerbatim}

This chunk will create id number 2 which will point to protein pdb loaded as protein1 by ProtoMS. The atom named O in residue 318 will be selected. Note that 318 is the residue number that appear in the PDB file. It is not necessarily the 318th residue to be loaded by ProtoMS in this protein.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{restraint} \PYG{n}{add} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{n}{bond} \PYG{n}{harmonic} \PYG{l+m+mf}{5.0} \PYG{l+m+mf}{3.33}
\end{sphinxVerbatim}

This chunk will cause a restraint to be added between the atoms id 1 and 2 points to. The functional form of this restraint will be a harmonic potential that is function of the distance between these two atoms. The force constant will be 5 kcal mol - 1. A - 2 and the equilibrium distance 3.33 angstrom.

\index{hardwall restraint}\ignorespaces 
Applying a hardwall restraint is slightly different

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n+nb}{id} \PYG{n}{add} \PYG{l+m+mi}{1} \PYG{n}{SOLUTE} \PYG{l+m+mi}{2} \PYG{n}{O00} \PYG{n}{WAT}
\end{sphinxVerbatim}

This chunk will create id number 1 which will point to solute number 2, looking at the O00 atom of resname WAT

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{hardwall} \PYG{l+m+mi}{1} \PYG{l+m+mf}{25.890} \PYG{l+m+mf}{16.895} \PYG{l+m+mf}{59.083} \PYG{l+m+mf}{1.8} \PYG{l+m+mi}{1000000000}
\end{sphinxVerbatim}

This chunk will apply a hardwall restraint to the center of geometry of the solute number 2. The form of this restraint is spherical, with a radius of 1.8 and will be centered at the point defined by the coordinates 25.890 16.895 59.083. If the center of geometry of the molecule attempts to leave this radius then a huge penalty is applied, preventing the move. Equally, if any atom from another molecule tries to occupy the hardwall region then the penalty is applied.

A hardwall restraint can also be applied on the initial position of the center of geometry of a ligand. In this case, no coordinates need to be specified, and the lines results:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{hardwall} \PYG{l+m+mi}{1} \PYG{l+m+mf}{1.8} \PYG{l+m+mi}{1000000000}
\end{sphinxVerbatim}

This option should be quite useful when the ligand simply wants to be kept in its initial position.


\subsection{Frequent output generation}
\label{\detokenize{protoms:frequent-output-generation}}
Incidental generation of output files might not be convenient either for the production of results and restart files nor for PDB outputs. Consistently, there is an alternative option which allows for the generation of these files \sphinxstyleemphasis{while} the \sphinxtitleref{simulate} chunk is running.

\index{dump files}\ignorespaces 
This is controlled with the alternative key word dump:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dump} \PYG{n}{frequency} \PYG{n}{command}
\end{sphinxVerbatim}

This manner of output generation can be applied to all commands included in {\hyperref[\detokenize{protoms:results-and-restarts}]{\sphinxcrossref{Results and Restarts}}} secction, as well as {\hyperref[\detokenize{protoms:pdb-output}]{\sphinxcrossref{PDB output}}} section.

An example of a dump line would be:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dump} \PYG{l+m+mi}{100000} \PYG{n}{results} \PYG{n}{write} \PYG{n}{results}
\end{sphinxVerbatim}

This line, given as input for ProtoMS, will append results information to the \sphinxtitleref{results} file every 100000 moves, thoughout the \sphinxtitleref{simulate} part of your simulation.

It is important to note how the appending behaviour variates. For frequent results and PDB printing, new results will be appended to the existent file. However for the restart generation, the existing file will be overwritten every time and the old restart will be moved to another file. Consistently these imput lines:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dump} \PYG{l+m+mi}{100} \PYG{n}{results} \PYG{n}{write} \PYG{n}{results}
\PYG{n}{dump} \PYG{l+m+mi}{100} \PYG{n}{pdb} \PYG{n+nb}{all} \PYG{n}{file}\PYG{o}{=}\PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{dump} \PYG{l+m+mi}{100} \PYG{n}{restart} \PYG{n}{write} \PYG{n}{restart}
\PYG{n}{dump} \PYG{l+m+mi}{100} \PYG{n}{averages} \PYG{n}{reset}
\PYG{n}{chunk} \PYG{n}{simulate} \PYG{l+m+mi}{400} \PYG{n}{solvent}\PYG{o}{=}\PYG{l+m+mi}{10} \PYG{n}{solute}\PYG{o}{=}\PYG{l+m+mi}{5} \PYG{n}{volume}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

Will generate four results reports all appended to the file \sphinxtitleref{results}, four PDB conformations of the system appended to \sphinxtitleref{all.pdb}, but only one restart report (the last printed) in the file \sphinxtitleref{restart}.

Dump lines can be written in any order, and they all will be applied while the \sphinxtitleref{simulate} chunk is running.


\subsection{Miscellaneous}
\label{\detokenize{protoms:miscellaneous}}\label{\detokenize{protoms:misccmd}}
As well as running the simulation, there are also a collection of other things that you can do in a simulation chunk. These are

\index{singlepoint}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-82}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{singlepoint}
\end{sphinxVerbatim}

Calculate the energy of the current system and output it to the SPENERGY stream. This is useful if you just want to use ProtoMS to evaluate a forcefield energy. You can set up the input files, turn off all streams, direct stream SPENERGY to STDOUT and run a simulation that only consists of this ‘singlepoint’ chunk.

\index{solutenergy}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-83}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{soluteenergy} \PYG{n}{N}
\end{sphinxVerbatim}

Calculate the energy of solute N. This calculates the energy of solute N and outputs the components of this energy in great detail. This is useful for debugging a forcefield or for collecting average energy components that are more finely divided than those normally collected.

\index{fakesime}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-84}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{fakesim}
\end{sphinxVerbatim}

Performs one step of simulation, without doing anything other than adding the energies to the averages. This can be useful for debugging purposes.

\index{retienergy}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-85}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{retienergy} \PYG{l+m+mf}{0.2}
\end{sphinxVerbatim}

The RETI free energy method requires the calculation of the energy at the neighbouring two \(\lambda\) windows at the end of the simulation. This chunk will calculate the energy at \(\lambda\) windows 0.2 above and below the reference state, and will output the results to the RETI stream.

\index{lambda chunk}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-86}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{k}{lambda} \PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

Sets \(\lambda\) to 0.5. Will calculate and return the change in energy associated with this change in \(\lambda\). This is useful if you wish to perform a slow growth or fast growth free energy simulation. You could also use this in conjunction with the ‘averages print’ and ‘averages reset’ chunks to calculate the free energy of all windows across \(\lambda\) within a single simulation. This is because the window widths are preserved by the change in \(\lambda\), thus if the \(\lambda\) windows were 0.1 0.2 0.4 before the change, then they would be 0.4 0.5 0.7 after the change. Note that the values of \(\lambda\) are clamped between 0.0 and 1.0.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{k}{lambda} \PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.6} \PYG{l+m+mf}{0.4}
\end{sphinxVerbatim}

As above, except set the \(\lambda\) values of the forwards and backwards windows to 0.6 and 0.4 respectively.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{k}{lambda} \PYG{n}{delta} \PYG{l+m+mf}{0.1}
\end{sphinxVerbatim}

As above except instead of directly setting \(\lambda\), change \(\lambda\) by 0.1. This will also increase the value of \(\lambda\) for the for- wards and backwards windows by 0.1.

\index{freeenergy}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-87}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{freeenergy} \PYG{l+m+mf}{0.3} \PYG{l+m+mf}{0.5}
\end{sphinxVerbatim}

Calculate quantities need for free energy estimators. This will calculate the derivative of the potential with respect to \(\lambda\) as needed for thermodynamic integration, and energies at \(\lambda\) =0.3 and \(\lambda\) =0.5 as needed for Bennett Acceptance Ratio method. All of these energies will be printed to the INFO and ENERGY streams.

\index{fixresidues}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-88}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{fixresidues} \PYG{l+m+mi}{1} \PYG{n+nb}{all}
\end{sphinxVerbatim}

Fix all of the residues of protein 1.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{fixresidues} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{l+m+mi}{12} \PYG{l+m+mi}{14} \PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}
\end{sphinxVerbatim}

Fix the residues of protein 1. Only fix residues 1 to 10, 12, 14 and 16 to 20.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{fixresidues} \PYG{l+m+mi}{1} \PYG{n}{none}
\end{sphinxVerbatim}

Unfix all of the residues of protein 1.

\index{fixbackbone}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-89}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{fixbackbone} \PYG{l+m+mi}{1} \PYG{n+nb}{all}
\end{sphinxVerbatim}

Fix the backbone of all residues of protein 1. This chunk has the same syntax as the fixresidues chunk.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{fixbackbone} \PYG{l+m+mi}{1} \PYG{n}{none} \PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{35}
\end{sphinxVerbatim}

Unfix all of the residues of protein 1, then fix the backbone of residues 20-35. This ensures that only the backbone of residues 20-35 is fixed.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk12} \PYG{n}{transrot} \PYG{l+m+mi}{1} \PYG{l+m+mf}{0.0} \PYG{l+m+mf}{0.0}
\end{sphinxVerbatim}

Set the translation and rotation displacements for solute 1 to zero. This overrides the values read in the template file. The first floating point number is the translation displacement and the second one is the rotation displacement and is optional. Can be useful for pure solvent and gas-phase calculations.

\index{setstream}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-90}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{setstream} \PYG{n}{info}\PYG{o}{=}\PYG{n}{stdout} \PYG{n}{move}\PYG{o}{=}\PYG{n}{off}
\end{sphinxVerbatim}

Direct the INFO stream to STDOUT and turn the MOVE stream off.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{setstream} \PYG{n}{restart}\PYG{o}{=}\PYG{n}{myfile}\PYG{o}{.}\PYG{n}{txt} \PYG{n}{warning}\PYG{o}{=}\PYG{n}{stderr}
\end{sphinxVerbatim}

Direct the RESTART stream to myfile.txt and the WARNING stream to STDERR. solvate{]}

\index{solvent chunk}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{protoms:index-91}}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{solvent} \PYG{n}{box} \PYG{n}{xdim} \PYG{n}{ydim} \PYG{n}{zdim} \PYG{p}{[}\PYG{n}{xorig} \PYG{n}{yorig} \PYG{n}{zorig} \PYG{n}{xmax} \PYG{n}{ymax} \PYG{n}{zmax}\PYG{p}{]}
\end{sphinxVerbatim}

This command can be used to replicate a solvent file loaded as solvent1 such that the final solvent occupies a box of dimensions xdim ydim zdim with origin (0,0,0). Alternatively the origin can be specified along with the maximum coordinates of the cubix box. solvate2{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chunk} \PYG{n}{solvent} \PYG{n}{cap} \PYG{n}{xorig} \PYG{n}{yorig} \PYG{n}{zorig} \PYG{n}{rad}
\end{sphinxVerbatim}

As before but the output will be a spherical cap of solvent centered at the specified origin and with a radius rad. The last two commands can be used to create large solvent boxes when needed. Once this chunk has been performed, you should save a pdb of the system using the chunk pdb and then edit the output file such that it can load as ProtoMS solvent pdb. The process of replicating the solvent molecules can be quite memory consuming and you may find you have to recompile ProtoMS so that it can handle a large number of solvent molecules, particularly if the coordinates of the system you want to solvate are far away from the coordinates of the solvent molecules in the input solvent box.


\section{Setup and analysis tools}
\label{\detokenize{protoms:setup-and-analysis-tools}}
As there are many options that can be set in ProtoMS, we provide a range of setup tools that can be used to setup the most common type of simulations. The main tool is called \sphinxcode{\sphinxupquote{protoms.py}} and is document in the next \sphinxhref{protomspy.html}{chapter}. For more advanced use, one can use the individual setup tools as documented in the \sphinxhref{tools.html}{tools chapter}.

In order to perform analysis of ProtoMS simulations, there is a range of tools that can be used. They are documented in the \sphinxhref{tools.html}{tools chapter}.


\chapter{Input Files}
\label{\detokenize{protoms:input-files}}
ProtoMS can read in five types of input file
\begin{itemize}
\item {} 
\sphinxstylestrong{Parameter / Forcefield file} These provide the forcefield parameters used in a simulation, and the templates (z-matricies) that are used to specify the connectivity and flexibility of the simulated molecules.

\item {} 
\sphinxstylestrong{Protein file} These are simple PDB format files that contain the coordinates of the protein chains to be simulated. Only one protein chain may be contained within each protein PDB file.

\item {} 
\sphinxstylestrong{Solute file} These are simple PDB format files that contain the coordinates of the solutes to be simulated. Only one solute may be contained within each solute PDB file.

\item {} 
\sphinxstylestrong{Solvent file} These are simple PDB format files that contain the coordinates of the solvent molecules to be simulated. Multiple solvent molecules may be contained within each solvent file.

\item {} 
\sphinxstylestrong{Restart file} These are files used by ProtoMS to save and restore the coordinates of all of the molecules in the system.

\end{itemize}

ProtoMS is insensitive to case, so you can mix upper case and lower case within these files without affecting how
they are read.


\section{Parameter / Forcefield Files}
\label{\detokenize{protoms:parameter-forcefield-files}}\label{\detokenize{protoms:parfil}}
The parameter file is the most powerful, and hence the most complicated of all of the input files read by ProtoMS. The parameter file provides all of the forcefield parameters that are used in a simulation, and it also provides all of the templates that provide the connectivity and z-matrices of all of the loaded molecules. The parameter file uses a word based format, meaning that you can leave as many spaces between words on a line as you like, and you do not have to worry about lining up data into particular columns.

The general format of a parameter file is shown below:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} comment lines start with a \PYGZsq{}\PYGZsh{}\PYGZsq{}}

\PYG{n}{mode} \PYG{n}{clj}
\PYG{c+c1}{\PYGZsh{}.... charge / Lennard Jones forcefield parameters}

\PYG{n}{mode} \PYG{n}{bond}
\PYG{c+c1}{\PYGZsh{}.... bond parameters}

\PYG{n}{mode} \PYG{n}{template}
\PYG{c+c1}{\PYGZsh{}.... templates}

\PYG{c+c1}{\PYGZsh{}parameter file uses a word\PYGZhy{}based format, so leave as many spaces as}
\PYG{c+c1}{\PYGZsh{}you want between words, e.g.}
       \PYG{n}{mode}            \PYG{n}{clj}

\PYG{n}{mode} \PYG{n}{bond}   \PYG{c+c1}{\PYGZsh{}comments can also go at the end of any lines, like this!}

\PYG{n}{MoDe} \PYG{n}{DiHeDrAl}  \PYG{c+c1}{\PYGZsh{} you can use whatever case you want (though try to make}
               \PYG{c+c1}{\PYGZsh{} things readable!}
\end{sphinxVerbatim}

How ProtoMS reads the parameter file is controlled by which \sphinxcode{\sphinxupquote{mode}} the file has been set. There are several different modes, and as figure 3.5 shows, it is possible to change between modes within a single file. The different modes are
\begin{itemize}
\item {} 
\sphinxstylestrong{info} This mode is used to read in control information for the forcefield.

\item {} 
\sphinxstylestrong{clj} This mode is used to read in the charge and Lennard Jones (clj) parameters for the simulation.

\item {} 
\sphinxstylestrong{bond} This mode is used to read in the bond parameters for the simulation.

\item {} 
\sphinxstylestrong{angle} This mode is used to read in the angle parameters.

\item {} 
\sphinxstylestrong{ureybradley} This mode is used to read in the Urey-Bradley parameters.

\item {} 
\sphinxstylestrong{dihedral} This mode is used to read in the dihedral parameters.

\item {} 
\sphinxstylestrong{template} This mode is used to read in the templates (z-matricies) used in the simulation. The template format is quite complex, so is described in the next section.

\end{itemize}

ProtoMS will only read lines that are valid within the mode that is being read. If ProtoMS could not read a line, or finds an incorrectly formatted line, then ProtoMS will print a message to the WARNING stream and will skip that line. It is therefore very important that you check the WARNING stream if you are writing or modifying a parameter file. To help you, ProtoMS will write out detailed information about a loaded parameter file to the DETAIL stream. You should check this output to ensure that any changes you make to a parameter file are being
correctly loaded by ProtoMS.

ProtoMS can be asked to load as many forcefield files as you desire. Each parameter or template within the forcefield files has either a numerical or name based ID. If two forcefield files have parameters or templates that share the same ID, then ProtoMS will use the value that was read last. ProtoMS will of course warn you that it has overwritten an earlier parameter (by outputting a message to the WARNING stream) but this behaviour could still trip you up! To help you, all of the parameters that use numerical IDs in the forcefield files supplied with ProtoMS use IDs that are between 1 and 2999. You can thus use numerical IDs that are greater than or equal to 3000 without worrying about a clash.

\index{mode info}\ignorespaces 
\sphinxstylestrong{mode info}

This mode is used to read in control information for the forcefield. This information is used to set parameters that affect which functions are used to evaluate the forcefield, and to set the values of forcefield-global parameters. The following lines are valid within this mode

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ljcombine} \PYG{n+nb}{type}
\end{sphinxVerbatim}

where \sphinxstyleemphasis{type} can be \sphinxtitleref{arithmetic} or \sphinxtitleref{geometric}. This sets the combining rules used for the Lennard Jones \(\sigma\) parameter to either the arithmetic mean (as used by AMBER), or the geometric mean (as used by OPLS). See equations \eqref{equation:protoms:arithmetriccomb} and \eqref{equation:protoms:geometriccomb} for the functional forms of these combining rules.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scl14coul} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This sets the 1-4 coulombic scaling factor, e.g. for OPLS the value should be 0.5 (see eq \eqref{equation:protoms:intrapot1}).

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scl14lj} \PYG{n+nb}{float}
\end{sphinxVerbatim}

This sets the 1-4 Lennard Jones scaling factor, e.g. for OPLS the value should be 0.5 (see eq \eqref{equation:protoms:intrapot1}).

\index{mode clj}\ignorespaces 
\sphinxstylestrong{mode clj}

This mode is used to read in the charge and Lennard Jones (clj) parameters used by the simulation (see equations \eqref{equation:protoms:intermol1} and \eqref{equation:protoms:intrapot3}). Only one type of line is valid within this mode

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{n}{amber} \PYG{n}{proton}\PYG{o}{\PYGZhy{}}\PYG{n}{number} \PYG{n}{charge} \PYG{n}{sigma} \PYG{n}{epsilon}
\end{sphinxVerbatim}

\sphinxstyleemphasis{id} is the unique identifying number for this clj parameter. This can be any number from 1 to MAXCLJ (by default this is 10000). If this ID is the same as an already read CLJ parameter, then ProtoMS will write a warning to the WARNING stream, and will overwrite the old CLJ parameter with the new parameter. To help prevent unintentional ID clashes, then the forcefields supplied with ProtoMS only use parameter IDs from 1 to 2000, and the solvent models supplied with ProtoMS use parameter IDs 2001 to 2999. You are thus free to use parameter IDs from 3000 in your own parameter files.

\sphinxstyleemphasis{amber} is the AMBER atom type associated with this clj parameter. The AMBER atom type is a two letter code that is used to identify the atom for the purposes of assigning bond, angle, dihedral or Urey-Bradley parameters. If this is a parameter for a dummy or non-chemical parameter, then the AMBER atom type should be ‘??’. Note that the AMBER type is case sensitive. This is different to other parts of ProtoMS, and is required as the GAFF forcefield uses case to distinguish between different AMBER types.

\sphinxstyleemphasis{proton-number} is the number of protons in the atom associated with this clj parameter, e.g. 1 for hydrogen, 6 for carbon or 8 for oxygen.

\sphinxstyleemphasis{charge}, \sphinxstyleemphasis{sigma} and \sphinxstyleemphasis{epsilon} are the partial charge (in \textbar{}e\textbar{}), and Lennard Jones \(\sigma\) (A) and \(\epsilon\) (kcal mol-1 ) parameters associated with this clj parameter, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{l+m+mi}{2001} \PYG{n}{OW} \PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.834} \PYG{l+m+mf}{3.15061} \PYG{l+m+mf}{0.1521} \PYG{c+c1}{\PYGZsh{} TIP3P oxygen}
\end{sphinxVerbatim}

specifies the clj parameter for oxygen in TIP3P water, with parameter number 2001, AMBER atom type ‘OW’ proton number 8, a partial charge of -0.834 \textbar{}e\textbar{}, \(\sigma\) = 3.15061 A and \(\epsilon\) = 0.1521 kcal mol-1 .

Parameter ID 0 is a special clj parameter used to represent a null atom. This null atom has charge, \(\sigma\) and \(\epsilon\) values of 0.0, an AMBER atom type of ‘DM’ and a proton number of 0.

\index{mode bond}\ignorespaces 
\sphinxstylestrong{mode bond}

This mode is used to read in the bond parameters used by the simulation. Two types of line are valid within this mode

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{n}{force}\PYG{o}{\PYGZhy{}}\PYG{n}{constant} \PYG{n}{bond}\PYG{o}{\PYGZhy{}}\PYG{n}{length}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{id}} is an identifying number from 1 to MAXBNDPARAM (default 5000) that is used to uniquely identify a bond. As in the case of the clj parameters, new parameters with the same ID number will overwrite old parameters with that ID number, and the parameter files supplied with ProtoMS will only use IDs from 1 to 2999, so you can safely use parameters 3000 and up.

\sphinxcode{\sphinxupquote{force-constant}} is the force constant (\(k_{bond}\), see eq \eqref{equation:protoms:bondpot}) for the bond parameter. The units of \(k_{bond}\) are kcal mol-1 A-2 . \sphinxcode{\sphinxupquote{bond-length}} is the equilibrium bond length (\(r_0\) ), in units of A.

The second type of line valid in this mode is used to associate a pair of AMBER atom types with a bond parameter

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atm} \PYG{n}{amb1} \PYG{n}{amb2} \PYG{n+nb}{id}
\end{sphinxVerbatim}

This line specifies the bond between atoms with AMBER atom types \sphinxcode{\sphinxupquote{amb1}} and \sphinxcode{\sphinxupquote{amb2}} is assigned the parameters from bond ID \sphinxcode{\sphinxupquote{id}}. Note that this bond parameter does not need to have been loaded when this line of the parameter file is being read, as bond parameters are not assigned until after all parameter files have been read. If none of the bond parameter files provide this bond ID, then ProtoMS will print a message to the WARNING stream and will set the bond ID to 0. As in the case of the clj parameters, 0 is a special parameter used to specify a null bond, whose bond parameters, and thus energy, are all 0.0. In addition, any bond involving an AMBER atom with a null clj parameter (i.e. having AMBER atom type ‘DM’) will be automatically set to use bond parameter 0. It is not possible to have a non-null bond parameter for bonds that involve dummy atoms.

These bond atm lines are indexed by the AMBER pair amber1-amber2. If this AMBER pair has already been loaded then its parameter is overwritten with the new parameter. Note that bonds are symmetrical, thus bond index amb1-amb2 is equal to amb2-amb1.

\index{mode angle}\ignorespaces 
\sphinxstylestrong{mode angle}

This mode is used to read in the angle parameters used in the simulation and its format and behaviour is almost identical to that used in the bond mode. Again, only two types of line are valid within the angle mode

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{n}{force}\PYG{o}{\PYGZhy{}}\PYG{n}{constant} \PYG{n}{angle}\PYG{o}{\PYGZhy{}}\PYG{n}{size}
\end{sphinxVerbatim}

and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atm} \PYG{n}{amb1} \PYG{n}{amb2} \PYG{n}{amb3} \PYG{n+nb}{id}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{id}} is an indentifying number from 1 to MAXANGPARAM (default 5000) that is used to uniquely identify an angle parameters. \sphinxcode{\sphinxupquote{force-constant}} is the force constant (\(k_{angle}\) , see eq \eqref{equation:protoms:angpot}) for the angle parameter, in units of kcal mol-1 degree-2 . \sphinxcode{\sphinxupquote{angle-size}} is the equilibrium angle size (\(\theta_0\)) in units of degrees. Angle ID 0 is the null angle, and the forcefield files supplied with ProtoMS will only use angle IDs from 1 to 2999.

The atm line is again very similar to that in the bond mode, with in this case the angle between atoms with AMBER types \sphinxcode{\sphinxupquote{amb1-amb2-amb3}} being assigned angle parameter id. Angles are also symmetric, so \sphinxcode{\sphinxupquote{amb1-amb2-amb3}} is equivalent to \sphinxcode{\sphinxupquote{amb3-amb2-amb1}}. Like the bond mode, any angle involving dummy atoms (AMBER type ‘DM’) will automatically be set to use the angle parameter 0. It is not possible to use a non-null angle parameter over an angle involving dummy atoms.

\index{mode ureybradley}\ignorespaces 
\sphinxstylestrong{mode ureybradley}

This mode is used to read in Urey-Bradley parameters (see eq \eqref{equation:protoms:ubpot}), and its format is identical to that of the angle mode. There are only two valid lines in this mode

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{n}{force}\PYG{o}{\PYGZhy{}}\PYG{n}{constant} \PYG{n}{uby}\PYG{o}{\PYGZhy{}}\PYG{n}{size}
\end{sphinxVerbatim}

and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atm} \PYG{n}{amb1} \PYG{n}{amb2} \PYG{n}{amb3} \PYG{n+nb}{id}
\end{sphinxVerbatim}

In this case force-constant refers to the Urey-Bradley force constant (\(k_{uby}\) ), in units of kcal mol-1 A -2 and \sphinxcode{\sphinxupquote{uby-size}} refers to the equilibrium Urey-Bradley length (\(x_0\) ) in units of A. Everything else about this mode is identical to that of the bond mode.

\index{mode dihedral}\ignorespaces 
\sphinxstylestrong{mode dihedral}

This mode is used to read in the dihedral parameters that are used in the simulation. There are three types of line that are value in this mode. The first of these is used to provide the parameters for a single dihedral cosine term :
\begin{quote}

term term-id k1 k2 k3 k4
\end{quote}

\sphinxcode{\sphinxupquote{term-id}} is an ID number from 1 to MAXDIHTERMS (default 5000) that uniquely identifies this dihedral cosine term. \sphinxcode{\sphinxupquote{k1}} to \sphinxcode{\sphinxupquote{k4}} are the values of the four constants (\(k_1\) to \(k_4\) ) that control the dihedral cosine term (see eq \eqref{equation:protoms:dihepot}). \sphinxcode{\sphinxupquote{k1}} has units of kcal mol-1 , \sphinxcode{\sphinxupquote{k2}} and \sphinxcode{\sphinxupquote{k3}} are dimensionless, and \sphinxcode{\sphinxupquote{k4}} is in units of degrees.

A full dihedral parameter is composed from the sum of individual dihedral cosine terms. The second valid line in the dihedral mode specifies which terms are associated with which parameters, e.g

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{l+m+mi}{3} \PYG{l+m+mi}{10} \PYG{l+m+mi}{32}
\end{sphinxVerbatim}

specifies that dihedral parameter \sphinxcode{\sphinxupquote{id}} is formed as the sum of dihedral cosine terms 3, 10 and 32. You may specify as many dihedral cosine terms on this line as you wish from 1 to MAXDIHTERMSPERDIHEDRAL (default 6). As in the bond, angle and ureybradley modes, \sphinxcode{\sphinxupquote{id}} is a uniquely identifying number, in this case from 1 to MAXDIHPARAM (default 5000), with ID 0 referring to the special, null dihedral.

As in the case of the bond, angle and ureybradley modes, the AMBER atom set is used to associate dihedral parameters with actual dihedrals in a molecule. The final valid line associates the AMBER atom types of the four  atoms in the dihedral with the dihedral parameter ID, e.g

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atm} \PYG{n}{amb1} \PYG{n}{amb2} \PYG{n}{amb3} \PYG{n}{amb4} \PYG{n+nb}{id}
\end{sphinxVerbatim}

Because dihedrals are symmetrical, \sphinxcode{\sphinxupquote{amb1-amb2-amb3-amb4}} is equivalent to \sphinxcode{\sphinxupquote{amb4-amb3-amb2-amb1}}.

\index{mode born}\ignorespaces 
\sphinxstylestrong{mode born}

This mode is used to read the Generalised Born parameters that are used in the simulation. A valid line is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{n}{atype} \PYG{n}{iborn} \PYG{n}{scalefac}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{atype}} is an AMBER/GAFF atom type, \sphinxcode{\sphinxupquote{iborn}} is an intrinsic born radius and scalefac a scaling factor for Pairwise Descreening Approximation calculations. These parameters have been optimised to be used with the AMBER or GAFF force fields.

\index{mode surface}\ignorespaces 
\sphinxstylestrong{mode surface}

This mode is used to read surface area parameters that are used in the simulation. A valid line is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par} \PYG{n+nb}{id} \PYG{n}{atype} \PYG{n}{radius} \PYG{n}{surftens}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{atype}} is an AMBER/GAFF atom type, \sphinxcode{\sphinxupquote{radius}} is the radius of the atom and \sphinxcode{\sphinxupquote{surftens}} the surface tension of this atom type, which relates the solvent accessible surface area of this atom to a non polar energy. These parameters have been optimised to be used with the AMBER or GAFF force fields.


\section{Templates}
\label{\detokenize{protoms:templates}}\label{\detokenize{protoms:temref}}
Templates are used to assign the z-matrix and forcefield parameters to loaded molecules. Templates are read in using the template mode of the parameter / forcefield file. Different types of template are used with the different types of molecules in ProtoMS
\begin{itemize}
\item {} 
\sphinxstylestrong{proteins} The backbone of each protein residue is assigned via a chain template. The sidechain of each residue is assigned via a residue template.

\item {} 
\sphinxstylestrong{solutes} Solutes are assigned via solute templates.

\item {} 
\sphinxstylestrong{solvents} Solvents are assigned via solvent templates.

\item {} 
\sphinxstylestrong{GCsolutes} GCsolutes are assigned via GCsolute templates.

\end{itemize}

\sphinxstylestrong{Chain Templates}

Chain templates are used to assign the z-matrix and parameters of the backbone of protein residues. The start of a new chain template is indicated by the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chain} \PYG{n}{name}
\end{sphinxVerbatim}

where name is the name of the chain template. This name uniquely identifies this chain template. If another chain template has been loaded with this name, then this chain template will overwrite it and a message will be output to the WARNING stream.

The valid lines that comprise a chain template are

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bbatom} \PYG{n+nb}{id} \PYG{n}{nam} \PYG{n}{par0} \PYG{n}{par1}
\end{sphinxVerbatim}

This line identifies which are the four bbatoms of the residue. \sphinxcode{\sphinxupquote{id}} identifies which bbatom this atom is (from 1 to 4), \sphinxcode{\sphinxupquote{nam}} gives the name of the atom (maximum of four characters), and \sphinxcode{\sphinxupquote{par0}} and \sphinxcode{\sphinxupquote{par1}} are the CLJ parameters for this atom at \(\lambda\) = 0.0 and \(\lambda\) = 1.0, and these must refer to a valid CLJ parameter (from 0 to MAXCLJ, default 10000). Note that CLJ parameter 0 is used to assign a dummy atom. The name of the atom is the same as that given in the PDB file for the protein, and is limited to a maximum of four characters. The atom name must uniquely identify the atom within the residue, so this name must not be used elsewhere within this chain template, or in any residue templates that connect to this chain template

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atom} \PYG{n}{nam} \PYG{n}{par0} \PYG{n}{par1} \PYG{n}{bndnam} \PYG{n}{angnam} \PYG{n}{dihnam}
\end{sphinxVerbatim}

This line identifies any extra atoms that are part of the backbone. \sphinxcode{\sphinxupquote{nam}}, \sphinxcode{\sphinxupquote{par0}} and \sphinxcode{\sphinxupquote{par1}} have the same meanings as for the bbatom line. This is a z-matrix line, and \sphinxcode{\sphinxupquote{bndnam}}, \sphinxcode{\sphinxupquote{angnam}} and \sphinxcode{\sphinxupquote{dihnam}} are the names of the atoms that are the reference from which the coordinates of this atom are generated (bond, angle and dihedral atoms). Note that this line does not state that there is a bond, angle or dihedral with these atoms. This line only says that these three atoms are used to construct this extra atom. Note that the atoms in a residue are built in sequence, so the bond, angle and dihedral atoms in this line must refer to atoms that were previously listed in the chain template.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{zmat} \PYG{n}{nam} \PYG{n}{bndval} \PYG{n}{angval} \PYG{n}{dihval}
\end{sphinxVerbatim}

This line provides the default values of the internal z-matrix coordinates for the atom called \sphinxcode{\sphinxupquote{nam}}. \sphinxcode{\sphinxupquote{bndval}}, \sphinxcode{\sphinxupquote{angval}} and \sphinxcode{\sphinxupquote{dihval}} are the default values of the bond length, angle size and dihedral size. This line is optional, and is only required if you either want ProtoMS to construct this atom if it is missing from the PDB file, or if you want ProtoMS to reset bond and angles to default values.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{nam2}
\end{sphinxVerbatim}

This line adds a bond between atoms name \sphinxcode{\sphinxupquote{nam1}} and \sphinxcode{\sphinxupquote{nam2}}. These two atom names must be present in the chain template. ProtoMS will not automatically add any bonds between atoms (except inter-residue bonds), so you must add all bonds that are present in the chain template. ProtoMS will use all of these explicitly added non-dummy bonds between atoms to generate all of the implicit angles and dihedrals within the backbone. Additional arguments may be present on this line to control the type of bond that is added, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{dummy}
\end{sphinxVerbatim}

adds a dummy bond between atoms \sphinxcode{\sphinxupquote{nam1}} and \sphinxcode{\sphinxupquote{nam2}}. A dummy bond is really a non-bond, as it has no energy, and its presence forces ProtoMS to treat atoms nam1 and nam2 as though they were not bonded together. You can make this bond flexible by adding the flex argument to the bond line, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{flex} \PYG{n}{delta}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{delta}} is the maximum change in the bond length attempted in a Monte Carlo move in A. Note that you can only make degrees of freedom flexible if they are used in the construction of the z-matrix, i.e. atom \sphinxcode{\sphinxupquote{nam1}} must be constructed via a bond with \sphinxcode{\sphinxupquote{nam2}}, or \sphinxcode{\sphinxupquote{nam2}} constructed from \sphinxcode{\sphinxupquote{nam1}}.

The forcefield parameters for this bond will normally be assigned via the AMBER atom types of the constituent atoms. It is possible to override this assignment by explicitly assigning bond parameters, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{param} \PYG{n}{par0} \PYG{n}{par1}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{par0}} and \sphinxcode{\sphinxupquote{par1}} are the bond parameter IDs for this bond at \(\lambda\) = 0.0 and \(\lambda\) = 1.0. The bond parameter IDs must refer to valid bond parameters (0 to MAXBNDPARAM, default 5000), where parameter 0 is used to refer to a null bond. You can use parameter 0 to state that two atoms are bonded, but that the energy of the bond should not be evaluated, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{param} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

Angles and Urey-Bradley terms and dihedrals in the chain template are specified almost identically as for the bond line, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{angle} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{nam3}
\end{sphinxVerbatim}

adds an angle between atoms named \sphinxcode{\sphinxupquote{nam1-nam2-nam3}},

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ureybradley} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{nam3}
\end{sphinxVerbatim}

adds a Urey-Bradley term between atoms named \sphinxcode{\sphinxupquote{nam1-nam2-nam3}}, and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dihedral} \PYG{n}{nam1} \PYG{n}{nam2} \PYG{n}{nam3} \PYG{n}{nam4}
\end{sphinxVerbatim}

adds a dihedral between atoms named \sphinxcode{\sphinxupquote{nam1-nam2-nam3-nam4}}. \sphinxcode{\sphinxupquote{dummy}} and \sphinxcode{\sphinxupquote{param}} options may be added to all of these lines, and \sphinxcode{\sphinxupquote{flex}} may be added to the angle and dihedral lines (where delta is given in units of degrees).

ProtoMS uses the bonds specified in the template to work out where all of the implicit angles and dihedrals are in the backbone. You do not need to include implicit (additional) angles or dihedrals in the template file, and you can just the template to just the flexible angles and dihedrals. However there are some cases where you would not wish an implicit angle or dihedral to be evaluated, for example the dihedral energy may only need to be evaluated via one of the dihedrals around a bond, and not via any additional dihedrals. If this is the case then you will need to add those additional dihedrals to the template and use the dummy keyword to specify that these are dummy dihedrals and that their energy should not be evaluated.

It is not possible to add multiple bonds between the same pair of atoms, or multiple angles to the same triplet of atoms etc. ProtoMS will only use the first definition of a bond, angle, dihedral or Urey-Bradley term and will ignore any further attempts to set them.

As an example, the chain template for an amino acid backbone in the middle of a chain is as follows

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}       \PYGZhy{}\PYGZhy{}  HN      O  \PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{}        \textbar{}   \textbar{}      \textbar{}  \textbar{}}
\PYG{c+c1}{\PYGZsh{}   res\PYGZhy{}1\textbar{} \PYGZhy{}\PYGZhy{}N\PYGZhy{}\PYGZhy{}CA\PYGZhy{}\PYGZhy{}C\PYGZhy{}\PYGZhy{}\textbar{}res+1}
\PYG{c+c1}{\PYGZsh{}        \textbar{}       \textbar{}     \textbar{}}
\PYG{c+c1}{\PYGZsh{}       \PYGZhy{}\PYGZhy{}       X     \PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{mode} \PYG{n}{template}
\PYG{n}{chain} \PYG{n}{aacenter}
\PYG{n}{bbatom} \PYG{l+m+mi}{1}  \PYG{n}{N}  \PYG{l+m+mi}{3}  \PYG{l+m+mi}{3}
\PYG{n}{bbatom} \PYG{l+m+mi}{2}  \PYG{n}{CA} \PYG{l+m+mi}{6}  \PYG{l+m+mi}{6}
\PYG{n}{bbatom} \PYG{l+m+mi}{3}  \PYG{n}{C}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}
\PYG{n}{bbatom} \PYG{l+m+mi}{4}  \PYG{n}{O}  \PYG{l+m+mi}{2}  \PYG{l+m+mi}{2}
\PYG{n}{atom}  \PYG{n}{HN} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}  \PYG{n}{N}  \PYG{n}{CA}  \PYG{n}{C}
\PYG{n}{zmat}  \PYG{n}{HN} \PYG{l+m+mf}{1.010} \PYG{l+m+mf}{119.8} \PYG{l+m+mf}{180.0}
\PYG{n}{bond}  \PYG{n}{O}  \PYG{n}{C}
\PYG{n}{bond}  \PYG{n}{C}  \PYG{n}{CA}
\PYG{n}{bond}  \PYG{n}{CA} \PYG{n}{N}
\PYG{n}{bond}  \PYG{n}{HN} \PYG{n}{N}
\PYG{n}{angle} \PYG{n}{HN} \PYG{n}{N} \PYG{n}{CA} \PYG{n}{flex} \PYG{l+m+mf}{3.0}
\PYG{n}{dihedral} \PYG{n}{HN} \PYG{n}{N} \PYG{n}{CA} \PYG{n}{C} \PYG{n}{flex} \PYG{l+m+mf}{3.0}
\PYG{c+c1}{\PYGZsh{} Now the parameters}
\PYG{n}{mode} \PYG{n}{clj}
\PYG{n}{par} \PYG{l+m+mi}{3} \PYG{n}{N}  \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.570} \PYG{l+m+mf}{3.250} \PYG{l+m+mf}{0.170} \PYG{c+c1}{\PYGZsh{} N, sp2 N in amide}
\PYG{n}{par} \PYG{l+m+mi}{6} \PYG{n}{CH} \PYG{l+m+mi}{6}  \PYG{l+m+mf}{0.200} \PYG{l+m+mf}{3.800} \PYG{l+m+mf}{0.080} \PYG{c+c1}{\PYGZsh{} CA, sp3 C with 1 H}
\PYG{n}{par} \PYG{l+m+mi}{1} \PYG{n}{C}  \PYG{l+m+mi}{6}  \PYG{l+m+mf}{0.500} \PYG{l+m+mf}{3.750} \PYG{l+m+mf}{0.105} \PYG{c+c1}{\PYGZsh{} C, carbonyl C}
\PYG{n}{par} \PYG{l+m+mi}{2} \PYG{n}{O}  \PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.500} \PYG{l+m+mf}{2.960} \PYG{l+m+mf}{0.210} \PYG{c+c1}{\PYGZsh{} O, carbonyl O}
\PYG{n}{par} \PYG{l+m+mi}{4} \PYG{n}{H}  \PYG{l+m+mi}{1}  \PYG{l+m+mf}{0.370} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.000} \PYG{c+c1}{\PYGZsh{} HN, amide hydrogen}
\end{sphinxVerbatim}

This shows that it can be convienient to combine the chain template with the CLJ parameters for the template into a single parameter file.

\sphinxstylestrong{Residue Templates}

Residue templates are used to assign the z-matrix and forcefield parameters for the sidechains of protein residues. The format of a residue templates is almost identical to that of a chain template.

As an example, here is the residue template for OPLS united atom alanine

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ALANINE}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}     N\PYGZhy{}CA\PYGZhy{}C}
\PYG{c+c1}{\PYGZsh{}        \textbar{}}
\PYG{c+c1}{\PYGZsh{}       CB}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{mode} \PYG{n}{template}
\PYG{n}{residue} \PYG{n}{ALA}
\PYG{n}{info} \PYG{n}{rotate} \PYG{l+m+mf}{0.5} \PYG{n}{translate} \PYG{l+m+mf}{1.0}
\PYG{n}{backbone} \PYG{n}{first} \PYG{n}{aanterm} \PYG{n}{middle} \PYG{n}{aacenter} \PYG{n}{last} \PYG{n}{aacterm} \PYG{n}{single} \PYG{n}{aasingle}
\PYG{n}{atom}  \PYG{n}{CB}  \PYG{l+m+mi}{7} \PYG{l+m+mi}{7} \PYG{n}{CA} \PYG{n}{N} \PYG{n}{C}
\PYG{n}{zmat}  \PYG{n}{CB}  \PYG{l+m+mf}{1.525} \PYG{l+m+mf}{111.1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120.0}
\PYG{n}{bond}  \PYG{n}{CB} \PYG{n}{CA}
\PYG{n}{angle} \PYG{n}{CB} \PYG{n}{CA} \PYG{n}{N} \PYG{n}{flex} \PYG{l+m+mf}{0.5}
\PYG{c+c1}{\PYGZsh{}parameters}
\PYG{n}{mode} \PYG{n}{clj}
\PYG{n}{par} \PYG{l+m+mi}{7} \PYG{n}{C3} \PYG{l+m+mi}{6}  \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{3.910} \PYG{l+m+mf}{0.160} \PYG{c+c1}{\PYGZsh{} CB, sp3 with 3 H}
\end{sphinxVerbatim}

The start of a new residue template is signalled by the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{residue} \PYG{n}{name}
\end{sphinxVerbatim}

where name is the name of the residue template. This name uniquely identifies the template and because residues locate templates via the residue name, the residue template name is limited to a maximum of four characters. The lines that comprise a residue template are

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{info} \PYG{n}{rotate} \PYG{n}{rotdel} \PYG{n}{translate} \PYG{n}{trandel}
\end{sphinxVerbatim}

This line provides information about the residue template. The option \sphinxcode{\sphinxupquote{rotate}} \sphinxcode{\sphinxupquote{rotdel}} specifies that the backbone rotation move would rotate the backbone by a maximum of \sphinxcode{\sphinxupquote{rotdel}} degrees. The option translate \sphinxcode{\sphinxupquote{trandel}} specifies that the backbone translation move would translate the backbone by a maximum of \sphinxcode{\sphinxupquote{trandel}} A. Both of these options are optional, and may appear in any order on this line. If these options are not given, then the default translation and rotation values are both 0.0.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{backbone} \PYG{n}{position} \PYG{n}{chain}
\end{sphinxVerbatim}

This line states which chain templates are associated with this residue template for different positions of the residue within the protein, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{backbone} \PYG{n}{first} \PYG{n}{aanterm} \PYG{n}{middle} \PYG{n}{aacenter} \PYG{n}{last} \PYG{n}{aacterm} \PYG{n}{single} \PYG{n}{aasingle}
\end{sphinxVerbatim}

states that this residue template uses the chain template called \sphinxcode{\sphinxupquote{aanterm}} if this was the first residue in the protein, \sphinxcode{\sphinxupquote{aacenter}} if this residue was in the middle of the protein, \sphinxcode{\sphinxupquote{aacterm}} if this was the last residue in the protein, and \sphinxcode{\sphinxupquote{aasingle}} if this was the only residue in the protein. You can place as many positions on this line as you wish, with possible positions being first, middle, last and single. You do not need to specify a chain template for every one of these positions, but ProtoMS will print a message to the WARNING stream if it needs a position that has not been specified.

The remaining lines in the residue template are the \sphinxcode{\sphinxupquote{atom}}, \sphinxcode{\sphinxupquote{zmat}}, \sphinxcode{\sphinxupquote{bond}}, \sphinxcode{\sphinxupquote{angle}}, \sphinxcode{\sphinxupquote{ureybradley}} and \sphinxcode{\sphinxupquote{dihedral}} lines, which have exactly the same meaning and formats as those in the chain template lines. Note that the names of atoms in the residue template must be different to those in any of its associated chain templates. Also note that you can (and indeed will have to!) refer to atoms that are present in the associated chain templates. In the example in above you can see that the only atom in the residue template is the united-atom ‘CB’, and that this is built from the ‘CA’, ‘N’ and ‘C’ atoms of its associated chain templates. This means that all of the chain templates associated with this residue template must include atoms named ‘CA’, ‘N’ and ‘C’. If these atoms don’t exist then ProtoMS will print many messages to the WARNING stream, and the simulation will fail.

ProtoMS will use the non-dummy bonds present in the residue template to find all of the implicit (additional) angles and dihedrals. If one of the bonds connect the sidechain to the backbone (one of the bonds should!), then the implicit angles and dihedrals between the sidechain and backbone will also be found. If you do not want the energy of these implicit angles and dihedrals to be evaluated then you need to specify them in the residue template with the \sphinxcode{\sphinxupquote{dummy}} option set.

It is possible for a residue template to contain no atoms! While this may sound strange, it is necessary for residues such as glycine in united atom forcefields, or for some terminating residues (e.g. methylamine). The following example is the residue template for OPLS united atom glycine

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} GLYCINE \PYGZhy{} this consists only of the glycine backbones}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}    \PYGZhy{}\PYGZhy{}C\PYGZhy{}\PYGZhy{}CA\PYGZhy{}\PYGZhy{}N\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{mode} \PYG{n}{template}
\PYG{n}{residue} \PYG{n}{GLY}
\PYG{n}{info} \PYG{n}{rotate} \PYG{l+m+mf}{0.5} \PYG{n}{translate} \PYG{l+m+mf}{1.0}
\PYG{n}{backbone} \PYG{n}{first} \PYG{n}{glynterm} \PYG{n}{middle} \PYG{n}{glycenter} \PYG{n}{last} \PYG{n}{glycterm} \PYG{n}{single} \PYG{n}{glysingle}
\PYG{c+c1}{\PYGZsh{} glycine has no atoms, or internals!}
\end{sphinxVerbatim}

\sphinxstylestrong{Solute templates}

Solute templates are used to assign the z-matrix and forcefield parameters to solute molecules. An example solute template for a united atom biphenyl is shown blelow

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mode} \PYG{n}{template}   \PYG{c+c1}{\PYGZsh{} make sure that the parameter file is being read in}
                \PYG{c+c1}{\PYGZsh{} in template mode}

\PYG{c+c1}{\PYGZsh{}                 \textbar{}}
\PYG{c+c1}{\PYGZsh{}     CH3\PYGZhy{}\PYGZhy{}CH2    \textbar{}     CH2\PYGZhy{}\PYGZhy{}CH3        Biphenyl, built as two residues,}
\PYG{c+c1}{\PYGZsh{}    /        \PYGZbs{}   \textbar{}    /        \PYGZbs{}             PH1 and PH2}
\PYG{c+c1}{\PYGZsh{}  CH4        CH1\PYGZhy{}\textbar{}\PYGZhy{}CH1         CH4}
\PYG{c+c1}{\PYGZsh{}    \PYGZbs{}        /   \textbar{}    \PYGZbs{}        /        Note that each atom in a residue}
\PYG{c+c1}{\PYGZsh{}     CH5\PYGZhy{}\PYGZhy{}CH6    \textbar{}     CH6\PYGZhy{}\PYGZhy{}CH5         must have a unique name but}
\PYG{c+c1}{\PYGZsh{}  PH1            \textbar{}              PH2     that atoms in different residues}
\PYG{c+c1}{\PYGZsh{}                                        may have the same name}
\PYG{n}{solute} \PYG{n}{biphenyl}
\PYG{n}{info} \PYG{n}{translate} \PYG{l+m+mf}{1.0} \PYG{n}{rotate} \PYG{l+m+mf}{5.0}

\PYG{c+c1}{\PYGZsh{} Atoms in the first, PH1 residue}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{atom} \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{DM3} \PYG{n}{DUM}  \PYG{n}{DM2} \PYG{n}{DUM}  \PYG{n}{DM1} \PYG{n}{DUM}  \PYG{c+c1}{\PYGZsh{} First three atoms are built}
\PYG{n}{atom} \PYG{n}{CH2} \PYG{n}{PH1}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{DM3} \PYG{n}{DUM}  \PYG{n}{DM2} \PYG{n}{DUM}  \PYG{c+c1}{\PYGZsh{} from the auto\PYGZhy{}generated}
\PYG{n}{atom} \PYG{n}{CH3} \PYG{n}{PH1}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH2} \PYG{n}{PH1}  \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{DM3} \PYG{n}{DUM}  \PYG{c+c1}{\PYGZsh{} dummy atoms (DM1\PYGZhy{}DM2\PYGZhy{}DM3)}
\PYG{n}{atom} \PYG{n}{CH4} \PYG{n}{PH1}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH3} \PYG{n}{PH1}  \PYG{n}{CH2} \PYG{n}{PH1}  \PYG{n}{CH1} \PYG{n}{PH1}
\PYG{n}{atom} \PYG{n}{CH5} \PYG{n}{PH1}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH4} \PYG{n}{PH1}  \PYG{n}{CH3} \PYG{n}{PH1}  \PYG{n}{CH2} \PYG{n}{PH1}
\PYG{n}{atom} \PYG{n}{CH6} \PYG{n}{PH1}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH5} \PYG{n}{PH1}  \PYG{n}{CH4} \PYG{n}{PH1}  \PYG{n}{CH3} \PYG{n}{PH1}

\PYG{c+c1}{\PYGZsh{} Atoms in the second, PH2 residue}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{atom} \PYG{n}{CH1} \PYG{n}{PH2}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{CH2} \PYG{n}{PH1}  \PYG{n}{CH3} \PYG{n}{PH1}
\PYG{n}{atom} \PYG{n}{CH2} \PYG{n}{PH2}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH1} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{CH2} \PYG{n}{PH1}
\PYG{n}{atom} \PYG{n}{CH3} \PYG{n}{PH2}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH2} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH1}
\PYG{n}{atom} \PYG{n}{CH4} \PYG{n}{PH2}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH3} \PYG{n}{PH2}  \PYG{n}{CH2} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH2}
\PYG{n}{atom} \PYG{n}{CH5} \PYG{n}{PH2}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH4} \PYG{n}{PH2}  \PYG{n}{CH3} \PYG{n}{PH2}  \PYG{n}{CH2} \PYG{n}{PH2}
\PYG{n}{atom} \PYG{n}{CH6} \PYG{n}{PH2}  \PYG{l+m+mi}{20} \PYG{l+m+mi}{20}  \PYG{n}{CH5} \PYG{n}{PH2}  \PYG{n}{CH4} \PYG{n}{PH2}  \PYG{n}{CH3} \PYG{n}{PH2}
\PYG{c+c1}{\PYGZsh{} Bonds between atoms \PYGZhy{} residue PH1}
\PYG{n}{bond} \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{CH2} \PYG{n}{PH1}
\PYG{n}{bond} \PYG{n}{CH2} \PYG{n}{PH1}  \PYG{n}{CH3} \PYG{n}{PH1}
\PYG{n}{bond} \PYG{n}{CH3} \PYG{n}{PH1}  \PYG{n}{CH4} \PYG{n}{PH1}
\PYG{n}{bond} \PYG{n}{CH4} \PYG{n}{PH1}  \PYG{n}{CH5} \PYG{n}{PH1}
\PYG{n}{bond} \PYG{n}{CH5} \PYG{n}{PH1}  \PYG{n}{CH6} \PYG{n}{PH1}
\PYG{n}{bond} \PYG{n}{CH6} \PYG{n}{PH1}  \PYG{n}{CH1} \PYG{n}{PH1}
\PYG{c+c1}{\PYGZsh{} interconnecting bond}
\PYG{n}{bond} \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{CH1} \PYG{n}{PH2}
\PYG{c+c1}{\PYGZsh{} bonds in residue PH2}
\PYG{n}{bond} \PYG{n}{CH1} \PYG{n}{PH2}  \PYG{n}{CH2} \PYG{n}{PH2}
\PYG{n}{bond} \PYG{n}{CH2} \PYG{n}{PH2}  \PYG{n}{CH3} \PYG{n}{PH2}
\PYG{n}{bond} \PYG{n}{CH3} \PYG{n}{PH2}  \PYG{n}{CH4} \PYG{n}{PH2}
\PYG{n}{bond} \PYG{n}{CH4} \PYG{n}{PH2}  \PYG{n}{CH5} \PYG{n}{PH2}
\PYG{n}{bond} \PYG{n}{CH5} \PYG{n}{PH2}  \PYG{n}{CH6} \PYG{n}{PH2}
\PYG{n}{bond} \PYG{n}{CH6} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH2}

\PYG{c+c1}{\PYGZsh{} only one flexible dihedral \PYGZhy{} interconnecting dihedral}
\PYG{n}{dihedral} \PYG{n}{CH2} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH2}  \PYG{n}{CH1} \PYG{n}{PH1}  \PYG{n}{CH2} \PYG{n}{PH1}  \PYG{n}{flex} \PYG{l+m+mf}{5.0}
\end{sphinxVerbatim}

The format for a solute template is very similar to that of a residue template. The main difference is that while residue atoms are uniquely identified by thier atom name, solute atoms are uniquely identified by the combined atom name and residue name, e.g. the biphenyl atom CH2 PH2 is a different atom to CH2 PH1.

A new solute template is started with the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solute} \PYG{n}{name}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{name}} is the uniquely identifying name of the solute template. As with the other templates, if a solute template with this name already exists, then it is overwritten by the new template. The name of the solute template can be any length up to 300 characters that can include spaces. Valid solute names thus include ‘biphenyl’ and ‘test ligand 132B’ Note that ProtoMS is insensitive to case, so it doesn’t matter how you capitalise the solute name as ProtoMS will ignore it. The solute names ‘biphenyl’, ‘BIPHENYL’ and ‘BiPhenyl’ are all equivalent. ProtoMS will also strip the spaces before and after the solute name, and will replace multiple spaces within the name with single spaces, e.g. ‘ test ligand 132B ’ is equivalent to ‘test ligand 132B’.

The format and meaning of the valid lines in a solute template file are very similar to those of a residue and chain template. The line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{info} \PYG{n}{rotate} \PYG{n}{rotdel} \PYG{n}{translate} \PYG{n}{trandel}
\end{sphinxVerbatim}

has exactly the same format for a solute template as it does for a residue template, and the meaning is very similar. In this case this line sets the maximum amounts that the solute molecule as a whole will be rotated and translated by, in units of A and degrees respectively. This line is optional, and it is not present then the default maximum rotation and translation amounts are both zero. Note that translation and rotation of a solute is about the location of the first automatically added dummy atom at the center of geometry of the solute.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atom} \PYG{n}{nam} \PYG{n}{res} \PYG{n}{par0} \PYG{n}{par1} \PYG{n}{bnd} \PYG{n}{bndres} \PYG{n}{ang} \PYG{n}{angres} \PYG{n}{dih} \PYG{n}{dihres}
\end{sphinxVerbatim}

This line has a very similar meaning to the atom line of the residue and chain templates. In this case, this line identifies the solute atom called \sphinxcode{\sphinxupquote{nam}}, in residue named \sphinxcode{\sphinxupquote{res}}, and assigns it the CLJ parameters \sphinxcode{\sphinxupquote{par0}} at \(\lambda\) = 0.0 and \sphinxcode{\sphinxupquote{par1}} at \(\lambda\) = 1.0. The bond, angle and dihedral z-matrix atoms that are used to build this atom are the atom named \sphinxcode{\sphinxupquote{bnd}} in residue \sphinxcode{\sphinxupquote{bndres}}, the atom named \sphinxcode{\sphinxupquote{ang}} in residue \sphinxcode{\sphinxupquote{angres}} and the atom named \sphinxcode{\sphinxupquote{dih}} in residue \sphinxcode{\sphinxupquote{dihres}}. These z-matrix atoms must have appeared in the solute template before this atom. Note that this line does not add a bond, angle or dihedral between any of these atoms. The atom lines only specify how to move and construct the solute, not how to evaluate its energy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{res1} \PYG{n}{nam2} \PYG{n}{res2}
\end{sphinxVerbatim}

This line adds a bond between solute atoms \sphinxcode{\sphinxupquote{nam1}} in residue \sphinxcode{\sphinxupquote{res1}} and \sphinxcode{\sphinxupquote{nam2}} in residue \sphinxcode{\sphinxupquote{res2}}. You can make this bond flexible by using the \sphinxcode{\sphinxupquote{flex}} keyword in the same way as described for the chain and residue templates (as long as this bond is used in one of the atom z-matrix lines to construct one of the atoms). You can also use the same \sphinxcode{\sphinxupquote{dummy}} keyword as the chain and residue templates to turn this into a dummy bond. As in those cases, a dummy bond is a non-bond, and has the effect of stating that the two atoms are not bonded together. The forcefield parameters for this bond are obtained via the AMBER types of the two solute atoms. However these parameters may be overridden through the use of the param keyword as used in the chain and residue templates, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bond} \PYG{n}{nam1} \PYG{n}{res1} \PYG{n}{nam2} \PYG{n}{res2} \PYG{n}{param} \PYG{n}{par0} \PYG{n}{par1}
\end{sphinxVerbatim}

This line states that this bond uses bond parameter \sphinxcode{\sphinxupquote{par0}} at \(\lambda\) = 0.0 and bond parameter \sphinxcode{\sphinxupquote{par1}} at \(\lambda\) = 1.0. The angles, Urey Bradley terms and dihedrals in the solute are specified in a very similar manner

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{angle} \PYG{n}{nam1} \PYG{n}{res1} \PYG{n}{nam2} \PYG{n}{res2} \PYG{n}{nam3} \PYG{n}{res3}

\PYG{n}{ureybradley} \PYG{n}{nam1} \PYG{n}{res1} \PYG{n}{nam2} \PYG{n}{res2} \PYG{n}{nam3} \PYG{n}{res3}

\PYG{n}{dihedral} \PYG{n}{nam1} \PYG{n}{res1} \PYG{n}{nam2} \PYG{n}{res2} \PYG{n}{nam3} \PYG{n}{res3} \PYG{n}{nam4} \PYG{n}{res4}
\end{sphinxVerbatim}

the \sphinxcode{\sphinxupquote{dummy}}, \sphinxcode{\sphinxupquote{flex}} and \sphinxcode{\sphinxupquote{param}} options may be used with these lines, with the exception of the \sphinxcode{\sphinxupquote{ureybradley}} line, which cannot use the \sphinxcode{\sphinxupquote{flex}} option. ProtoMS only uses the bonds listed in the solute template to work out which atoms are bonded together. ProtoMS does not try to guess which atoms are bonded together, so you will need to add all bonds that exist in the solute to the template file to ensure that the intramolecular energy is calculated correctly. ProtoMS will use these explicitly added, non-dummy bonds to work out all of the implicit (additional) angles and dihedrals in the solute. You do not need to include any additional angles or dihedrals in the solute template as they are added automatically by ProtoMS. If you do not want the energy of an additional angle or dihedral to be evaluated then you will need to add it to the template with the dummy option set. This is the same behaviour as in the chain and
residue templates.

Solute templates have one extra type of valid line compared to chain or residue templates. This line is used to describe how the geometry of the solute changes with \(\lambda\)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{variable} \PYG{n}{nam} \PYG{n}{res} \PYG{n+nb}{type} \PYG{n}{val0} \PYG{n}{val1}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{nam}} and \sphinxcode{\sphinxupquote{res}} are the name and residue of the atom that changes geometry with \(\lambda\). \sphinxcode{\sphinxupquote{typ}} can be either \sphinxstyleemphasis{bond}, \sphinxstyleemphasis{angle} or \sphinxstyleemphasis{dihedral} and describes whether the bond, angle or dihedral changes with \(\lambda\), with \sphinxcode{\sphinxupquote{val0}} giving its value at \(\lambda\) = 0.0 and \sphinxcode{\sphinxupquote{val1}} giving its value at \(\lambda\) = 1.0. These variable geometry lines are very useful for free energy calculations where an atom is being ‘switched off’ by turning it into a dummy atom. You can use the variable geometry line to shrink the bond length to its z-matrix bonded atom, thus having the effect of pulling it within the van der waals sphere of the bonded atom. This prevents instabilities that may arise when the atom is close to being fully switched off.

Another use for variable geometry lines is to perform free energy calculations along structural coordinates, e.g. pulling two molecules apart. You can perform these sorts of calculations in ProtoMS by loading both molecules as a single solute, with no bonds between the two molecules. You could then use a variable geometry line to change the distance between the two molecules with respect to \(\lambda\).

Yet another use of geometry variation is to calculate the energy along an internal degree of freedom, e.g. by performing a torsion drive for the purposes of generating a dihedral forcefield parameter.

While \(\lambda\) may be used to change the forcefield parameters of any atom of any molecule in the entire system, only solutes may have their geometry changed with respect to \(\lambda\). This is because geometry variations are implemented by making two copies of the solute and using these to shadow the original, reference solute. While you will not see these shadow solutes, they will reduce the number of solutes that you can load by two for every solute of variable geometry that you load. This means that while you can load a maximum of 50 solutes, you can only load a maximum of 16 solutes that have variable geometry.

\sphinxstylestrong{Solvent Templates}

Solvent molecules are implemented as rigid molecules in ProtoMS, so they do not require a z-matrix, nor do they have any internal degrees of freedom or energy terms. Solvent templates are thus much more simple than chain, residue and solute templates as they are only used to assign the forcefield parameters of the solvent molecules. An example solvent template for TIP4P water is shown in below

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}
\PYGZsh{} TIP4P (T4P)
\PYGZsh{}
\PYGZsh{}     O00       dist(OH) = 0.9572 A
\PYGZsh{}   /  \textbar{}  \PYGZbs{}     dist(OM) = 0.15 A
\PYGZsh{} H01 M03 H02   ang(HOH) = 104.52 deg
\PYGZsh{}

mode clj
par 2003  OW  8  0.000  3.15363  0.1550
par 2004  HW  1  0.520  0.0      0.0
par 2005  ??  0 \PYGZhy{}1.040  0.0      0.0

mode template
solvent T4P
info translate 0.15 rotate 15.0
atom O00 2003 2003
atom H01 2004 2004
atom H02 2005 2005
atom M03 2006 2006
\end{sphinxVerbatim}

A new solvent template is signified by the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solvent} \PYG{n}{name}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{name}} is the uniquely identifying name of the solvent template. As in the cases of the other templates, if a solvent template with this name has been previously loaded, then it is overwritten. Solvent molecules are named using the residue name column from the PDB file, so the solvent name is limited to four characters. There are only two types of line that are valid within a solvent template. These are an info line, that has the same meaning as that in the solute templates, and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{atom} \PYG{n}{nam} \PYG{n}{par0} \PYG{n}{par1}
\end{sphinxVerbatim}

which states that the solvent atom called \sphinxcode{\sphinxupquote{nam}} has CLJ parameters \sphinxcode{\sphinxupquote{par0}} at \(\lambda\) = 0.0 and \sphinxcode{\sphinxupquote{par1}} at \(\lambda\) = 1.0. The file \sphinxstyleemphasis{solvents.ff} in the \sphinxstyleemphasis{parameter} directory contains the solvent templates for a large number of standard solvents. All of the CLJ parameters used in this file range from 2001 to 2999.

\sphinxstylestrong{GCsolute Templates}

GCsolute molecules are implemented as rigid molecules in ProtoMS, like solvents, so they do not require a z-matrix, nor do they have any internal degrees of freedom or energy terms. GCsolutes templates are thus much more simple than chain, residue and solute templates as they are only used to assign the forcefield parameters of the GCsolute molecules. An example GCsolute template for TIP4Pg water is shown below

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
mode template
grand WAT
info translate 0.15 rotate 15
atom   O00  8003 8003
atom   H01  8004 8004
atom   H02  8004 8004
atom   M03  8005 8005
mode clj
\PYGZsh{}parameter atm proton\PYGZhy{}num charge(\textbar{}e\textbar{}) sigma(A) epsilon(kcal mol\PYGZhy{}1)
par  8003   OW    8    0.000      3.15363    0.1550
par  8004   HW    1    0.520      0.0        0.0
par  8005   ??    0   \PYGZhy{}1.040      0.0        0.0
\end{sphinxVerbatim}

A new GCsolute template is signified by the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grand} \PYG{n}{name}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{name}} is the uniquely identifying name of the GCsolute template. As in the cases of the other templates, if a GCsolute template with this name has been previously loaded, then it is overwritten. GCsolute molecules are named using the residue name column from the PDB file, so the name is limited to four characters. There are only two types of line that are valid within a GCsolute template. These are an info line, that has the same meaning as that in the solute templates, and :
\begin{quote}

atom nam par0 par1
\end{quote}

which states that the GCsolute atom called \sphinxcode{\sphinxupquote{nam}} has CLJ parameters \sphinxcode{\sphinxupquote{par0}} at \(\lambda\)  = 0.0 and \sphinxcode{\sphinxupquote{par1}} at \(\lambda\) = 1.0. GCsolute templates should have values of CLJ parameters used in the files ranging from 8001 to 8999.


\section{Automated Creation of Parameter and Template Files}
\label{\detokenize{protoms:automated-creation-of-parameter-and-template-files}}
Using an unsupported protein forcefield with ProtoMS requires the creation of a pair of parameter and template files. This process has been automated through a set of scripts that are able to import amber forcefield files and produce the necessary inputs for ProtoMS. For details of this please see the README in \$PROTOMSHOME parameter/dev.


\section{Protein File}
\label{\detokenize{protoms:protein-file}}\label{\detokenize{protoms:protpdb}}
Proteins are loaded from protein files. The names of the protein files are specified using the proteinN command described in section {\hyperref[\detokenize{protoms:incmd}]{\sphinxcrossref{\DUrole{std,std-ref}{Specifying input files}}}}. The protein file is just a standard PDB format file. The name of the protein contained within this file is taken from the HEADER line of the PDB. e.g.:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HEADER} \PYG{n}{p38} \PYG{n}{kinase}
\end{sphinxVerbatim}

The protein name may contain spaces, though ProtoMS will strip any spaces before or after the name, and will collapse multiple spaces into a single space (much like it does with the solute name).

ProtoMS tries to follow the PDB format when it reads in PDB lines (see \sphinxurl{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2} frame.html). Atom names and coordinates are given on lines that start with ATOM or HETATM. As with the rest of ProtoMS, the capitalisation of these keywords is not important. Unlike the rest of ProtoMS, these lines have a strict format with respect to in which column each piece of data is recorded.

ProtoMS constructs the protein chain from the residue order that it reads in from the PDB file. This means that if a protein file contains residues numbered 5, 10 and 2, in that order, then ProtoMS will construct a protein chain with the sequence 5-10-2. ProtoMS will not try to be clever and numerically order your residues for you! One requirement when loading a protein PDB is that all atoms that are part of a residue are together within the PDB file. It is not possible to scatter atoms from one residue throughout the entire PDB file. In addition, all residues in the protein must have a unique residue number, and all atoms within the same residue must have unique names. ProtoMS loads the protein and assigns residue templates based on the residue names that it finds in the PDB filele. If ProtoMS cannot find a residue template that matches the residue name then it prints a message to the WARNING stream and then skips the residue. ProtoMS will use the residue and chain templates that it finds to work out which atom names should be present in the residue. If the PDB file provides an atom that matches the atom name, then ProtoMS assigns that atom from the template. If the PDB file does not provide an atom that matches the name, then if the atom name corresponds to one of the required bbatoms, then ProtoMS will print a severe message to the WARNING stream and will then skip the residue. If the missing atom is not a bbatom, then if the residue or chain templates provide zmat information for that atom then the coordinates for the atom are constructed automatically (and a message output to the WARNING stream). If no zmat information is available for this atom, then it is skipped and a severe message is output to the WARNING stream. Finally, if the PDB file provides an atom that is not part of the template, then that atom is skipped.

ProtoMS can only read a single protein chain from a PDB file. This means that you must split multi-chain PDB files into several files, and that PDBs using the ‘A’ or ‘B’ chain notation will be read incorrectly. If ProtoMS reads TER line, then it will print a message to the WARNING stream, and will then skip the rest of the PDB file. ProtoMS is capable of reading a wide variety of PDB files, and of fixing many of the errors that it encounters. Despite this, I would recommend that you do not just use a PDB direct from the databank, but that you first preprocess the PDB with another software package to ensure that the PDB is correct, and that polar hydrogens and titratable residues are included correctly.


\section{Solute File}
\label{\detokenize{protoms:solute-file}}\label{\detokenize{protoms:solpdb}}
Solute input files are very similar to protein input files. Solute files are standard PDB format coordinate files. The name of the solute is read from the HEADER line in an identical manner to the name of a protein, e.g.:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{header} \PYG{n}{biphenyl}
\end{sphinxVerbatim}

The solute name is used to locate the solute template, which is used to assign the z-matrix and forcefield parameters of the solute.

The solute PDB file has the same format as a standard PDB, with the requirements that all atoms belonging to a residue are together in the PDB, that each residue name is unique, and that all atom names within a residue are unique.

As is the case for protein files, ProtoMS will only read a single solute from each solute PDB file, and will skip the rest of the solute PDB if it encounters a TER line. It is intended that a future version of ProtoMS will remove this restriction.

ProtoMS will use the solute name to find the solute template for this molecule, and will then try to locate each atom from the template within the PDB file. If the atom does not exist then ProtoMS can automatically build the missing atom as long as its zmat information has been provided. If ProtoMS cannot build the atom then it skips it, after writing severe messages to the WARNING stream. If the PDB contains atoms that are not listed in the template then these atoms are ignored.


\section{GCsolute File}
\label{\detokenize{protoms:gcsolute-file}}\label{\detokenize{protoms:gcpdb}}
GCsolute input files are very similar to protein input files, except that multiple GCsolutes can be loaded at once. GCsolute files are standard PDB format coordinate files. The name of each solvent molecule is taken from the residue name, and it is this name that is used to locate the template for each GCsolute molecule.


\section{Solvent File}
\label{\detokenize{protoms:solvent-file}}\label{\detokenize{protoms:solventpdb}}
Solvent input files are very similar to protein and solute input files. Solvent files are standard PDB format coordinate files. Unlike the protein and solute files, many solvent molecules may be contained within each solvent input file. The name of each solvent molecule is taken from the residue name, and it is this name that is used to locate the template for each solvent molecule. ProtoMS will then try to locate each atom from the template within the PDB file. If the atom cannot be found then ProtoMS will write a severe message to the WARNING stream and will skip that atom. If the PDB contains atoms that are not part of the template then they are skipped. Note that ProtoMS will take the coordinates of the solvent molecule from the PDB file and will make no attempt to ensure that the internal geometry of the solvent molecule is correct for the template model (e.g. that
TIP4P water has an O-H bond length of 0.9572 A).

If multiple solvent files are loaded, then the solvents from the newer files are appended onto the list of solvents loaded from the previous file. If solvent file 1 contains 340 solvent molecules, and solvent file 2 contains 10 solvent molecules, then the solvents from file 1 will be loaded as solvent molecules 1-340, and those from solvent file 2 will be loaded as solvent molecules 341-350.

\sphinxstylestrong{Boundary conditions}

As well as containing the coordinates of the solvent molecules, the solvent file may be used to specify the parameters needed for the boundary conditions. To do this, the solvent file must include a HEADER line that has one of the following formats

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HEADER} \PYG{n}{box} \PYG{n}{dimx} \PYG{n}{dimy} \PYG{n}{dimz}
\end{sphinxVerbatim}

This states that the solvent file contains a box of solvent of dimensions \sphinxtitleref{dimx} A by \sphinxtitleref{dimy} A by \sphinxtitleref{dimz} A, with the box centered on the origin. Note that ProtoMS will not check to see if this information is correct, so you will need to ensure that that no solvent molecules lie outside of this box.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HEADER} \PYG{n}{box} \PYG{n}{ox} \PYG{n}{oy} \PYG{n}{oz} \PYG{n}{tx} \PYG{n}{ty} \PYG{n}{tz}
\end{sphinxVerbatim}

This states that the solvent file contains a box of solvent with the bottom-left-back corner located at coordinates (\sphinxtitleref{ox},{}`oy{}`,{}`oz{}`) A and the top-right-front corner located at coordinates (\sphinxtitleref{tx},{}`ty{}`,{}`tz{}`) A. Again ProtoMS will not check that this information is accurate!

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HEADER} \PYG{n}{cap} \PYG{n}{ox} \PYG{n}{oy} \PYG{n}{oz} \PYG{n}{rad} \PYG{n}{k}
\end{sphinxVerbatim}

This states that the solvent file contains solvent molecules restrained to be within a spherical cap of \sphinxtitleref{radius} rad A, centered at coordinates (\sphinxtitleref{ox},{}`oy{}`,{}`oz{}`) A, using a half-harmonic force constant of k kcal mol-1 A -2 . ProtoMS will not check to see whether or not this information is accurate.

Only one HEADER line may be included in each solvent file. How ProtoMS interprets these HEADER lines depends on which boundary conditions had been set for the simulation.
\begin{enumerate}
\item {} 
If no boundaries had been set for the simulation, then any information in the solvent files is ignored.

\item {} 
If a solvent cap had been set for the simulation, then any information in the solvent files is ignored and the solvent cap parameters are taken from the simulation parameter.

\item {} 
If a solvent box had been set then the solvent box dimensions are initially taken from the simulation parameter. However if any of the loaded solvent files specify the solvent box size then the solvent box dimensions are increased to encompass both the initial dimensions and the solvent box dimensions.

\end{enumerate}

4. If ‘solvent’ boundaries had been set for the simulation then the boundaries used will be those obtained from the first solvent file that is loaded that contains a HEADER line. If none of the loaded solvent files contain a HEADER line then a warning is printed and no boundary conditions are used. Note that by default ‘solvent’ boundaries are set for all simulations.
Warnings are printed if solvent files contain conflicting boundary types (e.g. specifying a box when a spherical solvent cap is used), or if multiple solvent files supply solvent cap parameters. If multiple solvent files supply solvent box dimensions then the box is increased to the minimum size necessary to encompass all of the solvent boxes.

To make things simple, I recommend that you use one solvent file to describe your boundary conditions, and use the default option of specifying solvent boundaries via the solvent file (use \sphinxcode{\sphinxupquote{boundary solvent}} in your command file, or do not supply a \sphinxcode{\sphinxupquote{boundary}} value as \sphinxcode{\sphinxupquote{solvent}} is the default).

ProtoMS will print out the boundary dimension to any output PDB file if that file contains solvent molecules.


\section{Restart File}
\label{\detokenize{protoms:restart-file}}
The restart file is used to save the coordinates of the entire system to a high precision such that they can be loaded up at a future point, or by another ProtoMS simulation. The format of the restart file is not yet fixed, so unfortunately there is the possibility that different versions of ProtoMS may not be able to read each other’s restart files. This is considered a bug, and it is a development aim to stabilise the restart file format.

The restart file has deliberately been written as a human-readable text file. This means that the restart file is larger than it could be, but that it should be possible to manually edit a restart file, and understand its contents. If you wish to save space then I recommend that you compress the restart file via bzip2 or gzip. While the
restart file is human-readable and editable, I recommend that you do not attempt to change the restart file unless you have a good understanding of the writerestart.F and readrestart.F source files that are used by ProtoMS to read and write them.

The restart file only contains the coordinates of the entire system and the parameters needed for the boundary conditions. This file does not contain energies or energy averages, as these are output via the RESULTS stream. The restart file does not contain information about the connectivity or setup of the system as these are contained in the command file and the protein, solute, solvent and parameter files.

You can write a restart file at any point during your simulation, and you can write as many restart files as you wish. This means that you can start your simulation with a bit of equilibration, and write a restart file for the final equilibrated configuration, and then run some production. This is a strategy used by many of the examples in the next chapter.

You can read a restart file at any point during your simulation, and you can read restart files as many times as you desire during a simulation. A restart file merely resets the coordinates of the system to those saved when the restart file was written. This means that you could run multiple chunks of a simulation from the same equilibrated configuration by reading in a restart file from the equilibrated configuration before performing each chunk of production. Note that you can only read a restart file into the same system that was used to write that restart file. If you try to load an incompatible restart file then the program will print lots of warnings and will probably close down!


\chapter{protoms.py}
\label{\detokenize{protomspy:protoms-py}}\label{\detokenize{protomspy::doc}}
This program is used to setup a ProtoMS simulation. It was made with usability at highest priority. The only input that should be necessary is a couple of prepared PDB files containing the molecules one would like to simulate.

The program will create force field for small molecules, setup the protein and solvate the prepared system. At the moment it can setup the following types of simulations:
\begin{itemize}
\item {} 
Equilibration

\item {} 
Sampling

\item {} 
Dual-topology free energy

\item {} 
Single-topology free energy

\item {} 
Grand Canonical Monte Carlo (GCMC)

\item {} 
Just Add Waters, stage 1 and 2 (JAWS-1, JAWS-2)

\end{itemize}

The program will create files and inputs based on experience that should work in most situations. However there might be situations where the created settings are not appropriate. One can then use individual tools to make a more custom setup, see \sphinxhref{tools.html}{this}. One might also have to edit the files manually.

\sphinxstylestrong{Syntax:}
\begin{quote}

\sphinxcode{\sphinxupquote{protoms.py {[}-s none\textbar{}equilibration\textbar{}sampling\textbar{}dualtopology\textbar{}singletopology\textbar{}gcmc\textbar{}jaws1\textbar{}jaws2{]} {[}-f folder1 folder2{]} {[}-p protein.pdb{]} {[}-sc scoop.pdb{]} {[}-l lig1.pdb lig2.pdb ...{]} {[}-t template1 template2 ...{]} {[}-w water.pdb{]} {[}-c cmdfile{]} {[}-r nrepeats \textbar{} prefix{]} {[}-{-}outfolder folder{]} {[}-{-}atomnames namefile{]} {[}-{-}watmodel tip4p\textbar{}tip3p{]} {[}-{-}waterbox watbox{]} {[}-{-}charge charge1 charge2{]} {[}-{-}singlemap mapfile{]}  {[}-{-}center cent{]} {[}-{-}innercut icut{]} {[}-{-}outercut ocut{]} {[}-{-}flexin sidechain\textbar{}flexible\textbar{}rigid{]} {[}-{-}flexout sidechain\textbar{}flexible\textbar{}rigid{]} {[}-{-}scooplimit N{]} {[}-{-}capradius radius{]} {[}-{-}lambdas nlambdas \textbar{} lambda1 lambda2 ...{]} {[}-{-}adams B1 B2 ...{]} {[}-{-}jawsbias bias{]} {[}-{-}gcmcwater wat.pdb \textbar{} N{]} {[}-{-}gcmcbox box.pdb \textbar{} X Y Z A B C{]} {[}-{-}nequil N{]} {[}-{-}nprod N{]} {[}-{-}dumpfreq N{]} {[}-{-}absolute{]} {[}-{-}dovacuum{]} {[}-{-}testrun{]} {[}-{-}cleanup{]}}}
\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-s none\textbar{}equilibration\textbar{}sampling\textbar{}dualtopology\textbar{}singletopology\textbar{}gcmc\textbar{}jaws1\textbar{}jaws2}} = the type of simulation to perform}] \leavevmode
optional, default = \sphinxcode{\sphinxupquote{none}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-f folder1 folder2}} = name of folders to search for input files}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-p protein.pdb}} = the name of the protein PDB file}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-o scoop.pdb}} = the name of a protein scoop PDB file}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-l lig1.pdb lig2.pdb ...}} = the name(s) of PDB file(s) containing ligand(s)}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-t template1 template2 ...}} = the name(s) of ProtoMS template file(s) that needs to be loaded}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-w water.pdb}} = the name of a PDB file with bulk water for the protein}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-c cmdfile}} = the prefix for the created ProtoMS command file}] \leavevmode
optional, default = \sphinxcode{\sphinxupquote{run}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-r nrepeats \textbar{} prefix}} = setup independent repeats of the simulation}] \leavevmode
optional, default = 1
\sphinxcode{\sphinxupquote{nrepeat}} = repeats a created from 1 to \sphinxcode{\sphinxupquote{nrepeat}}
\sphinxcode{\sphinxupquote{prefix}} = a single repeat is created, but prefix is appended to folders and files

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}outfolder folder}} = the ProtoMS output folder}] \leavevmode
optional, default = \sphinxcode{\sphinxupquote{""}} (empty string)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}atomnames namefile}} = the name of file containing conversion instructions}] \leavevmode
optional, no default
if not given, takes the one in \sphinxcode{\sphinxupquote{\$PROTOMSHOME/data}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}watermodel tip4p\textbar{}tip3p}} = the water model to use}] \leavevmode
optional, default = \sphinxcode{\sphinxupquote{tip4p}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}waterbox watbox}} = the name a of a PDB file with a pre-equilibrated water box}] \leavevmode
optional, no default
if not given, takes one in \sphinxcode{\sphinxupquote{\$PROTOMSHOME/data}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}charge charge1 charge2}} … = the charges of the ligands}] \leavevmode
optional, default = 0

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}singlemap mapfile}} = the correspondence map for single-topology setup}] \leavevmode
optional, no default

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}center cent}} = the centre of the scoop}] \leavevmode
optional, default = 0.0,0.0,0.0

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}innercut icut}} == the inner region cut-off in Angstroms}] \leavevmode
optional, default = 16.9 A

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}outercut ocut}} == the outer region cut-off in Angstroms}] \leavevmode
optional, default = 20.0 A

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}flexin sidechain\textbar{}flexible\textbar{}rigid}} = determine the flexibility of the inner region}] \leavevmode
optional, default = \sphinxcode{\sphinxupquote{flexible}}
\sphinxcode{\sphinxupquote{sidechain}} = only the sidechains will be sampled in the simulation
\sphinxcode{\sphinxupquote{flexible}} = both sidechain and backbone will be sampled in the simulation
\sphinxcode{\sphinxupquote{rigid}} = no residues will be sampled

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}flexout sidechain\textbar{}flexible\textbar{}rigid}} = determine the flexibility of the outer region}] \leavevmode
optional, default = \sphinxcode{\sphinxupquote{sidechain}}
\sphinxcode{\sphinxupquote{sidechain}} = only the sidechains will be sampled in the simulation
\sphinxcode{\sphinxupquote{flexible}} = both sidechain and backbone will be sampled in the simulation
\sphinxcode{\sphinxupquote{rigid}} = no residues will be sampled

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}scooplimit N}} = the minimum removed number of residues in a scoop}] \leavevmode
optional, default = 10

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}capradius radius}} = the radius of the droplet solvating the protein}] \leavevmode
optional, default = 30

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}lambdas nlambdas \textbar{} lambda1 lambada2}} … = specification of \(\lambda\); space for free energy calculations}] \leavevmode
optional, default = 16
if a single value is given, this number of \(\lambda\)-values is created uniformly from 0 to 1
if a list of values are given, this is the \(\lambda\)-values to use

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}adams B1 B2}} … = the Adams parameter for GCMC}] \leavevmode
optional, default = 0

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}jawsbias bias}} = the bias to apply in JAWS-2 simulations}] \leavevmode
optional, default = 0

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}gcmcwater wat.pdb \textbar{} N}} = the name of a PDB file with reservoir waters for GCMC and JAWS-1 or an integer}] \leavevmode
optional, no default
if an integer is given this corresponds to the number of water to add to the GCMC/JAWS-1 box

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}gcmcbox box.pdb \textbar{} X Y X A B C}} = the name of a PDB file with GCMC or JAWS-1 simulation box dimension or the box dimensions}] \leavevmode
optional, no default
if six numbers are given this corresponds to the origin (first three) and the length (last three) of the box

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}nequil N}} = the number of equilibration moves}] \leavevmode
optional, default = 5E6

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}nprod N}} = the number of production moves}] \leavevmode
optional, default = 40E6

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}dumpfreq N}} = the frequency with which output is written to disc}] \leavevmode
optional, default = 1E5

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}absolute}} = turns \sphinxstyleemphasis{on} the setup of absolute free energies}] \leavevmode
optional, default = off

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}dovacuum}} = turns \sphinxstyleemphasis{on} the setup of vacuum simulation}] \leavevmode
optional, default = off

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}testrun}} = turns \sphinxstyleemphasis{on} the setup of a short simulations appropiate for tests}] \leavevmode
optional, default = off

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{-{-}cleanup}} = cleans up extraenous files and put them in a tar-ball}] \leavevmode
optional, default = off

\end{description}

\end{itemize}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{protoms}\PYG{o}{.}\PYG{n}{py}
\PYG{n}{protoms}\PYG{o}{.}\PYG{n}{py}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{sampling} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dovacuum} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{testrun}
\PYG{n}{protoms}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{dualtopology} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{lig2}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{protoms}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{dualtopology} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{absolute}
\PYG{n}{protoms}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{gcmc} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{adams} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\sphinxstylestrong{Notes:}

The program will try to locate previously created files for the protein and ligand in the current working directory or any folder specified with the \sphinxcode{\sphinxupquote{-f}} flag. For ligands the program will replace \sphinxcode{\sphinxupquote{.pdb}} with the appropriate ending, such as \sphinxcode{\sphinxupquote{.prepi}} for Amber prepi files and \sphinxcode{\sphinxupquote{.tem}} for ProtoMS template files.

Starting with just the PDB-files of the ligand(s) and the protein, the program will create the following files in the same folder as those PDB-files
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lig.prepi}} = the z-matrix and atom types of the ligand in Amber format

\item {} 
\sphinxcode{\sphinxupquote{lig.frcmod}} = additional parameters not in GAFF

\item {} 
\sphinxcode{\sphinxupquote{lig.zmat}} = the z-matrix of the ligand used to sample it in the MC simulation

\item {} 
\sphinxcode{\sphinxupquote{lig.tem}} = the complete template (force field) file for the ligand in ProtoMS format

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{li1-li2.tem}} = the combined template file of all ligands}] \leavevmode
the filename is a combination of the residue name of all ligands

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{lig\_box.pdb}} = the box of water solvating the ligand

\item {} 
\sphinxcode{\sphinxupquote{protein\_scoop.pdb}} = the truncated protein structure

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{protein\_pms.pdb}} = the original protein structure with ProtoMS naming convention}] \leavevmode
if the scoop removes to few residues, this file be created instead

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{water.pdb}} = the cap of water solvating the protein system

\end{itemize}

In addition, for dual-topology simulations the following files are created: :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{lig1\_dummy.pdb}} = the dummy particle that the ligand will be perturbed to}] \leavevmode
only created if the \textendash{}absolute flag is set

\end{description}

\end{itemize}

In addition, for single-topology simulations the following files are created:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{li1-li2\_ele.tem}} = the ProtoMS template file for electrostatic single-topology perturbation

\item {} 
\sphinxcode{\sphinxupquote{li1-li2\_vdw.tem}} = the ProtoMS template file for van der Waals single-topology perturbation

\item {} 
\sphinxcode{\sphinxupquote{li1-li2\_comb.tem}} = the ProtoMS template file for combined/single-step single-topology perturbation

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{settings.singlemap}} = the created correspondance map for single topology}] \leavevmode
only named like this if the \textendash{}singlemap argument is not set

\end{description}

\end{itemize}

In addition, for GCMC / JAWS-1 simulations the following files are created:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{gcmc\_box.pdb}} / \sphinxcode{\sphinxupquote{jaws1\_box.pdb}} = the GCMC / JAWS-1 simulation box

\item {} 
\sphinxcode{\sphinxupquote{gcmc\_wat.pdb}} = the GCMC / JAWS-1 reservoire waters

\item {} 
\sphinxcode{\sphinxupquote{water\_clr.pdb}} = the cap of water solvating the protein system, cleared from the GCMC / JAWS-1 simulation box

\end{itemize}

In addition, for JAWS-2 simulations the following files are created:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{jaws2\_watN.pdb}} = the JAWS-2 water}] \leavevmode
each of the water given with the \sphinxcode{\sphinxupquote{-{-}gcmc\_water}} flag will be written to an individual file

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{jaws2\_notN.pdb}} = the rest of the JAWS-2 water

\item {} 
\sphinxcode{\sphinxupquote{water\_clr.pdb}} = the cap of water solvating the protein system, cleared from the GCMC / JAWS-1 simulation box

\end{itemize}

It will create at most three ProtoMS command files, one for the protein simulation, one for the ligand simulation and one for the gas-phase simulation. These can be used to run ProtoMS, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}PROTOMS/protoms3 run\PYGZus{}free.cmd
\end{sphinxVerbatim}

\sphinxstylestrong{Prerequisites:}

The program assumes that both the ligand and the protein is prepared before. This includes for instance protonation. At the moment \sphinxstyleemphasis{only} Amber naming convention is supported.

The progam requires AmberTools to make force field for small molecules.


\chapter{Tools}
\label{\detokenize{tools:tools}}\label{\detokenize{tools::doc}}
In the \sphinxcode{\sphinxupquote{\$PROTOMSHOME/tools}} folder we have collect a range of useful scripts to setup and analyse ProtoMS simulations. Many of them are used by the \sphinxcode{\sphinxupquote{protoms.py}} setup script. In this page we have collected the documentation for these tools with the user as a focus. Developers might be interested in looking at the Python code manual in the \sphinxcode{\sphinxupquote{.doc}} folder.


\section{ambertools.py}
\label{\detokenize{tools:ambertools-py}}

Program to run antechamber and parmchk for a series of PDB-files


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{ambertools}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILES} \PYG{p}{[}\PYG{n}{FILES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{NAME}\PYG{p}{]}
                     \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{CHARGE} \PYG{p}{[}\PYG{n}{CHARGE} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-f, -{-}files]  
the name of the PDB-files
\item [-n, -{-}name]  
the name of the solute

Default: “UNK”
\item [-c, -{-}charge]  
the net charge of each PDB-file
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ambertools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{ambertools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{BNZ}
\PYG{n}{ambertools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzenamide}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+m+mi}{0}
\PYG{n}{ambertools}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{BNZ} \PYG{n}{TOL}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool encapsulate the program \sphinxcode{\sphinxupquote{antechamber}} and \sphinxcode{\sphinxupquote{parmchk}} from the AmberTools suite of programs.

It will produce an Amber prepi-file, containing the z-matrix and atom types of the given solutes, parametrized with the general Amber force field and AM1-BCC charges. It will also produce an Amber frcmod-file with additional parameters not found in the GAFF definition. These files be named after the input \sphinxcode{\sphinxupquote{pdbfile}}, replacing the extension \sphinxcode{\sphinxupquote{.pdb}} with \sphinxcode{\sphinxupquote{.prepi}} and \sphinxcode{\sphinxupquote{.frcmod}}

The \sphinxcode{\sphinxupquote{antechamber}} and \sphinxcode{\sphinxupquote{parmchk}} program should exist in the system path or the AMBERHOME environment variable should be set correctly.


\section{build\_template.py}
\label{\detokenize{tools:build-template-py}}

Program to build a ProtoMS template file


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{build\PYGZus{}template}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PREPI}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{z} \PYG{n}{ZMAT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FRCMOD}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{NAME}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{TRANSLATE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{ROTATE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{alldihs}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gaff} \PYG{n}{GAFF}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-p, -{-}prepi]  
the name of the leap prepi-file
\item [-o, -{-}out]  
the name of the template file

Default: “lig.tem”
\item [-z, -{-}zmat]  
the name of the zmatrix-file, if it exists
\item [-f, -{-}frcmod]  
the name of the frcmod-file, if it exists
\item [-n, -{-}name]  
the name of the solute

Default: “UNK”
\item [-t, -{-}translate]  
maxmium size for translation moves in Angstroms

Default: 0.1
\item [-r, -{-}rotate]  
maxmium size for rotation moves in degrees

Default: 1.0
\item [-{-}alldihs]  
sample improper dihedrals

Default: False
\item [-{-}gaff]  
gaff version to use, gaff14 or gafff16

Default: “gaff16”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{build\PYGZus{}template}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{prepi}
\PYG{n}{build\PYGZus{}template}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{prepi} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{frcmod}
\PYG{n}{build\PYGZus{}template}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{prepi} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{frcmod} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{template} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{BNZ}
\PYG{n}{build\PYGZus{}template}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{prepi} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{frcmod} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool builds a ProtoMS template file for a solute given an Amber prepi file.

If the solute needs parameters not in the specified GAFF release, they should be supplied with the \sphinxcode{\sphinxupquote{frcmodfile}}.

The tool will automatically make an appropriate z-matrix for Monte Carlo sampling. This works in most situations. However, if something is not working properly with the generated z-matrix, one can be supplied in the \sphinxcode{\sphinxupquote{zmatfile}}

The default translational and rotational displacements are based on experience and should be appropriate in most situations.


\section{calc\_bar.py}
\label{\detokenize{tools:calc-bar-py}}
\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}bar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}
\PYG{n}{calc\PYGZus{}bar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mi}{200}
\PYG{n}{calc\PYGZus{}bar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{l+m+mi}{200}
\PYG{n}{calc\PYGZus{}bar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{pw}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool calculates free energies using the Bennets Acceptance Ratio (BAR) method.

The program expects that in the \sphinxcode{\sphinxupquote{directory}} there exist an output folder for each \(\lambda\)-value, eg. \sphinxcode{\sphinxupquote{lam-0.000}} and \sphinxcode{\sphinxupquote{lam-1.000}}

The uncertainty of the free energies is estimated by boostrapping the energy differnces. The number of bootstrap samples is set by the \sphinxcode{\sphinxupquote{nbootstraps}} argument. The procedure is rather slow, so in order to obtain a quick estimate of the free energy, lower this value.

Block estimates can be constructed by combining \sphinxcode{\sphinxupquote{nskip}} and \sphinxcode{\sphinxupquote{nmax}}. For instance, these commands calculates block estimates with a block size of 5 m snapshots

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
for X in 0 50 100 150 200 250 300 350
do
calc\PYGZus{}bar.py \PYGZhy{}d out\PYGZus{}free \PYGZhy{}nskip \PYGZdl{}X \PYGZhy{}nmax 50 \PYGZhy{}b 5 \PYGZhy{}pw \PYGZhy{}pu
done
\end{sphinxVerbatim}


\section{calc\_clusters.py}
\label{\detokenize{tools:calc-clusters-py}}
\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}clusters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{calc\PYGZus{}clusters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{all2}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{calc\PYGZus{}clusters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{all\PYGZus{}clusters}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{calc\PYGZus{}clusters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{complete}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool cluster molecules from a simulation

It will extract the coordinates of all atoms with name equal to \sphinxcode{\sphinxupquote{atom}} in residues with name equal to \sphinxcode{\sphinxupquote{molecule}} in all input files and cluster them using the selected algorithm.  If no atom is specified, the entire molecule will be clustered. By default this atom and residue name is set to match GCMC / JAWS output with the standard water template.


\section{calc\_density.py}
\label{\detokenize{tools:calc-density-py}}

Program to discretize atoms on a 3D grid


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILES} \PYG{p}{[}\PYG{n}{FILES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{RESIDUE}\PYG{p}{]}
                       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{ATOM}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PADDING}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{SPACING}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{EXTENT}\PYG{p}{]}
                       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{NORM}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{p}{\PYGZob{}}\PYG{n}{sphere}\PYG{p}{,}\PYG{n}{gaussian}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{skip} \PYG{n}{SKIP}\PYG{p}{]}
                       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{max} \PYG{n}{MAX}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-f, -{-}files]  
the input PDB-files
\item [-o, -{-}out]  
the name of the output grid-file in DX-format, default=’grid.dx’

Default: “grid.dx”
\item [-r, -{-}residue]  
the name of the residue to extract, default=’wa1’

Default: “wa1”
\item [-a, -{-}atom]  
the name of the atom to extract, default=’o00’

Default: “o00”
\item [-p, -{-}padding]  
the amount to increase the minimum box in each direction, default=2 A

Default: 2.0
\item [-s, -{-}spacing]  
the grid resolution, default=0.5 A

Default: 0.5
\item [-e, -{-}extent]  
the size of the smoothing, i.e. the extent of an atom, default=1A

Default: 1.0
\item [-n, -{-}norm]  
number used to normalize the grid, if not specified the number of input files is used
\item [-t, -{-}type]  
Possible choices: sphere, gaussian

the type  of coordinate smoothing, should be either ‘sphere’, ‘gaussian’

Default: “sphere”
\item [-{-}skip]  
the number of blocks to skip to calculate the density. default is 0. Skip must be greater or equal to 0

Default: 0
\item [-{-}max]  
the upper block to use. default is 99999 which should make sure you will use all the available blocks. max must be greater or equal to 0

Default: 99999
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{all2}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{gcmc\PYGZus{}density}\PYG{o}{.}\PYG{n}{dx}
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{t4p} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{o00}
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mf}{1.0}
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{gaussian}
\PYG{n}{calc\PYGZus{}density}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool discretises atoms on a grid, thereby representing a simulation output as a density.

It will extract the coordinates of all atoms with name equal to \sphinxcode{\sphinxupquote{atom}} in residues with name equal to \sphinxcode{\sphinxupquote{residue}} in all input files and discretise them on a grid. By default this atom and residue name is set to match GCMC / JAWS output with the standard water template.

The produced density can be visualized with most programs, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vmd} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{dx}
\end{sphinxVerbatim}


\section{calc\_dg.py}
\label{\detokenize{tools:calc-dg-py}}

Calculate free energy differences using a range of estimators


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{calc\PYGZus{}dg}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{DIRECTORIES} \PYG{p}{[}\PYG{n}{DIRECTORIES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{LOWER\PYGZus{}BOUND}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{UPPER\PYGZus{}BOUND}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{TEMPERATURE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{pickle} \PYG{n}{PICKLE}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{figures} \PYG{p}{[}\PYG{n}{SAVE\PYGZus{}FIGURES}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{no}\PYG{o}{\PYGZhy{}}\PYG{n}{show}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{NAME}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{subdir} \PYG{n}{SUBDIR}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{pmf}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{test}\PYG{o}{\PYGZhy{}}\PYG{n}{equilibration} \PYG{n}{TEST\PYGZus{}EQUILIBRATION}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{test}\PYG{o}{\PYGZhy{}}\PYG{n}{convergence} \PYG{n}{TEST\PYGZus{}CONVERGENCE}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{estimators} \PYG{p}{\PYGZob{}}\PYG{n}{ti}\PYG{p}{,}\PYG{n}{mbar}\PYG{p}{,}\PYG{n}{bar}\PYG{p}{,}\PYG{n}{gcap}\PYG{p}{\PYGZcb{}} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{n}{ti}\PYG{p}{,}\PYG{n}{mbar}\PYG{p}{,}\PYG{n}{bar}\PYG{p}{,}\PYG{n}{gcap}\PYG{p}{\PYGZcb{}} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{n}{VOLUME}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-d, -{-}directories]  
Location of folders containing ProtoMS output subdirectories. Multiple directories can be supplied to this flag and indicate repeats of the same calculation. This flag may be given multiple times and each instances is treated as an individual leg making up a single free energy difference e.g. vdw and ele contributions of a single topology calculation.
\item [-l, -{-}lower-bound]  
Value between 0 and 1 that determines the proportion to omit from the beginning of the simulation data series.

Default: 0.0
\item [-u, -{-}upper-bound]  
Value between 0 and 1 that determines the proportion to omit from the end of the simulation data series.

Default: 1.0
\item [-t, -{-}temperature]  
Temperature at which the simulation was run. Default=298.15K

Default: 298.15
\item [-{-}pickle]  
Name of file in which to store results as a pickle.
\item [-{-}save-figures]  
Save figures produced by script. Takes optional argument that adds a prefix to figure names.
\item [-{-}no-show]  
Do not display any figures on screen. Does not interfere with \textendash{}save-figures.

Default: False
\item [-n, -{-}name]  
Name of ProtoMS output file containing free energy data. Note that this option will not change the output file used by the gcap estimator from results\_inst.

Default: “results”
\item [-{-}subdir]  
Optional sub-directory for each lambda value to search within for simulation output. This is useful in, for instance, processing only the results of a GCAP calculation at a particular B value.

Default: “”
\item [-{-}pmf]  
Make graph of potential of mean force

Default: False
\item [-{-}test-equilibration]  
Perform free energy calculations 10 times using varying proportions of the total data set provided. Data used will range from 100\% of the dataset down to the proportion provided to this argument
\item [-{-}test-convergence]  
Perform free energy calculations 10 times using varying proportions of the total data set provided. Data used will range from 100\% of the dataset up to the proportion provided to this argument
\item [-{-}estimators]  
Possible choices: ti, mbar, bar, gcap

Choose free energy estimator to use. By default TI, BAR and MBAR are used. Note that the GCAP estimator assumes a different file structure and ignores the \textendash{}subdir flag.

Default: {[}‘ti’, ‘mbar’, ‘bar’{]}
\item [-v, -{-}volume]  
Volume of GCMC region
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}dg}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}
\PYG{n}{calc\PYGZus{}dg}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free1}\PYG{o}{/} \PYG{n}{out\PYGZus{}free2}\PYG{o}{/} \PYG{n}{out\PYGZus{}free3}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mi}{200}
\PYG{n}{calc\PYGZus{}dg}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free1}\PYG{o}{/} \PYG{n}{out\PYGZus{}free2}\PYG{o}{/} \PYG{n}{out\PYGZus{}free3}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{l+m+mi}{200}
\PYG{n}{calc\PYGZus{}dg}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free1}\PYG{o}{/} \PYG{n}{out\PYGZus{}free2}\PYG{o}{/} \PYG{n}{out\PYGZus{}free3}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{ti} \PYG{n}{bar}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool calculates free energies using the method of thermodynamic integration (TI), Bennet’s Acceptance Ratio (BAR) and multi state BAR (MBAR).

The program expects that in the \sphinxcode{\sphinxupquote{directory}}, \sphinxcode{\sphinxupquote{directory2}} etc. there exist an output folder for each \(\lambda\)-value, eg. \sphinxcode{\sphinxupquote{lam-0.000}} and \sphinxcode{\sphinxupquote{lam-1.000}}

If the \sphinxcode{\sphinxupquote{-gr}} flag is set the gradient with respect to \(\lambda\) is plotted and saved to a file called \sphinxcode{\sphinxupquote{gradient.png}}

The MBAR estimator only works if PyMBAR is properly installed and can be loaded as a python library.


\section{calc\_gci.py}
\label{\detokenize{tools:calc-gci-py}}

Calculate water binding free energies using Grand Canonical Integration.


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{calc\PYGZus{}gci}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{LOWER\PYGZus{}BOUND}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{u} \PYG{n}{UPPER\PYGZus{}BOUND}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{TEMPERATURE}\PYG{p}{]}
                   \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{pickle} \PYG{n}{PICKLE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{save}\PYG{o}{\PYGZhy{}}\PYG{n}{figures} \PYG{p}{[}\PYG{n}{SAVE\PYGZus{}FIGURES}\PYG{p}{]}\PYG{p}{]}
                   \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{no}\PYG{o}{\PYGZhy{}}\PYG{n}{show}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{NAME}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{DIRECTORIES} \PYG{p}{[}\PYG{n}{DIRECTORIES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
                   \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{n}{VOLUME} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{NSTEPS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nmin} \PYG{n}{NMIN}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nmax} \PYG{n}{NMAX}\PYG{p}{]}
                   \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nfits} \PYG{n}{NFITS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{pin\PYGZus{}min} \PYG{n}{PIN\PYGZus{}MIN}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-l, -{-}lower-bound]  
Value between 0 and 1 that determines the proportion to omit from the beginning of the simulation data series.

Default: 0.0
\item [-u, -{-}upper-bound]  
Value between 0 and 1 that determines the proportion to omit from the end of the simulation data series.

Default: 1.0
\item [-t, -{-}temperature]  
Temperature at which the simulation was run. Default=298.15K

Default: 298.15
\item [-{-}pickle]  
Name of file in which to store results as a pickle.
\item [-{-}save-figures]  
Save figures produced by script. Takes optional argument that adds a prefix to figure names.
\item [-{-}no-show]  
Do not display any figures on screen. Does not interfere with \textendash{}save-figures.

Default: False
\item [-{-}name]  
Name of ProtoMS output file containing free energy data. Note that this option will not change the output file used by the gcap estimator from results\_inst.

Default: “results”
\item [-d, -{-}directories]  
Location of folders containing ProtoMS output subdirectories. Multiple directories can be supplied to this flag and indicate repeats of the same calculation.
\item [-v, -{-}volume]  
Volume of the calculations GCMC region.
\item [-n, -{-}nsteps]  
Override automatic guessing of the number of steps to fit for titration curve fitting.
\item [-{-}nmin]  
Override automatic guessing of the minimum number of waters for tittration curve fitting.
\item [-{-}nmax]  
Override automatic guessing of maximum number of waters for titration curve fitting.
\item [-{-}nfits]  
The number of independent fitting attempts for the neural network occupancy model. Increasing the number of fits may help improve results for noisy data.

Default: 10
\item [-{-}pin\_min]  
The minimum value when fitting the neural network occupancy model. Setting this may help improve models which are poorly fit at low values
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}gci}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{titration}
\PYG{n}{calc\PYGZus{}gci}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n+nb}{all} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n+nb}{all} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{steps} \PYG{l+m+mi}{3}
\PYG{n}{calc\PYGZus{}gci}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{percentiles} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{fit} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{steps} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{1000} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{fit\PYGZus{}options} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{repeats 1 pin\PYGZus{}min 0.0 cost huber c 1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{ANN}\PYG{o}{.}\PYG{n}{pickle}
\PYG{n}{calc\PYGZus{}gci}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{ANN}\PYG{o}{.}\PYG{n}{pickle} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{pmf} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{pmf} \PYG{n}{minimum}
\PYG{n}{calc\PYGZus{}gci}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{ANN}\PYG{o}{.}\PYG{n}{pickle} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{pmf} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{range} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

Collection of tools to analyse and visualise GCMC titration data of water using grand canonical integration (GCI). Used to plot average number of waters for a given Adams value, i.e. GCMC titration data, calculate transfer free energies from ideal gas, calculate absolute and relative binding free energies of water, calculate and/or estimate optimal number of bound waters. As described in Ross et al., J. Am. Chem. Soc., 2015, 137 (47), pp 14930-14943.

Prior to using the armoury of options available in this script, it is wise to first view the titration data with \sphinxcode{\sphinxupquote{-p titration}}. The plot shows the average number of water molecules at each Adams value. It’s important to use \sphinxcode{\sphinxupquote{-{-}skip nframes}} to check that the form of the graph doesn’t significantly change if some initial snapshots are discarded when computing the average. The value of \sphinxcode{\sphinxupquote{nframes}} can be informed by the tool \sphinxcode{\sphinxupquote{calc\_series.py}}.

All the other functions contained in this tool require the fitting of a monotonically increasing artificial neural network (ANN) to the titration data. This is merely a sum of logistic/step functions that has been constrained to produce a line with upward steps. The purpose of the ANN is to smooth over the titration data so the area under the curve can be reliably evaluated; the imposition of monotonicity is important as it is a property the titration data should have. The number of units in the ANN (i.e. the number of step functions) is input using \sphinxcode{\sphinxupquote{-{-}steps nsteps}} and should be chosen to capture the major features of the titration data. It is better to err on the side of over-fitting than under-fitting, so don’t be stingy with how many steps you use. To improve reproducibility and to save time in subsequent analyses, an ANN can be saved and loaded using the flags \sphinxcode{\sphinxupquote{-i}} and \sphinxcode{\sphinxupquote{-o}} respectively. The fitting of an ANN is performed automatically if any of the calculation options (other than \sphinxcode{\sphinxupquote{fit}}) with \sphinxcode{\sphinxupquote{-c}} are specified. Detailed fitting parameters can be parsed to the ANN using \sphinxcode{\sphinxupquote{-{-}fit\_options}}, discussed below.

Error estimates of free energies and optimal number of waters are based on either (a) automatic repeated fitting of the ANN from different random initial parameters or (b) bootstrap sampling of the titration data, which samples B-values with replacement. The latter is selected with \sphinxcode{\sphinxupquote{-b nboots}}, where \sphinxcode{\sphinxupquote{nboots}} is the number of bootstrap samples. When running a large number of bootstrap samples (eg 1000), its recommended to save to bootstrap ANNs with \sphinxcode{\sphinxupquote{-o}}.

The flag \sphinxcode{\sphinxupquote{-c pmf}} calculates the free energy to transfer water molecules from ideal gas, and from bulk water, where the abbreviation stands for “potential of mean force”. A table will be printed that contains the free energy to transfer water from ideal gas to the simulated volume (with the heading \sphinxcode{\sphinxupquote{IDEAL GAS TRANSFER FREE ENERGIES}}), and the free energy to transfer from bulk water at a temperature of 298.15 K (with the heading \sphinxcode{\sphinxupquote{BINDING FREE ENERGIES}}). From the multiple ANN fits (either automatic repeated fits or bootstrap sampling), various statistics have been calculated. The \sphinxcode{\sphinxupquote{Mean}} and \sphinxcode{\sphinxupquote{Median}} are different averages of the calculated free energies, with the median being more robust to bad fits of the ANN than the mean. The standard deviation (\sphinxcode{\sphinxupquote{Std.  Dev.}}) as well as the range between the 25th and 75th percentiles serve as error estimates. It is important that standard state correction is applied to binding free energies. This is handled automatically when the volume of the gcmc region is passed to the script with the \sphinxcode{\sphinxupquote{-v}} flag.

Due to the accumulation of error when performing integration, the estimated error of the calculated free energies increases with the number of water molecules. To emphasise this, one can also perform GCI in the reverse direction and calculate the free energy to decouple water from the simulated volume with the flag \sphinxcode{\sphinxupquote{-{-}reverse}}.

One can calculate the free energy to add and remove a specific number of waters with the \sphinxcode{\sphinxupquote{-{-}range}} flag, which requires and upper and a lower number of waters as input. Particularly, the estimated error for the relative free energy between two occupancies is improved as accumulated integration error is reduced.

If this flag is specified along with ‘minimum’, eg \sphinxcode{\sphinxupquote{-c pmf minimum}}, then the number of water molecules that minimises the explicitly calculated binding free energy (the optimal number) is printed under the heading \sphinxcode{\sphinxupquote{MINIMUM BINDING FREE ENERGY STATE}}. The B-value that produces an average number of waters equal to the optimal number is also estimated. If only \sphinxcode{\sphinxupquote{-c minimum}} is specified, the B-value that replicates equilibrium with bulk water at a temperature of 298.15 K is estimated using an analytical formula, without calculating binding free energies with GCI. This B-value, and the average number of waters that appear at this B-value are printed under \sphinxcode{\sphinxupquote{THERMODYNAMIC EQUILIBRIUM STATE}}. If the volume of the gcmc region is specified, it is also possible to exactly determine the correct equilibrium B-value and the corresponding water occupancy is determined from the fitted titration curve and nearest simulated B-values.

The flag \sphinxcode{\sphinxupquote{-{-}fit\_options}} allows one to pass commands into the ANN fitting tool. The default options for the ANN may need tweaking to accurately reproduce the GCMC titration data. The most important options for the user are “repeats” - number of times the entire process of fitting an ANN is repeated, all fits are retained to estimate the fitting error, default=20; “pin\_min” - value to constrain the intercept to, useful when a titration goes to zero waters; “cost” - the type of cost/loss function that is minimised when fitting, the three choices are ‘msd’ (mean squared deviation), ‘absolute’ (absolute error), and ‘huber’ (pseudo Huber loss), default=msd; “c” - the parameter in the pseudo Huber loss function, default=2. Both the ‘absolute’ and ‘huber’ loss functions are suited to very noisy titration data, as they are more robust to outliers than ‘msd’, although using  the fitting algorithm may produce unstable fits with ‘absolute’.


\section{calc\_gcsingle.py}
\label{\detokenize{tools:calc-gcsingle-py}}
\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}gcsingle}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{p}
\PYG{n}{calc\PYGZus{}gcsingle}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{guess} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}
\PYG{n}{calc\PYGZus{}gcsingle}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}gcmc}\PYG{o}{/}\PYG{n}{b\PYGZus{}}\PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{excess}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool analyses and plots free energies from GCMC simulations on sites that can bind only a single water molecule as described in Ross et al., J. Am. Chem. Soc., 2015, 137 (47), pp 14930-14943. The tool fits a logistic function to GCMC titration data, where the point of inflection/point of half maximum is equals the free energy to transfer a water molecule from ideal gas to the GCMC volume, divided by kT. This tool should only be applied to GCMC titration data where the maximum occupancy equals 1. To calculate standard state binding free energies the gcmc region volume should be specified with the \sphinxcode{\sphinxupquote{-v{}`}} flag and the relevant correction will be applied to the free energies.


\section{calc\_replicapath.py}
\label{\detokenize{tools:calc-replicapath-py}}

Program to analyze and plot a replica paths


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{calc\PYGZus{}replicapath}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILES} \PYG{p}{[}\PYG{n}{FILES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PLOT} \PYG{p}{[}\PYG{n}{PLOT} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                           \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{k} \PYG{p}{\PYGZob{}}\PYG{k}{lambda}\PYG{p}{,}\PYG{n}{temperature}\PYG{p}{,}\PYG{n}{rest}\PYG{p}{,}\PYG{k}{global}\PYG{p}{,}\PYG{n}{B}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-f, -{-}files]  
the name of the files to analyse
\item [-p, -{-}plot]  
the replica values to plot
\item [-k, -{-}kind]  
Possible choices: lambda, temperature, rest, global, B

the kind of replica to analyze

Default: “lambda”
\item [-o, -{-}out]  
the prefix of the output figure. Default is replica\_path.

Default: “replica\_path.png”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}replicapath}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}\PYG{n}{lam}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.}\PYG{o}{*}\PYG{o}{/}\PYG{n}{results} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{1.000}
\PYG{n}{calc\PYGZus{}replicapath}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}\PYG{n}{lam}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.}\PYG{o}{*}\PYG{o}{/}\PYG{n}{results} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.500} \PYG{l+m+mf}{1.000} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{replica\PYGZus{}paths}\PYG{o}{.}\PYG{n}{png}
\PYG{n}{calc\PYGZus{}replicapath}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{o}{*}\PYG{o}{/}\PYG{n}{lam}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.000}\PYG{o}{/}\PYG{n}{results} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mf}{25.0} \PYG{l+m+mf}{35.0} \PYG{l+m+mf}{45.0} \PYG{o}{\PYGZhy{}}\PYG{n}{k} \PYG{n}{temperature}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tools plots the path of different replicas in a replica exchange simulation as a function of simulation time.

If the kind of replicas is from \(\lambda\) replica exchange the \sphinxcode{\sphinxupquote{replica1}} and \sphinxcode{\sphinxupquote{replica2}} etc should be individual \(\lambda\)-values to plot.

If the kind of replicas is from REST or temperature replica exchange the \sphinxcode{\sphinxupquote{replica1}} and \sphinxcode{\sphinxupquote{replica2}} etc should be individual temperatures to plot.


\section{calc\_rmsd.py}
\label{\detokenize{tools:calc-rmsd-py}}

Program to calculate RMSD of ligand centre


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{calc\PYGZus{}rmsd}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{INITIAL}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILES} \PYG{p}{[}\PYG{n}{FILES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{LIGAND}\PYG{p}{]}
                    \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{ATOM}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{TEMPERATURE}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-i, -{-}initial]  
the initial PDB-file of the ligand
\item [-f, -{-}files]  
the input PDB-files
\item [-l, -{-}ligand]  
the name of the ligand to extract
\item [-a, -{-}atom]  
the name of the atom to analyze
\item [-t, -{-}temperature]  
the temperature in the simulation

Default: 298.0
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}rmsd}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{out\PYGZus{}bnd}\PYG{o}{/}\PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{bnz}
\PYG{n}{calc\PYGZus{}rmsd}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{out\PYGZus{}bnd}\PYG{o}{/}\PYG{n+nb}{all}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{bnz} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{c4}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool calculate the RMSD of a ligand in a simulation.

If the \sphinxcode{\sphinxupquote{atom}} name is given, the tool will calculate the RMSD of that atom with respect to its position in \sphinxcode{\sphinxupquote{pdbfile}}. Otherwise, the program will calculate the RMSD of the geometric centre with respect to \sphinxcode{\sphinxupquote{pdbfile}}.

A force constant to keep the ligand restrained for free energy calculations is estimated from the RMSD using the equipartition theorem.


\section{calc\_series.py}
\label{\detokenize{tools:calc-series-py}}

Program to analyze and plot a time series


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{calc\PYGZus{}series}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILE} \PYG{p}{[}\PYG{n}{FILE} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
                      \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{SERIES} \PYG{p}{[}\PYG{n}{SERIES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                      \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{p}{\PYGZob{}}\PYG{n}{sep}\PYG{p}{,}\PYG{n}{sub}\PYG{p}{,}\PYG{n}{single}\PYG{p}{,}\PYG{n}{single\PYGZus{}first0}\PYG{p}{,}\PYG{n}{single\PYGZus{}last0}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
                      \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nperm} \PYG{n}{NPERM}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{threshold} \PYG{n}{THRESHOLD}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{average}\PYG{p}{]}
                      \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{moving} \PYG{n}{MOVING}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-f, -{-}file]  
the name of the file to analyse. Default is results.

Default: {[}‘results’{]}
\item [-o, -{-}out]  
the prefix of the output figure. Default is series.

Default: “series”
\item [-s, -{-}series]  
the series to analyze
\item [-p, -{-}plot]  
Possible choices: sep, sub, single, single\_first0, single\_last0

the type of plot to generate for several series
\item [-{-}nperm]  
if larger than zero, perform a permutation test to determine equilibration, default=0

Default: 0
\item [-{-}threshold]  
the significant level of the equilibration test, default=0.05

Default: 0.05
\item [-{-}average]  
turns on use of running averaging of series

Default: False
\item [-{-}moving]  
turns on use of moving averaging of series, default=None
\end{optionlist}

on time has been determined, the tool will estimate the number of independent samples in the production part using the method of statistical inefficiency. The equilibration time will also be estimated from a method that maximizes the number uncorrelated samples as suggested on alchemistry.org.

Apart from the raw series, the tool can also plot the running average if the \sphinxcode{\sphinxupquote{-{-}average}} flag is set or the moving average if the \sphinxcode{\sphinxupquote{-{-}moving}} flag is used.

Typically only a single ProtoMS results file will be analysed and plotted. However, for the series \sphinxcode{\sphinxupquote{grad}} and \sphinxcode{\sphinxupquote{agrad}} (the gradient and analytical gradient, respectively), multiple results file can be given. In this case, the gradients for each results file is used to estimate the free energy using thermodynamic integration.


\section{calc\_ti.py}
\label{\detokenize{tools:calc-ti-py}}
\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{calc\PYGZus{}ti}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}
\PYG{n}{calc\PYGZus{}ti}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mi}{200}
\PYG{n}{calc\PYGZus{}ti}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{l+m+mi}{200}
\PYG{n}{calc\PYGZus{}ti}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{analytical}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool calculates free energies using the method of thermodynamic integration (TI).

The program expects that in the \sphinxcode{\sphinxupquote{directory}} there exist an output folder for each \(\lambda\)-value, eg. \sphinxcode{\sphinxupquote{lam-0.000}} and \sphinxcode{\sphinxupquote{lam-1.000}}

If the \sphinxcode{\sphinxupquote{-gr}} flag is set the gradient with respect to \(\lambda\) is plotted and saved to a file called \sphinxcode{\sphinxupquote{gradient.png}}

Block estimates can be constructed by combining \sphinxcode{\sphinxupquote{nskip}} and \sphinxcode{\sphinxupquote{nmax}}. For instance, these commands calculates block estimates with a block size of 5 m snapshots

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
for X in 0 50 100 150 200 250 300 350
do
calc\PYGZus{}bar.py \PYGZhy{}d out\PYGZus{}free \PYGZhy{}nskip \PYGZdl{}X \PYGZhy{}nmax 50 \PYGZhy{}b 5 \PYGZhy{}pw \PYGZhy{}pu
done
\end{sphinxVerbatim}

Rather than manually specifying snapshots to skip with \sphinxcode{\sphinxupquote{nskip}} you can also simply give the \sphinxcode{\sphinxupquote{autoeqb}} option that uses the automatic equilibration detection functionality of calc\_series to decide how much data to include in the ensemble averages. This should be used with caution and checked.


\section{clear\_gcmcbox.py}
\label{\detokenize{tools:clear-gcmcbox-py}}

Program to remove water molecules from a GCMC/JAWS-1 box


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{clear\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{BOX}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{SOLVATION}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-b, -{-}box]  
the name of the PDB-file containing the box.
\item [-s, -{-}solvation]  
the name of the PDB-file containing the solvation waters
\item [-o, -{-}out]  
the name of the output PDB-file

Default: “cleared\_box.pdb”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{clear\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{gcmc\PYGZus{}box}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{n}{water}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{clear\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{gcmc\PYGZus{}box}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{n}{water}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{water\PYGZus{}cleared}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool clears a GCMC or JAWS-1 simulation box from any bulk water placed there by the solvation method.

In a GCMC and JAWS-1 simulation the bulk water is prevented to enter or exit a GCMC or JAWS-1 simulation box. Therefore, bulk water that are within this box needs to be removed prior to the GCMC or JAWS-1 simulation.

The \sphinxcode{\sphinxupquote{boxfile}} is typically created by \sphinxcode{\sphinxupquote{make\_gcmcbox.py}} and the \sphinxcode{\sphinxupquote{waterfile}} is typically created by \sphinxcode{\sphinxupquote{solvate.py}} and can be either a droplet or a box.


\section{convertatomnames.py}
\label{\detokenize{tools:convertatomnames-py}}

Program convert atom names in a protein pdb-file to ProtoMS style


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{convertatomnames}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PROTEIN}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{STYLE}\PYG{p}{]}
                           \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{CONVERSIONFILE}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-p, -{-}protein]  
the protein PDB-file
\item [-o, -{-}out]  
the output PDB-file

Default: “protein\_pms.pdb”
\item [-s, -{-}style]  
the style of the input PDB-file

Default: “amber”
\item [-c, -{-}conversionfile]  
the name of the file with conversion rules

Default: “atomnamesmap.dat”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
convertatomnames.py \PYGZhy{}p protein.pdb
convertatomnames.py \PYGZhy{}p protein.pdb \PYGZhy{}c \PYGZdl{}PROTOMSHOME/data/atomnamesmap.dat
convertatomnames.py \PYGZhy{}p protein.pdb \PYGZhy{}s charmm
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool converts residue and atom names to ProtoMS convention.

This script modfies in particular names of hydrogen atoms, but also some residue names, e.g. histidines.

A file containing conversion instructions for amber and charmm is available in the \sphinxcode{\sphinxupquote{\$PROTOMSHOME/data}} folder.


\section{convertwater.py}
\label{\detokenize{tools:convertwater-py}}

Program to convert water molecules - with or without hydrogens - in a pdb file to simulation models, such as tip4p. Currently ignores original hydrogen positions.


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{convertwater}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PDB}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{MODEL}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{RESNAME}\PYG{p}{]}
                       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{setupseed} \PYG{n}{SETUPSEED}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-p, -{-}pdb]  
the PDF-file containing the waters to be transformed
\item [-o, -{-}out]  
the output PDB-file

Default: “convertedwater.pdb”
\item [-m, -{-}model]  
the water model,default=tip4p

Default: “tip4p”
\item [-i, -{-}ignoreh]  
whether to ignore hydrogens in input water. If no hydrogens are present, waters are randomly orientated. default=No

Default: False
\item [-n, -{-}resname]  
the residue name that will be applied to the water molecules. When it is not specified, it is chosen based on the water model
\item [-{-}setupseed]  
optional random number seed for generation of water coordinates
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{convertwater}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{convertwater}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{tip3p}
\PYG{n}{convertwater}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{ignoreh}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool converts water molecules to a specific model.

Currently the script recognizes TIP3P and TIP4P water models. The valid values for \sphinxcode{\sphinxupquote{style}} is therefore \sphinxcode{\sphinxupquote{t4p, tip4p, tp4, t3p, tip3p, tp3}}

If the \sphinxcode{\sphinxupquote{-{-}ignoreh}} flag is given, the script will discard the hydrogen atoms found in \sphinxcode{\sphinxupquote{pdbfile}} and add them at a random orientation.


\section{distribute\_waters.py}
\label{\detokenize{tools:distribute-waters-py}}

Randomly distribute n molecules within box dimensions


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{distribute\PYGZus{}waters}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{BOX} \PYG{n}{BOX} \PYG{n}{BOX} \PYG{n}{BOX} \PYG{n}{BOX} \PYG{n}{BOX}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{MOLECULES}\PYG{p}{]}
                            \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUTFILE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{model} \PYG{n}{MODEL}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{resname} \PYG{n}{RESNAME}\PYG{p}{]}
                            \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{number} \PYG{n}{NUMBER}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{setupseed} \PYG{n}{SETUPSEED}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-b, -{-}box]  
Dimensions of the box. Six arguments expected: origin (x,y,z) \& length (x,y,z)
\item [-m, -{-}molecules]  
Molecules to distribute in the box. Either the number of waters or a pdb file containing all of them
\item [-o, -{-}outfile]  
Name of the pdb file to write the molecules to. Default=’ghostmolecules.pdb’

Default: “ghostmolecules.pdb”
\item [-{-}model]  
Water model. Used when only the amount of waters is specified. Options: ‘t4p’,’t3p’. Default=’t4p’

Default: “t4p”
\item [-{-}resname]  
Residue name of the molecules writen to output. Default=’WAT’

Default: “WAT”
\item [-{-}number]  
Required number of molecules when it differs from the number of residues in the file.
\item [-{-}setupseed]  
Optional random number seed for generation of water coordinates
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{distribute\PYGZus{}waters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mf}{53.4} \PYG{l+m+mf}{56.28} \PYG{l+m+mf}{13.23} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{l+m+mi}{12}
\PYG{n}{distribute\PYGZus{}waters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mf}{53.4} \PYG{l+m+mf}{56.28} \PYG{l+m+mf}{13.23} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{l+m+mi}{12} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{model} \PYG{n}{t3p} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{resname} \PYG{n}{T3P}
\PYG{n}{distribute\PYGZus{}waters}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mf}{53.4} \PYG{l+m+mf}{56.28} \PYG{l+m+mf}{13.23} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10} \PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{myonewater}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{number} \PYG{l+m+mi}{12} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{mywatersinbox}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool can place water molecules at random within a GCMC or JAWS-1 simulation box.

It can place molecules in random positions and orientations with their geometry center restricted to the given dimensions of a box.


\section{divide\_pdb.py}
\label{\detokenize{tools:divide-pdb-py}}

Split your multi pdb file into individual files


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{divide\PYGZus{}pdb}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{INPUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUTPUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PATH}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-i, -{-}input]  
The name of your multi pdb file. Default = all.pdb

Default: “all.pdb”
\item [-o, -{-}output]  
The basename of your individual pdb files. Default = {\color{red}\bfseries{}snapshot\_}

Default: “{\color{red}\bfseries{}snapshot\_}”
\item [-p, -{-}path]  
Where the input should be found and the output printed. Default = ./

Default: “./”
\end{optionlist}

\sphinxstylestrong{Examples:}
\begin{description}
\item[{::}] \leavevmode
divide\_pdb.py
divide\_pdb.py -i mypmsout.pdb -o individual -p outfolder/

\end{description}

\sphinxstylestrong{Description:}

This tool splits up a PDB file with multiple models (the keyword END defines the end of a model) into several PDB files.


\section{generate\_input.py}
\label{\detokenize{tools:generate-input-py}}

Program to create a ProtoMS command file


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{generate\PYGZus{}input}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{p}{\PYGZob{}}\PYG{n}{sampling}\PYG{p}{,}\PYG{n}{equilibration}\PYG{p}{,}\PYG{n}{dualtopology}\PYG{p}{,}\PYG{n}{singletopology}\PYG{p}{,}\PYG{n}{gcap\PYGZus{}single}\PYG{p}{,}\PYG{n}{gcap\PYGZus{}dual}\PYG{p}{,}\PYG{n}{gcmc}\PYG{p}{,}\PYG{n}{jaws1}\PYG{p}{,}\PYG{n}{jaws2}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dovacuum}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PROTEIN}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{LIGANDS} \PYG{p}{[}\PYG{n}{LIGANDS} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{TEMPLATES} \PYG{p}{[}\PYG{n}{TEMPLATES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{pw} \PYG{n}{PROTWATER}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{lw} \PYG{n}{LIGWATER}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{outfolder} \PYG{n}{OUTFOLDER}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gaff} \PYG{n}{GAFF}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{lambdas} \PYG{n}{LAMBDAS} \PYG{p}{[}\PYG{n}{LAMBDAS} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{adams} \PYG{n}{ADAMS} \PYG{p}{[}\PYG{n}{ADAMS} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{adamsrange} \PYG{n}{ADAMSRANGE} \PYG{p}{[}\PYG{n}{ADAMSRANGE} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{jawsbias} \PYG{n}{JAWSBIAS} \PYG{p}{[}\PYG{n}{JAWSBIAS} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gcmcwater} \PYG{n}{GCMCWATER}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gcmcbox} \PYG{n}{GCMCBOX}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{watmodel} \PYG{p}{\PYGZob{}}\PYG{n}{tip3p}\PYG{p}{,}\PYG{n}{tip4p}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nequil} \PYG{n}{NEQUIL}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nprod} \PYG{n}{NPROD}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dumpfreq} \PYG{n}{DUMPFREQ}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{absolute}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{ranseed} \PYG{n}{RANSEED}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{softcore} \PYG{p}{\PYGZob{}}\PYG{n}{auto}\PYG{p}{,}\PYG{n+nb}{all}\PYG{p}{,}\PYG{n}{none}\PYG{p}{,}\PYG{n}{manual}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
                         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{spec}\PYG{o}{\PYGZhy{}}\PYG{n}{softcore} \PYG{n}{SPEC\PYGZus{}SOFTCORE}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-s, -{-}simulation]  
Possible choices: sampling, equilibration, dualtopology, singletopology, gcap\_single, gcap\_dual, gcmc, jaws1, jaws2

the kind of simulation to setup

Default: “equilibration”
\item [-{-}dovacuum]  
turn on vacuum simulation for simulation types equilibration and sampling

Default: False
\item [-p, -{-}protein]  
the name of the protein file
\item [-l, -{-}ligands]  
the name of the ligand pdb files
\item [-t, -{-}templates]  
the name of ProtoMS template files
\item [-pw, -{-}protwater]  
the name of the solvent for protein
\item [-lw, -{-}ligwater]  
the name of the solvent for ligand
\item [-o, -{-}out]  
the prefix of the name of the command file

Default: “run”
\item [-{-}outfolder]  
the ProtoMS output folder

Default: “out”
\item [-{-}gaff]  
the version of GAFF to use for ligand

Default: “gaff16”
\item [-{-}lambdas]  
the lambda values or the number of lambdas

Default: {[}16{]}
\item [-{-}adams]  
the Adam/B values for the GCMC

Default: 0
\item [-{-}adamsrange]  
the upper and lower Adam/B values for the GCMC and, optionally, the number of values desired (default value every 1.0), e.g. -1 -16 gives all integers between and including -1 and -16
\item [-{-}jawsbias]  
the bias for the JAWS-2

Default: 0
\item [-{-}gcmcwater]  
a pdb file with a box of water to do GCMC on
\item [-{-}gcmcbox]  
a pdb file with box dimensions for the GCMC box
\item [-{-}watmodel]  
Possible choices: tip3p, tip4p

the name of the water model. Default = tip4p

Default: “tip4p”
\item [-{-}nequil]  
the number of equilibration steps

Default: 5000000.0
\item [-{-}nprod]  
the number of production steps

Default: 40000000.0
\item [-{-}dumpfreq]  
the output dump frequency

Default: 100000.0
\item [-{-}absolute]  
whether an absolute free energy calculation is to be run. Default=False

Default: False
\item [-{-}ranseed]  
the value of the random seed you wish to simulate with. If None, then a seed is randomly generated. Default=None
\item [-{-}softcore]  
Possible choices: auto, all, none, manual

determine which atoms to apply softcore potentials to. If ‘all’ softcores are applied to all atoms of both solutes. If ‘none’ softcores are not applied to any atoms. If ‘auto’, softcores are applied to atoms based on matching coordinates between ligand structures. The selected softcore atoms can be amended using the \textendash{}spec-softcore flag. If ‘manual’ only those atoms specified by the \textendash{}spec-softcore flag are softcore.

Default: “all”
\item [-{-}spec-softcore]  
Specify atoms to add or remove from softcore selections. Can be up to two, space separated, strings of the form “N:AT1,AT2,-AT3”. N should be either “1” or “2” indicating the corresponding ligand. The comma separated list of atom names are added to the softcore selection. A preceding dash for an atom name specifies it should be removed from the softcore selection. The special value “auto” indictates that automatic softcore assignments should be accepted without amendment.
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{generate\PYGZus{}input}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{dualtopology} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{lig2}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{li1}\PYG{o}{\PYGZhy{}}\PYG{n}{li2}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{pw} \PYG{n}{droplet}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{lw} \PYG{n}{lig1\PYGZus{}wat}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{lambas} \PYG{l+m+mi}{8}
\PYG{n}{generate\PYGZus{}input}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{dualtopology} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{dummy}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{li1}\PYG{o}{\PYGZhy{}}\PYG{n}{dummy}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{lw} \PYG{n}{lig1\PYGZus{}wat}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{absolute}
\PYG{n}{generate\PYGZus{}input}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{gcmc} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{pw} \PYG{n}{droplet}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{adams} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{6} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gcmcwater} \PYG{n}{gcmc\PYGZus{}water}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gcmcbox} \PYG{n}{gcmc\PYGZus{}box}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{generate\PYGZus{}input}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{sampling} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{lig1}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{dovacuum}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool generates input files with commands for ProtoMS.

The settings generate are made according to experience and should work in most situations.

The tool will create at most two ProtoMS command files, one for the protein simulation and one for the ligand simulation. These can be used to run ProtoMS, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}PROTOMS/protoms3 run\PYGZus{}free.cmd
\end{sphinxVerbatim}


\section{make\_dummy.py}
\label{\detokenize{tools:make-dummy-py}}

Program make a dummy corresponding to a molecule


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{make\PYGZus{}dummy}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-f, -{-}file]  
the name of a PDB file
\item [-o, -{-}out]  
the name of the dummy PDB file

Default: “dummy.pdb”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make\PYGZus{}dummy}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{make\PYGZus{}dummy}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{benzene\PYGZus{}dummy}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool makes a matching dummy particle for a solute.

The dummy particle will be placed at the centre of the solute.


\section{make\_gcmcbox.py}
\label{\detokenize{tools:make-gcmcbox-py}}

Program to make a PDB-file with box coordinates covering a solute molecules


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{make\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{SOLUTE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PADDING}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
                       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{BOX} \PYG{p}{[}\PYG{n}{BOX} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-s, -{-}solute]  
the name of the PDB-file containing the solute.
\item [-p, -{-}padding]  
the padding in A,default=2

Default: 2.0
\item [-o, -{-}out]  
the name of the box PDB-file

Default: “gcmc\_box.pdb”
\item [-b, -{-}box]  
Either the centre of the box (x,y,z), or the centre of box AND length (x,y,z,x,y,z). If the centre is specified and the length isn’t, twice the ‘padding’ will be the lengths of a cubic box.
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{make\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mf}{0.0}
\PYG{n}{make\PYGZus{}gcmcbox}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{benzene\PYGZus{}gcmc\PYGZus{}box}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool makes a GCMC or JAWS-1 simulation box to fit on top of a solute.

The box will be created so that it has the extreme dimensions of the solute and then \sphinxcode{\sphinxupquote{padding}} will be added in each dimension

The box can be visualised with most common programs, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vmd} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{n}{benzene\PYGZus{}gcmc\PYGZus{}box}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}

this is a good way to see that the box is of appropriate dimensions.

When an appropriate box has been made, it can be used by \sphinxcode{\sphinxupquote{solvate.py}} to fill it with water.


\section{make\_single.py}
\label{\detokenize{tools:make-single-py}}

Program to setup template files for single-toplogy perturbations semi-automatically


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{make\PYGZus{}single}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t0} \PYG{n}{TEM0}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t1} \PYG{n}{TEM1}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p0} \PYG{n}{PDB0}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p1} \PYG{n}{PDB1}\PYG{p}{]}
                      \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{MAP}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{gaff} \PYG{n}{GAFF}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-t0, -{-}tem0]  
Template file for V0
\item [-t1, -{-}tem1]  
Template file for V1
\item [-p0, -{-}pdb0]  
PDB-file for V0
\item [-p1, -{-}pdb1]  
PDB-file for V1
\item [-m, -{-}map]  
the correspondance map from V0 to V1
\item [-o, -{-}out]  
prefix of the output file

Default: “single”
\item [-{-}gaff]  
the version of GAFF to use for ligand

Default: “gaff16”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make\PYGZus{}single}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{t0} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{t1} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{p0} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p1} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{make\PYGZus{}single}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{t0} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{t1} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{p0} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p1} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{bnz2tol}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{make\PYGZus{}single}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{t0} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{t1} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{p0} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{p1} \PYG{n}{toluene}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{bnz}\PYG{o}{\PYGZhy{}}\PYG{n}{tol}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool makes ProtoMS template files for single topology free energy simulations.

The program will automatically try to match atoms in \sphinxcode{\sphinxupquote{template0}} with atoms in \sphinxcode{\sphinxupquote{template1}}. It will do this by looking for atoms with the same atom type that are on top of each other in \sphinxcode{\sphinxupquote{pdbfile0}} and \sphinxcode{\sphinxupquote{pdbfile1}}. A cut-off of 0.02 A2 will be used for this. All atoms that cannot be identified in this way are written to the screen and the user has to enter the corresponding atoms. If no corresponding atom exists, i.e., the atom should be perturbed to a dummy, the user may enter blank.

The user may also write the corresponding atoms to a file and provide it as \sphinxcode{\sphinxupquote{map}} above. In this file there should be one atom pair on each line, separated by white-space. A dummy atom should be denoted as \sphinxcode{\sphinxupquote{DUM}}. If \sphinxcode{\sphinxupquote{map}} is not given, the program will write the created correspondence map to a file based on the \sphinxcode{\sphinxupquote{outfile}} string.

Currently, dummy atoms are not supported in the solute at \(\lambda=0.0\). Therefore, this solute needs to be the larger one.

The tool will write two ProtoMS template files, one for the electrostatic perturbation, one for the van der Waals perturbation and one for the combined perturbation. These template files will end in \sphinxcode{\sphinxupquote{\_ele.tem}}, \sphinxcode{\sphinxupquote{\_vdw.tem}}, \sphinxcode{\sphinxupquote{\_comb.tem}} respectively.

A summary of the charges and van der Waals parameters in the four states will be printed to the screen. This information should be checked carefully.


\section{merge\_templates.py}
\label{\detokenize{tools:merge-templates-py}}

Program merge a series of ProtoMS template files


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{make\PYGZus{}templates}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{FILES} \PYG{p}{[}\PYG{n}{FILES} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-f, -{-}files]  
the name of the template files
\item [-o, -{-}out]  
the name of the merged template file
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{merge\PYGZus{}templates}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{tem} \PYG{n}{dummy}\PYG{o}{.}\PYG{n}{tem} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{bnz}\PYG{o}{\PYGZhy{}}\PYG{n}{dummy}\PYG{o}{.}\PYG{n}{tem}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool combines several ProtoMS template files into a single template file.

The force field parameters in \sphinxcode{\sphinxupquote{file2}} will be re-numbered so that they do not conflict with \sphinxcode{\sphinxupquote{file1}}. This is important when you want to load both parameters into ProtoMS at the same time.


\section{plot\_theta.py}
\label{\detokenize{tools:plot-theta-py}}

Program to plot the theta distribution of a given molecule, result from a JAWS simulation


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{plot\PYGZus{}theta}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{RESULTS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{RESTART}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{MOLECULE}\PYG{p}{]}
                     \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PLOTNAME}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{skip} \PYG{n}{SKIP}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-r, -{-}results]  
the name of the results file. Deafult=’results’

Default: “results”
\item [-s, -{-}restart]  
the replica values to plot. Default=’restart’

Default: “restart”
\item [-m, -{-}molecule]  
the residue name of the JAWS molecule. Default=’WAT’

Default: “WAT”
\item [-p, -{-}plotname]  
the start of the filename for the plots generated. Default=’theta\_dist’

Default: “theta\_dist”
\item [-{-}skip]  
the number of results snapshots to skip, Default = 0

Default: “0”
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}theta}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{WA1} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{skip} \PYG{l+m+mi}{50}
\PYG{n}{plot\PYGZus{}theta}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{n}{WA1} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{theta\PYGZus{}wa1}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool plots the theta distribution resulting from a JAWS stage one simulation.

Two different histograms will be generated. One in which all different copies of the same molecule are added up, and a different one where each copy is displayed individually.


\section{pms2pymbar.py}
\label{\detokenize{tools:pms2pymbar-py}}
\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pms2pymbar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/}
\PYG{n}{pms2pymbar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+m+mi}{200}
\PYG{n}{pms2pymbar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{l+m+mi}{200}
\PYG{n}{pms2pymbar}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{out\PYGZus{}free}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{run}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool extract free energy data from ProtoMS output files and makes them compatible with the PyMBAR software.

The program expects that in the \sphinxcode{\sphinxupquote{directory}} there exist an output folder for each \(\lambda\)-value, eg. \sphinxcode{\sphinxupquote{lam-0.000}} and \sphinxcode{\sphinxupquote{lam-1.000}}

The tool writes a file \sphinxcode{\sphinxupquote{outfile}} to each folder in \sphinxcode{\sphinxupquote{directory}} that is human readable. It contains some header information such as units, current \(\lambda\)-value and total number of \&lambda-values. It then contains one row for each snapshot and each of these rows contains a column with the total energy at a specific \(\lambda\)-value., one column for each \(\lambda\)-value. These files can then be read by PyMBAR.

Alternatively, if PyMBAR is properly installed and can be loaded as a python library, the user can add the \sphinxcode{\sphinxupquote{-{-}run}} flag and the tool will automatically feed PyMBAR with the energy values and compute the free energy using MBAR.


\section{scoop.py}
\label{\detokenize{tools:scoop-py}}

Program scoop a protein pdb-file


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PROTEIN}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{LIGAND}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{center} \PYG{n}{CENTER}\PYG{p}{]}
                \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{innercut} \PYG{n}{INNERCUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{outercut} \PYG{n}{OUTERCUT}\PYG{p}{]}
                \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{flexin} \PYG{p}{\PYGZob{}}\PYG{n}{sidechain}\PYG{p}{,}\PYG{n}{flexible}\PYG{p}{,}\PYG{n}{rigid}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
                \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{flexout} \PYG{p}{\PYGZob{}}\PYG{n}{sidechain}\PYG{p}{,}\PYG{n}{flexible}\PYG{p}{,}\PYG{n}{rigid}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
                \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{terminal} \PYG{p}{\PYGZob{}}\PYG{n}{keep}\PYG{p}{,}\PYG{n}{doublekeep}\PYG{p}{,}\PYG{n}{neutralize}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
                \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{excluded} \PYG{n}{EXCLUDED} \PYG{p}{[}\PYG{n}{EXCLUDED} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
                \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{added} \PYG{n}{ADDED} \PYG{p}{[}\PYG{n}{ADDED} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{scooplimit} \PYG{n}{SCOOPLIMIT}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-p, -{-}protein]  
the protein PDB-file
\item [-l, -{-}ligand]  
the ligand PDB-file
\item [-o, -{-}out]  
the output PDB-file

Default: “scoop.pdb”
\item [-{-}center]  
the center of the scoop, if ligand is not available, either a string or a file with the coordinates

Default: “0.0 0.0 0.0”
\item [-{-}innercut]  
maximum distance from ligand defining inner region of the scoop

Default: 16.0
\item [-{-}outercut]  
maximum distance from ligand defining outer region of the scoop

Default: 20.0
\item [-{-}flexin]  
Possible choices: sidechain, flexible, rigid

the flexibility of the inner region

Default: “flexible”
\item [-{-}flexout]  
Possible choices: sidechain, flexible, rigid

the flexibility of the inner region

Default: “sidechain”
\item [-{-}terminal]  
Possible choices: keep, doublekeep, neutralize

controls of to deal with charged terminal

Default: “neutralize”
\item [-{-}excluded]  
a list of indices for residues to be excluded from scoops

Default: {[}{]}
\item [-{-}added]  
a list of indices for residues to be included in outer scoops

Default: {[}{]}
\item [-{-}scooplimit]  
the minimum difference between number of residues in protein and scoop for scoop to be retained

Default: 10
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}  \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{n}{benzene}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{center} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.0 0.0 0.0}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{center} \PYG{n}{origin}\PYG{o}{.}\PYG{n}{dat}
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{innercut} \PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{outercut} \PYG{l+m+mi}{16}
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{exclude} \PYG{l+m+mi}{189} \PYG{l+m+mi}{190}
\PYG{n}{scoop}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{pdb}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{added} \PYG{l+m+mi}{57} \PYG{l+m+mi}{58} \PYG{l+m+mi}{59}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool truncates a protein and thereby creating a scoop.

All residues outside \sphinxcode{\sphinxupquote{ocut}} is removed completely. \sphinxcode{\sphinxupquote{icut}} is used to separate the scoop model into two different regions, that possibly can have different sampling regimes. The sampling regimes are determined by \sphinxcode{\sphinxupquote{-{-}flexin}} and \sphinxcode{\sphinxupquote{-{-}flexout}}.

If the user would like to finetune the residues in the scoop this can be done with \sphinxcode{\sphinxupquote{-{-}excluded}} to discard specific residues or \sphinxcode{\sphinxupquote{-{-}added}} to include specific residues.

The scoop will be centred on the \sphinxcode{\sphinxupquote{ligandfile}} is such a file is provided. Otherwise, it will be centred on the flag \sphinxcode{\sphinxupquote{-{-}center}}. The argument to this flag can be either a string with three numbers specifying the centre, as in example three above. It can also be the name of a file containing the centre, as in example four above.

Crystallographic waters that are in \sphinxcode{\sphinxupquote{proteinfile}} will also be truncated at \sphinxcode{\sphinxupquote{ocut}}

The PDB file will contain specific instructions for ProtoMS to automatically enforce the values of  \sphinxcode{\sphinxupquote{-{-}flexin}} and \sphinxcode{\sphinxupquote{-{-}flexout}}.


\section{solvate.py}
\label{\detokenize{tools:solvate-py}}

Program to solvate a solute molecule in either a box or a droplet


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{solvate}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{n}{BOX}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{SOLUTE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{pr} \PYG{n}{PROTEIN}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{p}{\PYGZob{}}\PYG{n}{box}\PYG{p}{,}\PYG{n}{droplet}\PYG{p}{,}\PYG{n}{flood}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{n}{PADDING}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{RADIUS}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{CENTER}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{p}{\PYGZob{}}\PYG{n}{Amber}\PYG{p}{,}\PYG{n}{ProtoMS}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{n}{OFFSET}\PYG{p}{]}
                  \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{setupseed} \PYG{n}{SETUPSEED}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-b, -{-}box]  
a PDB-file containing a pre-equilibrated box of water molcules

Default: “”
\item [-s, -{-}solute]  
a PDB-file containing the solute molecule
\item [-pr, -{-}protein]  
a PDB-file containing the protein molecule
\item [-o, -{-}out]  
the name of the output PDB-file containing the added water, default solvent\_box.pdb

Default: “solvent\_box.pdb”
\item [-g, -{-}geometry]  
Possible choices: box, droplet, flood

the geometry of the added water, should be either ‘box’, ‘droplet’ or ‘flood’

Default: “box”
\item [-p, -{-}padding]  
the minimum distance between the solute and the box edge, default=10 A

Default: 10.0
\item [-r, -{-}radius]  
the radius of the droplet, default=30A

Default: 30.0
\item [-c, -{-}center]  
definition of center, default=’cent’

Default: “cent”
\item [-n, -{-}names]  
Possible choices: Amber, ProtoMS

the naming convention, should be either Amber or ProtoMS

Default: “ProtoMS”
\item [-{-}offset]  
the offset to be added to vdW radii of the atoms to avoid overfilling cavities with water.

Default: 0.89
\item [-{-}setupseed]  
optional random number seed for generation of water coordinates..
\end{optionlist}

\begin{quote}

if -b or -s are not supplied on the command-line, the program will ask for
them.

-c can be either ‘cent’ or a string containing 1, 2 or 3 numbers. If 1
number is given it will be used as center of the droplet in x, y, and z.
If 2 numbers are given this is interpreted as an atom range, such that the
droplet will be centered on the indicated atoms, and if 3 numbers are
given this is directly taken as the center of droplet
\begin{description}
\item[{Example usages:}] \leavevmode\begin{description}
\item[{solvate.py -b \$\{PROTOMSHOME\}/tools/sbox1.pdb -s solute.pdb}] \leavevmode\begin{description}
\item[{(will solvate ‘solute.pdb’ in a box that extends at least 10 A from}] \leavevmode
the solute)

\end{description}

\item[{solvate.py -b \$\{PROTOMSHOME\}/tools/sbox1.pdb -s protein.pdb -g droplet -r 25.0}] \leavevmode\begin{description}
\item[{(will solvate ‘protein.pdb’ in a 25 A droplet centered on}] \leavevmode
all coordinates)

\end{description}

\end{description}

\end{description}
\end{quote}


\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}s benzene.pdb
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}s benzene.pdb \PYGZhy{}p 12.0
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}s benzene.pdb \PYGZhy{}pr protein.pdb \PYGZhy{}g droplet
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}s benzene.pdb \PYGZhy{}pr protein.pdb \PYGZhy{}g droplet \PYGZhy{}r 24.0
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}pr protein.pdb \PYGZhy{}g droplet \PYGZhy{}c 0.0
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}pr protein.pdb \PYGZhy{}g droplet \PYGZhy{}c \PYGZdq{}0.0 10.0 20.0\PYGZdq{}
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}pr protein.pdb \PYGZhy{}g droplet \PYGZhy{}c \PYGZdq{}76 86\PYGZdq{}
solvate.py \PYGZhy{}b \PYGZdl{}PROTOMSHOME/data/wbox\PYGZus{}tip4p.pdb \PYGZhy{}s gcmc\PYGZus{}box.pdb \PYGZhy{}g flood
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool solvates a ligand in either a droplet or a box of water. It can also flood a GCMC or JAWS-1 simulatios box with waters.

Pre-equilibrated boxes to use can be found in the \sphinxcode{\sphinxupquote{\$PROTOMSHOME/data}} folder.

To solvate small molecule it is sufficient to give the \sphinxcode{\sphinxupquote{solutefile}} as in the first example above. This produces a box with at least 10 A between the solute and the edge of the water box, which should be sufficient in most situation. Use \sphinxcode{\sphinxupquote{padding}} to increase or decreas the box size as in the second example. The solvation box is created by replicating the pre-equilibrated box in all dimensions and then removing waters that overlap with solute atoms.

To solvate a protein in a droplet, specify \sphinxcode{\sphinxupquote{proteinfile}} and \sphinxcode{\sphinxupquote{droplet}} as in the third example above. This produces a droplet with radius of 30 A, which was choosen to work well with the default options in \sphinxcode{\sphinxupquote{scoop.py}}. Use \sphinxcode{\sphinxupquote{radius}} to obtain a smaller or larger droplet as in the fourth example. The centre of the droplet can be on a ligand if \sphinxcode{\sphinxupquote{ligandfile}} is specified. Otherwise, the \sphinxcode{\sphinxupquote{center{}`{}`argument is used. This argument can be either {}`{}`cent}} (the default) that places the droplet at the centre of the protein. It can also take a single number as in the fifth example above in case it is placed at this coordinate in all dimensions. It can also take a string with three numbers which is the origin of the droplet in x, y, and z dimensions, see the sixth example above. If two numbers are given as in the seventh example above, it is assumed that this is an atom range and the droplet will be placed at the centre of these atoms. The droplet is created by putting random waters from the pre-equilibrated box on a grid, displacing them slightly in a random fashion.

The tool can also be used to fill a box with waters for GCMC and JAWS-1 simulations, similar to \sphinxcode{\sphinxupquote{distribute\_waters.py}}. In this case the solute is typically a box created by \sphinxcode{\sphinxupquote{make\_gcmcbox.py}} and \sphinxcode{\sphinxupquote{flood}} needs to be specified, see the last example above. This gives a box filled with the bulk number of waters.


\section{split\_jawswater.py}
\label{\detokenize{tools:split-jawswater-py}}

Program to split JAWS-1 waters to a number of PDB-files for JAWS-2


\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{usage}\PYG{p}{:} \PYG{n}{split\PYGZus{}jawswater}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{n}{WATERS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{jaws2box}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Named Arguments}
\label{\detokenize{tools:Named Arguments}}\begin{optionlist}{3cm}
\item [-w, -{-}waters]  
the name of the PDB-file containing the waters.
\item [-o, -{-}out]  
the prefix of the output PDB-files

Default: “”
\item [-{-}jaws2box]  
whether to apply a header box for jaws2 to the pdb files of individual waters

Default: False
\end{optionlist}

\sphinxstylestrong{Examples:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{split\PYGZus{}jawswater}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{n}{waters}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{split\PYGZus{}jawswater}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{n}{waters}\PYG{o}{.}\PYG{n}{pdb} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{jaws2\PYGZus{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Description:}

This tool splits a PDB file containing multiple water molecules into PDB files appropriate for JAWS-2.

For each water molecule in \sphinxcode{\sphinxupquote{pdbfile}} the tool will write a PDB file with individual water molecules named \sphinxcode{\sphinxupquote{outprefix+watN.pdb}} where N is the serial number of the water molecule. Furthermore, the tool will write a PDB file with all the other molecules and name if \sphinxcode{\sphinxupquote{outprefix+notN.pdb}} where again N is the serial number of the water molecule. In these latter PDB-files, the water residue name is changed to that of the bulk water, e.g., \sphinxcode{\sphinxupquote{t3p}} or \sphinxcode{\sphinxupquote{t4p}}.

For instance, if \sphinxcode{\sphinxupquote{waters.pdb}} in the second example above contains 3 water molecule, this tool will create the following files:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jaws2\PYGZus{}wat1}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{jaws2\PYGZus{}wat2}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{jaws2\PYGZus{}wat3}\PYG{o}{.}\PYG{n}{pdb}

\PYG{n}{jaws2\PYGZus{}not1}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{jaws2\PYGZus{}not2}\PYG{o}{.}\PYG{n}{pdb}
\PYG{n}{jaws2\PYGZus{}not3}\PYG{o}{.}\PYG{n}{pdb}
\end{sphinxVerbatim}


\chapter{Test Suite}
\label{\detokenize{testsuite:test-suite}}\label{\detokenize{testsuite::doc}}
The ProtoMS test suite can be found in the \sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests}} directory. It contains a set of Python scripts and all required input files and reference output files to run a sanity check on the ProtoMS code, both the source (Fortran) code and the (Python) tools. In this page you will find a list of the different tests, a brief indication of which part of ProtoMS each of the tests is checking and instructions to run each of the individual tests separately, or all of them as a whole.


\section{Dependencies}
\label{\detokenize{testsuite:dependencies}}
The Python module \sphinxcode{\sphinxupquote{nose}} is required to run the test suite. You can find more information on nose on its website \sphinxcode{\sphinxupquote{nose.readthedocs.org/en/latest/}}.


\section{Running all tests}
\label{\detokenize{testsuite:running-all-tests}}
The simplest and recommended way to run the tests is to run the command \sphinxcode{\sphinxupquote{ctest}} while in the build directory \sphinxcode{\sphinxupquote{\$PROTOMSHOME/build}}.  This will run all tests and report the success or failure of each.  For more information use the command \sphinxcode{\sphinxupquote{ctest -V}} which will print all output from the tests as well as output from both the Python and Fortran components of ProtoMS.

If ProtoMS was compiled without MPI, the following test scripts will not be run:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{test\_mpi\_install.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_gcmc.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_jaws2\_sim.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_reti\_sngl.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_reti\_dbl.py}}

\end{itemize}


\section{Individual tests}
\label{\detokenize{testsuite:individual-tests}}
In this section you will a list of all tests, with a brief explanaition of which part of the ProtoMS code they are testing.

Most of the test scripts define multiple individual tests, a setup test and a simulation test.
From the ProtoMS build directory (i.e. \sphinxcode{\sphinxupquote{\$PROTOMSHOME/build}}), to run all tests within a single test script use \sphinxcode{\sphinxupquote{python ../tests/test\_\textless{}scriptname\textgreater{}.py}}.
To run only a single test stage use \sphinxcode{\sphinxupquote{python ../tests/test\_\textless{}scriptname\textgreater{}.py \textless{}FullTestName\textgreater{}}} or \sphinxcode{\sphinxupquote{ctest -R \textless{}FullTestName\textgreater{}}}


\subsection{List of tests}
\label{\detokenize{testsuite:list-of-tests}}
A list of all Python scripts that correspond to each of the tests is shown below:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{test\_install\_dependencies.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_ligand\_setup.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_parameters\_ff.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_path.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_tools\_protoms.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_prot\_setup.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_equil.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_energies.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_sampling.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_jaws1.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_mpi\_install.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_gcmc.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_jaws2.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_reti\_sngl.py}}

\item {} 
\sphinxcode{\sphinxupquote{test\_reti\_dbl.py}}

\end{itemize}


\subsection{test\_install\_dependencies.py}
\label{\detokenize{testsuite:test-install-dependencies-py}}
\sphinxstylestrong{Coverage}
\begin{quote}

This test covers the requirements for the installation of ProtoMS.  It checks that the AmberTools are installed and available at \sphinxcode{\sphinxupquote{\$AMBERHOME}} and that the Python modules numpy, scipy and matplotlib are available.
\end{quote}


\subsection{test\_ligand\_setup.py}
\label{\detokenize{testsuite:test-ligand-setup-py}}
\sphinxstylestrong{Coverage}
\begin{quote}

Checks that the set up of ligands with the ProtoMS tools generates the expected results.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/setup}}
\end{quote}


\subsection{test\_parameters\_ff.py}
\label{\detokenize{testsuite:test-parameters-ff-py}}
\sphinxstylestrong{Coverage}
\begin{quote}

Checks that all expected parameter files are found in \sphinxcode{\sphinxupquote{\$PROTOMSHOME/parameter}}.
\end{quote}


\subsection{test\_path.py}
\label{\detokenize{testsuite:test-path-py}}
\sphinxstylestrong{Coverage}
\begin{quote}

Checks that \sphinxcode{\sphinxupquote{\$PROTOMSHOME}} has been set correctly.
\end{quote}


\subsection{test\_tools\_protoms.py}
\label{\detokenize{testsuite:test-tools-protoms-py}}
\sphinxstylestrong{Coverage}
\begin{quote}

Checks that all expected Python scripts corresponding to the ProtoMS tools are present in \sphinxcode{\sphinxupquote{\$PROTOMSHOME/tools}}.
\end{quote}


\subsection{test\_prot\_setup.py}
\label{\detokenize{testsuite:test-prot-setup-py}}
\sphinxstylestrong{Contains}
* ProtSetupTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks that the set up of protein and ligand with the ProtoMS tools generates the expected results.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/setup/}}
\end{quote}


\subsection{test\_equil\_prot.py}
\label{\detokenize{testsuite:test-equil-prot-py}}
\sphinxstylestrong{Contains}
* EquilSetupTest
* EquilSimulationTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{equilibration}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/equil/}}
\end{quote}


\subsection{test\_energies.py}
\label{\detokenize{testsuite:test-energies-py}}
\sphinxstylestrong{Contains}
* EnergiesSimulationTip3pTest
* EnergiesSimulationTip4pTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks the generation of correct energies for different water models used as solvent.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/energies/}}
\end{quote}


\subsection{test\_sampling.py}
\label{\detokenize{testsuite:test-sampling-py}}
\sphinxstylestrong{Contains}
* SamplingSetupTest
* SamplingSimulationTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{sampling}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/sampling/}}
\end{quote}


\subsection{test\_jaws1.py}
\label{\detokenize{testsuite:test-jaws1-py}}
\sphinxstylestrong{Contains}
* Jaws1SetupTest
* Jaws1SimulationTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{jaws1}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/jaws1/}}
\end{quote}


\subsection{test\_mpi\_install.py}
\label{\detokenize{testsuite:test-mpi-install-py}}
\sphinxstylestrong{Coverage}
\begin{quote}

Checks that MPI is available for running simulations requiring it.
\end{quote}


\subsection{test\_gcmc.py}
\label{\detokenize{testsuite:test-gcmc-py}}
\sphinxstylestrong{Contains}
GcmcSetupBoxTest
GcmcSetupTest
GcmcSimulationTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{gcmc}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/gcmc/}}
\end{quote}


\subsection{test\_jaws2.py}
\label{\detokenize{testsuite:test-jaws2-py}}
\sphinxstylestrong{Contains}
* Jaws2SetupTest
* Jaws2SimulationTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{jaws2}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/jaws2/}}
\end{quote}


\subsection{test\_reti\_sngl.py}
\label{\detokenize{testsuite:test-reti-sngl-py}}
\sphinxstylestrong{Contains}
* RetiSnglSetupTest
* RetiSnglSimulationFreeTest
* RetiSnglSimulationGasTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{singletopology}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/RETI\_sngl/}}
\end{quote}


\subsection{test\_reti\_dbl.py}
\label{\detokenize{testsuite:test-reti-dbl-py}}
\sphinxstylestrong{Contains}
* RetiDblSetupTest
* RetiDblSimulationTest

\sphinxstylestrong{Coverage}
\begin{quote}

Checks both setup and run of the \sphinxcode{\sphinxupquote{dualtopology}} simulation type among those offered by \sphinxcode{\sphinxupquote{protoms.py}}.
\end{quote}

\sphinxstylestrong{Reference Data Location}
\begin{quote}

\sphinxcode{\sphinxupquote{\$PROTOMSHOME/tests/RETI\_dbl/}}
\end{quote}



\renewcommand{\indexname}{Index}
\printindex
\end{document}