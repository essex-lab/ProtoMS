      subroutine simulate(nconfig)
      include 'dimensions.inc'
      include 'enums.inc'
      include 'pressure.inc'
      include 'flags.inc'
      include 'printer.inc'
      include 'moves.inc'
      include 'stacks.inc'
      include 'averages.inc'
      include 'parallel.inc'
      include 'mpif.h'
c################################################################
c
c       This routine actually runs a simulation with some
c       data collection! It produces the averages that are
c       necessary to generate thermodynamic quantities,
c       or records energies/lambdas that are necessary for
c       umbrella type or generalised ensemble type simulations!
c
c#################################################################

      integer nconfig
      integer i,j,imov     ,linelength
      integer NAcceptedMoves,NTotalMoves
      integer getMoveType
      logical residueMove,titrationMove,solventMove,soluteMove
      logical rotamerMove
      logical volumeMove,sampleMove
      logical insertionMove,deletionMove
      logical gcsoluteMove,thetaMove
      logical templ
                     
c     return if there are no configurations
      if (nconfig.le.0) return
                               
c     check that the initial total energy has been calculated
      call checkGotTotal

      NAcceptedMoves = 0
      NTotalMoves = 0
      do i=1,nconfig
        NTotalMoves = NTotalMoves + 1
c       obtain the move type based on probabilities entered by the user
        imov = getMoveType()
        if (imov.eq.TRYPROTEIN) then
          templ = residueMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYSOLUTE) then
          templ = soluteMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYTITRATE) then
          templ = titrationMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYSOLVENT) then
          templ = solventMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYVOLUME) then
          templ = volumeMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYROTAMER) then
          templ = rotamerMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYINSERTION) then
          templ = insertionMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYDELETION) then
          templ = deletionMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYGCSOLUTE) then
          templ = gcsoluteMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYSAMPLE) then
          templ = sampleMove(UPDATEENERGY,i,0)
        else if (imov.eq.TRYTHETA) then
          templ = thetaMove(UPDATEENERGY,i,0)

        else
          write(printstring,*) "Problems sorting out the move type! ",imov
          call printLine(WARNING,printstring)
          call printLine(WARNING,"This is probably a programming bug!")
          templ = .false.
        endif
        if (templ) NAcceptedMoves = NAcceptedMoves + 1

c       now average the energies
        call calcAverageEnergy
        
        if (doLambdaRE.and.(lrefreq.gt.0).and.(i.gt.1).and.(mod(i,lrefreq).eq.0)) then
          write(printstring,*)"Results up to snapshot",i
          call prettyLine(RESULTS,printstring)
          call printAverages
          call lambdaRE
c          if (myid.eq.0) write(*,"(I6,50F5.2)")i,(lambdaval(lambda2task(j)+1),j=1,nlambdas)
c          write(6,*)"Task = ",myid," lambda= ",mylambda," folder = ",lrefolder(1:lineLength(lrefolder))
        endif

      enddo

      if (NTotalMoves.gt.0) then
        write(printstring,*) "Data collection complete. Attempted/accepted moves ",
     .                             NTotalMoves,NAcceptedMoves
        call printLine(INFO,printstring)
        
        if (streamhandle(ACCPT).ge.0) call printAttemptAccept
      endif
      if (doLambdaRE.and.(lrefreq.gt.0)) then       
        write(printstring,"(A,2I6,A,F8.3,A)")
     .     "Attempted/successful lambda swaps: ",nlretry,nlreswap," (",dble(nlreswap)/dble(nlretry)*100,"%)" 
        call printLine(INFO,printstring)
      endif
         
      if (SolventBox) then
        write(printstring,*) "Final volume = ",volume," A^3"
        call prettyLine(INFO,printstring)
      endif

      return
      end
